문제 번호,제목,등급,문제,입력 설명,출력 설명,예제 입력,예제 출력,힌트
8889,등고선 지도,Platinum II,"한려해상국립공원은 한반도의 남쪽에 있으며, 120km에 걸친 독특한 해양 생태계를 가지고 있다. 공원은 360개 이상의 섬으로 이루어져 있으며, 섬의 크기도 모두 제각각 다르다. 69개의 무인도와 30개의 유인도로 이루어진 아름다운 수로는 바다의 보석과 같다는 찬사를 받는다.


공원 관리자 김상근은 등고선을 이용해 공원 내의 모든 섬의 고도를 조사하려고 한다. 등고선은 해발 고도가 같은 지점을 연결한 곡선이며, 볼록한 닫힌 곡선이다. (그림 1)


한려해상국립공원의 섬을 나타내는 등고선은 서로 겹치지 않으며, 타원과 같은 단순 볼록 곡선이며 닫혀있다. 


컴퓨터는 등고선 지도를 디지털 등고선 지도로 변형해서 사용한다. 디지털 등고선 지도의 등고선은 볼록 직교 다각형 (그림 2) 이다. 직교 다각형이란 모든 변이 수직 또는 수평인 다각형이다. 직교 다각형 P가 볼록이 되려면, P의 모든 내부와 수직선 또는 수평선과의 교점이 비어있거나 선분이어야 한다.


가장 바깥에 있는 등고선은 레벨 1이다. 등고선 c를 둘러싼 등고선의 레벨이 k인 경우에 c의 레벨은 k+1이다. 그림 2에의 지도에서 가장 높은 등고선의 레벨은 5이다.




등고선 n개로 이루어진 디지털 등고선 지도가 주어진다. 이때, 가장 높은 등고선의 레벨을 구하는 프로그램을 작성하시오.","첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스의 첫째 줄에는 등고선의 개수 m(1 ≤ m ≤ 20,000)이 주어진다. 다음 m개 줄에는 각 등고선의 정보를 나타내는 2k+1개의 정수 k, x
1
, y
1
, x
2
, y
2
, ..., x
k
, y
k
 (4 ≤ k ≤ 100, 1 ≤ x
i
, y
i
 ≤ 10
9
) 가 주어진다. k는 볼록 직교 다각형 Q의 꼭짓점의 개수를 나타내며, (x
i
, y
i
)는 Q의 꼭짓점을 나타낸다. 꼭짓점은 반시계방향으로 주어진다. 두 볼록 직교 다각형이 겹치는 경우는 없다.",각 테스트 케이스마다 가장 높은 등고선의 레벨을 출력한다.,"2
5
4 5 3 14 3 14 12 5 12
4 6 4 13 4 13 11 6 11
4 7 5 12 5 12 10 7 10
4 8 6 11 6 11 9 8 9
4 9 7 10 7 10 8 9 8
4
4 10 7 11 7 11 8 10 8
6 3 7 5 7 5 9 6 9 6 12 3 12
6 8 5 9 5 9 6 12 6 12 9 8 9 
10 9 2 9 3 14 3 14 11 7 11 7 8 6 8 6 4 4 4 4 2","5
3",
2865,나는 위대한 슈퍼스타K,Silver IV,"상근이는 한국 최고의 가수를 뽑는 ""나는 위대한 슈퍼스타K""의 감독이다. 상근이는 다음과 같이 참가자를 선발하려고 한다.


""나는 위대한 슈퍼스타K""의 예선에는 N명이 참가했고, 서로 다른 M개 장르에 대한 오디션을 보았다. 심사위원은 모든 참가자의 각 장르에 대한 능력을 점수로 매겼다. 이 점수는 실수로 나타낸다.


본선에는 총 K명이 나갈 수 있다. 각 참가자는 본선에서 단 하나의 장르만 부를 수 있고, 이 장르는 상근이가 정해준다. 한 사람이 여러 장르를 부를 수는 없지만, 여러 사람이 같은 장르를 부를 수는 있다.


모든 참가자의 각 장르에 대한 능력이 주어진다. 이때, 능력의 합이 최대가 되도록 참가자와 장르를 선택하는 프로그램을 작성하시오.","첫째 줄에 N, M, K가 주어진다. (1 ≤ M ≤ 100, 1 ≤ K ≤ N ≤ 100)


다음 M개의 줄은 각 장르에 대한 참가자의 능력이 주어진다. 이 줄에는 N개의 (i, s)쌍이 주어진다. 여기서 i는 참가자의 번호, s는 그 참가자의 장르에 대한 능력이다. 이 쌍은 능력이 감소하는 순서대로 주어진다. 참가자의 번호는 1부터 N까지 이다.


각 줄에 모든 학생은 한 번씩 등장한다.",첫째 줄에 본선 참가자의 능력의 합을 소수점 첫째자리까지 반올림해 출력한다.,"3 2 2
2 3.0 1 0.2 3 0.1
3 1.0 2 0.5 1 0.2

---

4 4 3
4 5.0 2 4.0 3 2.0 1 1.0
2 2.0 3 1.0 1 0.5 4 0.3
4 6.0 3 5.0 2 2.0 1 0.0
1 4.0 2 3.0 4 0.6 3 0.3","4.0

---

15.0",
20054,트리 가짓수 세기,Platinum V,"이진 검색 트리(BST, Binary Search Tree)는 모든 노드가 최대 $2$개의 자식 노드를 가지고 있는 트리이다. 만약 어떤 노드에 쓰여 있는 수가 $X$라면, 그 노드의 왼쪽 서브트리에는 $X$보다 작은 수, 오른쪽 서브트리에는 $X$보다 큰 수만 저장되어 있어야 한다.


다음은 BST의 삽입하는 함수를 수도-코드(pseudo code)로 작성한 것이다.


insert(number X, node N)
    if X가 노드 N에 있는 수보다 작다면
        if N의 왼쪽 자식이 없다면
            X를 포함하는 새 노드를 만든 뒤, N의 왼쪽 자식으로 만든다
        else
            insert(X, N의 왼쪽 자식)
    else (X가 노드 N에 있는 수보다 크다면)
        if N의 오른쪽 자식이 없다면
            X를 포함하는 새 노드를 만든 뒤, N의 오른쪽 자식으로 만든다
        else
            insert(X, N의 오른쪽 자식)


첫 번째로 삽입하는 수를 루트로 놓고, 그 뒤로 삽입하는 모든 수 X에 대해서 insert(X, root)를 호출하게 된다.


트리의 높이는 루트 노드로부터 리프 노드까지의 경로 중 가장 긴 경로 위에 존재하는 노드의 개수를 뜻한다. (리프 노드는 자식 노드가 없는 것을 의미한다.)


$1$부터 $N$까지의 수를 BST에 삽입하려고 한다. 삽입 순서를 자유롭게 정할 수 있을 때 만들어지는 높이가 $K$ 이하인 BST의 가짓수를 구해보자. (BST의 루트 노드는 높이가 1로 가정한다.)


$2$ $1$ $3$ 순으로 넣었을 때 생성되는 BST와 $2$ $3$ $1$ 순으로 넣었을 때 생성되는 BST는 같은 경우이고, $3$ $2$ $1$ $4$와 $2$ $1$ $3$ $4$ 순으로 넣었을 때 생성되는 BST는 서로 다른 경우이다.


구하려는 경우의 수는 매우 커질 수 있으므로 답을 $10^9+7$로 나눈 나머지를 출력한다.","첫 번째 줄에 두 정수 $N$, $K$이 공백으로 구분되어 주어진다. ($1 \leq N \leq 3500,\, 1 \leq K \leq 12$)",만들어지는 BST의 경우의 수를 $10^9+7$로 나눈 나머지를 출력한다.,"1 1

---

4 2

---

5 3","1

---

0

---

6",
14434,놀이기구1,Gold I,"1번부터 N번까지 번호가 매겨져있는 총 N명의 아이들이 있다. 아이들은 놀이공원에 가는 걸 좋아하지만 아이들은 키제한 때문에 타지 못하는 일이 빈번하다. 놀이기구는 1번부터 M번까지 총 M개가 있으며, 모든 놀이기구는 정원이 2명이다. 아이 i와 아이 j가 함께 놀이기구 k를 타려면, (아이 i의 키) + (아이 j의 키) ≥ (놀이기구 k의 키제한) 이 성립해야한다.


이러한 (i, j, k) 쌍이 Q개 주어지는데, 이 뜻은 아이 i와 아이 j가 놀이기구 k를 타려고 매일 시도한다는 뜻이다.


아이들의 처음 키는 모두 0cm이기 때문에 처음에는 모두 놀이기구를 타지 못하지만, 아이들은 성장기이므로 키가 쑥쑥 자란다.


구체적으로, 첫날부터 K번째 날까지 매일매일 한 명씩 키가 1씩 자라게 된다. 매일매일 누구의 키가 자라는지 주어질 때, 첫날부터 K번째 날까지 각 날마다 아이들이 놀이기구를 총 몇 번 타는지 출력하는 프로그램을 작성하여라. (단, 놀이기구를 타는 것 보다 키가 자라는 것이 먼저 일어난다)","첫째 줄에 아이들의 수 N, 놀이기구의 수 M, 기간 K, 질문의 개수 Q가 주어진다. (1 ≤ N, M, K, Q ≤ 200,000)


둘째 줄에는 놀이기구들의 키제한이 순서대로 주어진다. (1 ≤ 키제한 ≤ 200,000)


셋째 줄에는 각 날에 키가 자라는 아이의 번호가 총 K개 주어진다. (1 ≤ 번호 ≤ N)


그 다음 Q줄에 걸쳐 (i, j, k) 쌍이 주어진다. (1 ≤ i, j ≤ N, 1 ≤ k ≤ M)",K줄에 걸쳐 각 날마다 아이들이 놀이기구를 총 몇번 타는지 출력한다.,"5 3 4 4
4 3 1
2 2 5 1
1 2 2
1 2 1
1 5 2
3 5 3","0
0
1
2","둘째날까지 아이들은 놀이기구를 타지 못한다.


셋째날에는 아이 3과 아이 5가 놀이기구 3을 탈 수 있다.


넷째날에는 아이 3과 아이 5가 놀이기구 3을 탈 수 있고, 아이 1과 아이 2가 놀이기구 2를 탈 수 있다."
20554,경로 수정하기,Platinum IV,"오른쪽으로 갈수록 $x$좌표가 증가하고, 위쪽으로 갈수록 $y$좌표가 증가하는 일반적인 좌표평면 상의 $(0,0)$에 사는 석표는 $(X,Y)$에 있는 준호의 집으로 가려고 한다. 석표는 1초마다 수평 또는 수직 방향으로 1만큼 이동하는데, 석표의 이동 계획을 정리한 길이 $N$의 문자열을 $S$라고 한다. $S$의 $i$번째 문자가 
L, R, D, U
인지에 따라 석표는 각각 왼쪽, 오른쪽, 아래쪽, 위쪽으로 1만큼 이동한다. 


덜렁이인 석표가 세운 이동 계획은 정확하지 않을 수 있다. 이동 계획이 정확하다는 것은 모든 이동을 완료한 후 석표가 $(X,Y)$에 있다는 것을 의미한다. 중간에 $(X,Y)$를 도달했어도 마지막에 $(X,Y)$에 있지 않는다면 정확한 이동 계획이 아니다.


석표는 $S$의 한 문자를 다른 문자로 수정하는 것을 반복해, 정확한 이동 계획으로 바꾸려고 한다. 석표는 힘들게 $4^N$가지 경우를 모두 따져서 필요한 최소 수정 횟수를 구했다. 그런데 슬프게도 준호가 이사를 갔다는 소식이 전해졌다. 준호는 $Q$개의 위치 중 하나로 이동했다고 한다. $i$번째 위치는 $(X_i,Y_i)$이다. 이제 석표는 $Q$개의 위치 각각에 대해 필요한 최소 수정 횟수를 구해야 한다.


석표는 $Q$번 최소 수정 횟수를 구해야 한다는 사실에 그만 정신을 잃고 말았다. 석표를 위해 대신 답을 구해주자.","첫 줄에 $N$과 $Q$가 공백으로 구분되어 주어진다. $(1 \leq N,Q \leq 300\,000)$


다음 줄에 $S$가 주어진다.


이후 $Q$개의 줄에 걸쳐 $X_i$와 $Y_i$가 공백으로 구분되어 주어진다. $(|X_i|,|Y_i| \leq 300\,000)$","각 위치에 대해 정확한 이동 계획으로 바꾸는 것이 불가능하다면 -1을, 그렇지 않다면 필요한 최소 수정 횟수를 줄바꿈으로 구분하여 출력한다.","10 3
DLRURDRLDU
2 3
3 3
-4 8","-1
3
-1",
25353,게임의 꽃,Ruby V,"여러분은 삼단논법을 아는가? blackking은 잘 알고 있다.




PS는 게임이다. 트리와 쿼리는 PS의 꽃이다. 따라서 트리와 쿼리는 
게임의 꽃
이다.


- blackking26




$N$개의 정점으로 이루어진 트리(무방향 사이클이 없는 연결 그래프)가 있다. 정점은 $1$번부터 $N$번까지 번호가 매겨져 있고 간선은 $1$번부터 $N-1$번까지 번호가 매겨져 있다. $i$번 정점에는 정수 가중치 $A_{i}$가 부여되어 있다.


정점열 $v_{1}, v_{2}, \cdots, v_{k}$에 대해 $v_{i}$와 $v_{i+1}$ 사이에 간선이 존재하고 $A_{v_{i}} < A_{v_{i+1}}$ $(1 ≤ i ≤ k-1)$ 이라면 $v_{1}, v_{2}, \cdots, v_{k}$은 길이가 $k$인 
증가 경로
이다.


주어진 트리에서 
증가 경로
 중 길이가 가장 긴 경로의 길이를 구한 후, 아래의 쿼리를 처리하는 프로그램을 작성하시오.




$i$ $x$: $i$번 정점의 가중치, 즉 $A_{i}$를 $x$로 바꾼 후 
증가 경로
 중 길이가 가장 긴 경로의 길이를 출력한다.","첫째 줄에 트리의 크기 $N$과 쿼리의 개수 $M$이 주어진다. 


둘째 줄에 각 정점의 가중치 $A_{i}$가 공백으로 구분되어 주어진다. 


이후 $N-1$개의 줄에는 각 간선이 연결하는 두 정점 번호 $u, v$가 주어진다. 


이후 $M$개의 줄에는 쿼리의 정보 $i, x$가 주어진다.","첫 번째 줄에 주어진 트리에서 
증가 경로
 중 길이가 가장 긴 경로의 길이를 출력한다.


이후 $M$개의 줄에 쿼리의 결과를 한 줄에 하나씩 순서대로 출력한다.","5 4
3 3 5 2 4
1 2
1 3
2 4
2 5
1 4
2 7
5 8
1 6","3
4
2
3
4",
4802,함수 오버로딩,Platinum I,"프로그래머는 다양한 프로그래밍언어에서 함수를 오버로드할 수 있다. 함수 오버로드란 같은 함수의 이름을 가지고 있으나, 매개변수가 다른 함수이다. 그러나, Ada와 같은 언어에서는 리턴 타입도 오버로드할 수 있다. 즉, 같은 이름과 매개변수를 가지고 있으나, 리턴타입이 다를 수도 있는 것이다.


다음은 함수 오버로딩의 예이다.



char f(float x, int y)
char f(float x, float y)
float f(float x, float y)
float g(float x, int y)
float g(int x, float y)



위와 같이 함수 선언이 있을 때, 아래와 같은 변수 선언과 함수 호출을 포함한 프로그램을 작성할 수 있다.



float a = 1.0, b = 2.0;
int c = 3;
float d = g(c, f(a, b));



f
의 처음 두 선언은 위의 함수 
f
에 해당하지 않는다. 하지만, 세 번째 함수는 
f(<float>, <float>)
와 같은 형식이라 매개변수의 타입이 같고, 리턴 타입도 
g(<int>, <float>)
의 
float
과 같기 때문에 해당한다. 따라서, 3번째 
f
와 두 번째 
g
를 사용할 수 있다.


이렇게 3번째 
f
와 2번째 
g
를 사용했기 때문에, 다음과 같이 숫자와 함께 표현할 수 있다.



d = g2(c, f3(a, b))



하지만, 위의 함수 선언을 이용해서 
c = g(a, f(a, c))
는 사용할 수 없다.


마지막으로 다음과 같은 함수 선언이 있다고 하자.



float x(float w)
int x(float w)
char y(float v)
char y(int v)



위와 같은 선언에서 다음과 같은 함수 호출은 애매모호(ambiguous)하기 때문에 사용할 수 없다.



float a = 1.0
char c = y(x(a))","입력은 여러 개의 함수 선언과 함수 호출으로 이루어져 있다. 함수 선언은 한 줄에 하나씩 주어지며, 다음과 같은 형태이다.



name num_params param(1) param(2) ... param(num_params) rettype


name은 함수의 이름이고, param(i)는 i번째 매개변수의 데이터 타입이다. rettype은 함수의 리턴값의 데이터 타입이다. (이 문제에서 void 함수는 없다) num_params는 적어도 1이고 많아야 9이다. 매개변수는 이름을 갖지 않는다. 함수의 이름은 알파벳 소문자 한글자이고, 데이터 타입은 알파벳 대문자 한글자이다. 같은 이름을 갖는 다른 함수는 연속으로 나타나며, 같은 이름을 갖는 함수는 많아야 500개이다. 두 함수의 선언이 정확하게 일치하는 경우는 없다.


문제에서 설명한 것 처럼 함수에 숫자를 붙여서 나타내는 것의 숫자를 시리얼 넘버라고 한다. 이때, 시리얼 넘버는 새로운 함수의 이름이 시작할 때 1이 되고, 선언이 나타날때마다 1씩 증가한다.


함수 선언의 마지막에는 '#'가 주어진다. 그 다음줄부터 함수 호출이 한 줄에 하나씩 주어진다.


함수 호출은 다음과 같은 문법을 따른다.



<function_call> := <data_type> = <right_hand_side>
<right_hand_side> := <fname> <num_params> <param_list>
<param_list> := <param> | <param_list> <param>
<param> := <data_type> | <right_hand_side>
<data_type> := <upper_case_letter>
<num_params> := '1' | '2' | ... | '9'
<fname> := <lower_case_letter>



:=와 |는 문법 정의에만 등장하는 기호이고, 실제 함수 호출에는 나타나지 않는다. 각 함수 호출에서 호출하는 함수의 이름은 500개를 넘지 않는다. 함수 호출의 마지막 줄에는 '#'가 하나 주어진다.","입력으로 주어진 각 함수 호출에 대해서, 만약 어떤 함수를 사용했는지 유일하게 결정할 수 있다면, 입력 함수 호출에서 함수의 이름에 시리얼 넘버만 추가한 형태로 출력한다. 만약, 해당하는 함수가 없어서 호출할 수 없다면 ""impossible""을 출력하고, 애매모호해서 호출하는 방법이 여러 가지라면, ""ambiguous""를 출력하고, 경우의 수를 출력한다. 만약, 1000가지를 넘는 방법으로 호출할 수 있다면 ""> 1000""을 경우의 수 대신 출력한다.","f 2 A B C
f 2 A A C
f 2 A A A
g 2 A B A
g 2 B A A
x 1 A A
x 1 A B
y 1 A C
y 1 B C
h 2 A B E
h 2 C D F
k 2 E F A
#
A = g 2 B f 2 A A
B = g 2 A f 2 A B
C = y 1 x 1 A
A = k 2 h 2 A B h 2 C D
#","A = g2 2 B f3 2 A A
impossible
ambiguous 2
A = k1 2 h1 2 A B h2 2 C D",
17415,Huge Integer!,Platinum III,"$N$개의 정수, $B_1, B_2, \cdots, B_N$과 $N$개의 수열, $C_1, C_2, \cdots, C_N$에 대하여, $\lambda$를 다음과 같이 정의하자.


$\lambda = {\overline{C_{1,1} C_{1,2}\cdots C_{1,B_1} C_{2,1} C_{2,2} \cdots C_{2,B_2} \cdots\cdots C_{N,1} C_{N,2} \cdots C_{N,B_N}}}_{(10)}$


$1 \le i \le N$인 정수 $i$에 대하여, $C_{i,1} = C_{i,2} = \cdots = C_{i,B_i} = A_i$를 만족할 때, $\lambda$를 $K$로 나눈 나머지를 구하는 프로그램을 작성하시오.","첫 번째 줄에 두 개의 정수 $N$과 $K$가 사이에 공백을 두고 주어진다.


두번째 줄부터 $N$개의 줄에 걸쳐, $A$와 $B$의 정보가 주어진다.


$(i+1)$번째 줄에는 두 정수 $A_i$와 $B_i$가 사이에 공백을 두고 주어진다$(1 \le i \le N)$.


$1 \le i \le N$인 정수 $i$에 대하여, $0 \le A_i \le 9$와 $1 \le B_i \le 10^{18}$을 만족한다.


모든 입력 데이터에 대하여, $1 \le N \le 2 \times 10^6$와 $1 \le K \le 5 \times 10^5$을 만족한다.",첫 번째 줄에 $\lambda$를 $K$로 나눈 나머지를 출력한다.,"4 2
0 1
1 2
2 1
3 3",1,
23817,포항항,Gold I,"당신은 에브리타임을 둘러보다가 한 글을 보았다!




이 글을 보고 공포에 사로잡힌 당신은 주변에 과메기를 파는 식당에 달려가기로 하였다. 하지만 요즘 과메기가 인기가 많아 식당에서는 1인분씩만 팔고 있다. 따라서 당신은 총 다섯 식당을 찾아가 과메기를 먹어야 한다. 슬슬 포항항항 하며 웃음이 나오려고 한다. 최대한 빨리 과메기를 먹고 저주를 풀자!


$N \times M$ 크기의 지도가 주어진다. 지도에서 당신의 위치는 'S', 식당의 위치는 'K'로 주어진다. 또한, 지도 중간중간에 장애물이 존재하며, 장애물은 'X'로 주어진다. 당신은 지도 상에서 한 칸씩 상하좌우로 움직일 수 있고, 한 칸을 이동하는데 1분이 걸린다. 장애물이 있는 칸으로는 이동할 수 없다.


5개의 식당을 방문하는 데 필요한 최소한의 시간을 출력하자.","첫째 줄에 $N, M \, (4 \leq N, M \leq 1,000)$이 주어진다.


그 이후 $N$개의 줄에 걸쳐 각 줄에 길이 $M$의 문자열이 주어진다.


'.'은 빈 칸, 'X'는 장애물, 'S'는 현재 위치, 'K'는 식당을 의미한다 ($1 \leq$ 식당의 수 $\leq 20$).",'S'에서 출발하여 주어진 식당 중 5개의 식당을 방문하는 데 걸리는 최소한의 시간을 출력하여라. 만약 5개의 식당을 방문할 수 없는 경우 $-1$을 출력한다.,"4 4
SKKK
X..X
X..X
K..K

---

4 4
SKKK
XXXX
KKKK
KKKK","11

---

-1","첫번째 예제의 경우 오른쪽 3칸, 왼쪽 1칸, 아래쪽 3칸, 오른쪽 1칸, 왼쪽 3칸으로 총 11칸 이동하여 5개의 식당을 방문할 수 있다.


두번째 예제의 경우 장애물에 가로막혀 5개의 식당을 방문할 수 없다."
13700,완전 범죄,Silver I,"홍익대학교 근처에 있는 오락실에 새로운 게임이 들어왔다. 이 게임을 클리어하려면 방금 막 금은방을 턴 마포구 대도 X가 되어 아무에게도 들키지 않고 X의 집에 무사히 도착해야 한다. 게임은 오직 좌우 버튼 두 개로만 진행되고 규칙은 아래와 같다.




마포구의 모든 건물은 일렬로 나열되어 있고 각 건물에는 1번부터 N번까지 번호가 지정되어 있다. 마포구에는 K개의 경찰서가 있고 경찰 내부에는 이미 X의 얼굴이 알려졌다.


게임이 시작될 때 X는 막 범행을 끝내고 금은방 S 안에 있다.


X는 자신의 집 D에 마포구를 떠날 수 있는 비밀 통로를 만들어놓았다. 따라서 경찰에게 발각되지 않고 무사히 집으로 돌아가야 한다.


좌(←) 버튼을 누르면 후방으로 달리고, 우(→) 버튼을 누르면 전방으로 달린다. X는 마포구 내에서만 이동할 수 있으며, 자신이 오랜 연구 끝에 알아낸 이동 방식을 맹신하여 오직 그 방식으로만 이동한다.


X의 달리기는 남에게 얼굴이 보이지 않을 정도로 매우 빠르다. 현재 X가 a번 건물 안에 있다고 가정하면, 밖으로 나와 전방으로 달려 a+F번 건물 안으로 이동하거나, 후방으로 달려 a-B번 건물 안으로 이동할 수 있다. 단, X의 달리기는 자신도 주체할 수 없을 만큼 빨라서 중간에 멈출 수 없다.


X는 한 번 달리면 너무 힘들어 건물 안에서 10초 동안 휴식을 취해야 한다. 이때 X가 경찰서 안에서 휴식을 취할 경우, 그는 집에 돌아가지 못하고 체포된다.




이 게임은 아직 베타 버전이라 무사히 집으로 가는 방법이 없는 버그도 존재한다.


지언이의 취미는 오락실 게임을 누구보다 빠르게 클리어하는 것이다. 그래서 대도 X가 무사히 집에 도착할 수 있는 여러 방법 중에서도 좌우 버튼을 가장 최소로 눌렀을 때의 횟수를 알고 싶다.


마포구 건물의 개수 N, 털린 금은방 S, 대도 X의 집 D, 앞으로 한 번에 달릴 수 있는 건물 수 F, 뒤로 한 번에 달릴 수 있는 건물 수 B, 마포구 경찰서의 개수 K, 각 경찰서의 건물 번호 l
1
, l
2
, …, l
K
가 주어질 때 대도 X가 무사히 집에 도착하기 위해 버튼을 눌러야 하는 최소 횟수를 출력하는 프로그램을 작성해라.


만약 집으로 가는 방법이 없는 경우를 발견했다면 이 데이터를 게임 회사에 알리기 위해 “BUG FOUND”를 출력한다.","첫째 줄에 N, S, D, F, B, K가 주어지고, K > 0인 경우에는 둘째 줄에 경찰서의 위치 l
1
, l
2
, …, l
K
가 주어진다. (1 ≤ S, D ≤ N ≤ 100000, 0 ≤ F, B ≤ 100000, 0 ≤ K ≤ N/2, S ≠ D ≠ l)","첫째 줄에 대도 X가 건물 S에서 자신의 집 D로 무사히 가기 위해 지언이가 버튼을 눌러야 하는 최소 횟수를 출력한다. 만약, D에 도달할 수 없는 데이터인 경우 “BUG FOUND”를 출력한다.","20 1 20 2 1 4
5 10 15 19

---

20 1 20 2 1 3
5 6 9","14

---

BUG FOUND",
15783,세진 바이러스,Platinum IV,"때는 2118년….


세상의 모든 강과 호수가 말랐다..! 하지만 한 곳..! 인경호는 마르지 않았다. 심지어 지하에서 물이 계속 나왔다. 앞으로도 마르지 않을 것 이다.


인하대학교 학생들은 인경호의 물을 식수로 쓰기 위해 정수 시설을 설치 하기로 했다. 정수 시설은 인경호 안에 N개의 구역에 설치 되었다. 정수 시설이 있는 곳에서는 물을 마실 수 있다. 각 구역은 0번부터 N-1번까지 번호를 써놨다. 그리고 정수 시설에는 깨끗한 물만 흐르게 하기 위해 M개의 파이프를 이용해 연결 시켰다. 파이프로 연결된 정수 시설에서 물은 파이프를 통해 한 방향으로만 흐른다. 예를 들어 1번 정수 시설과 2번 정수 시설이 연결 되었다면 1번 정수 시설에서 2번 정수 시설로만 깨끗한 물이 흐르는 것 이다. 또한 2번 정수 시설과 3번 정수 시설이 연결되어 있다면 1번 정수 시설에서 3번 정수 시설로도 물이 흐른다. 이때 여러 개가 연결 될 수도 있고 하나도 연결 되지 않을 수 있다. 정수 시설을 설치했기 때문에 인하대학교 학생들은 목이 마를때면 모두 인경호의 물을 마신다. 인하대학교는 학생이 굉장히 많기 때문에 모든 정수 시설에서 최소한 1명은 물을 마신다.


100년 째 CTP 회장을 하고 있던 김세진은 이 소식을 듣고 엄청난 계획을 하기 시작했다..!


바로 세진 바이러스를 정수 시설에 넣는 것이다..! 세진 바이러스를 먹게 된다면 모두 다 김세진 처럼 변하게 된다..! 김세진의 목표는 인하대학교 학생들 모두에게 세진 바이러스를 감염 시키는 것이다..! 그러기 위해선 모든 정수 시설에 바이러스를 감염시켜야 하지만 세진 바이러스는 생산비가 굉장히 비싸다…! 바이러스는 물을 따라서 전염되기 때문에 세진이는 물이 흐르는 방향을 잘 파악하여 최소의 바이러스만 생산하려 한다.


이때 생산해야 할 바이러스는 몇 개인지 알아보자..!","입력의 첫째 줄에 시설의 수 N(1 ≤ N ≤ 100000), 파이프의 수 M(1 ≤ M ≤ 100000)이 주어진다. 


이후 두 번째 줄부터 M+1번째 줄 까지  연결된 정수 시설  A(0 ≤ A ≤ N-1), B(0 ≤ B ≤ N-1) 가 주어진다. 만약 A B가 들어온다면 A에서 B로 흐르는 것을 의미한다. 동일한 파이프는 최대 한번만 들어온다.",세진이가 생산해야 할 최소의 바이러스 개수 K를 출력한다.,"10 5
0 5
0 4
2 3
5 9
8 6

---

5 3
0 1
1 2
2 0","5

---

3",
26082,WARBOY,Bronze V,"Furiosa AI에서는 AI 연산에 최적화된 반도체인 WARBOY란 이름의 NPU(Neural Processing Unit)를 만들고 있다. NPU는 인공지능 모델의 학습 및 추론을 기존의 처리 유닛보다 훨씬 빠르게 할 수 있다.




WARBOY는 글로벌 AI 반도체 벤치마크 대회의 이미지 분류, 객체 검출 처리 속도 면에서 가장 좋은 성적을 받았다. 특히, WARBOY는 가격 대비 성능이 경쟁사 제품의 
3배
나 되어 많은 관심을 끌었다.


가격 대비 성능은 아래와 같은 수식으로 계산된다.


\[ \text{가격 대비 성능} = \frac{\text{성능}}{\text{가격}} \]


경쟁사 제품의 가격 $A$, 경쟁사 제품의 성능 $B$, WARBOY의 가격 $C$가 주어질 때, WARBOY의 성능을 구해보자.","첫째 줄에 세 양의 정수 $A$, $B$, $C$($1 \le A, B, C \le 1\,000$)가 공백으로 구분되어 주어진다.


$\mathbf{\mathit{B}}$는 항상 $\mathbf{\mathit{A}}$의 배수이다.",첫째 줄에 WARBOY의 성능을 출력한다.,10 100 7,210,
23053,문자열 X,Diamond III,"길이가 $1$ 이상이고 알파벳 소문자로만 이루어진 미지의 문자열 $X$가 있다.


이 문자열을 알아내기 위해 $N$개의 단서 $S_1$, $S_2$, $\cdots$, $S_N$을 모았다.


$N$개의 단서 중 $X$를 부분문자열(substring)로 가지는 것이 정확히 $K$개 있음을 알게 되었다.


이때 $X$로 가능한 문자열은 몇 개가 있을까?","첫째 줄에 두 정수 $N$과 $K$가 주어진다. ($1 \le N \le 500\,000$, $1 \le K \le N$)


이후 $N$개 줄에 걸쳐 알파벳 소문자로만 이루어진 문자열 $S_i$가 각각 주어진다. ($1 \le |S_i| \le 500\,000$, $|S_1| + |S_2| + \cdots + |S_N| \le 500\,000$)",첫째 줄에 $X$로 가능한 문자열의 개수를 출력한다.,"5 3
bridgetown
georgetown
freetown
capetown
kingstown

---

5 5
bridgetown
georgetown
freetown
capetown
kingstown

---

3 2
aaaaa
bbbb
ccc","2

---

10

---

0","첫 번째 예제에서 $X$로 가능한 문자열은 
g
, 
r
가 있다.


두 번째 예제에서 $X$로 가능한 문자열은 
t
, 
o
, 
w
, 
n
, 
to
, 
ow
, 
wn
, 
tow
, 
own
, 
town
이 있다.


문자열 $A$가 문자열 $B$를 부분문자열로 가진다는 것은 $A$의 양 끝에서 각각 $0$개 이상의 문자를 지워 $B$를 만들 수 있음을 의미한다."
1194,"달이 차오른다, 가자.",Gold I,"지금 민식이가 계획한 여행은 달이 맨 처음 뜨기 시작할 때 부터, 준비했던 여행길이다. 하지만, 매번 달이 차오를 때마다 민식이는 어쩔 수 없는 현실의 벽 앞에서 다짐을 포기하고 말았다.


민식이는 매번 자신의 다짐을 말하려고 노력했지만, 말을 하면 아무도 못 알아들을 것만 같아서, 지레 겁먹고 벙어리가 되어버렸다. 결국 민식이는 모두 잠든 새벽 네시 반쯤 홀로 일어나, 창 밖에 떠있는 달을 보았다.


하루밖에 남지 않았다. 달은 내일이면 다 차오른다. 이번이 마지막기회다. 이걸 놓치면 영영 못간다.


영식이는 민식이가 오늘도 여태것처럼 그냥 잠 들어버려서 못 갈지도 모른다고 생각했다. 하지만 그러기엔 민식이의 눈에는 저기 뜬 달이 너무나 떨렸다.


민식이는 지금 미로 속에 있다. 미로는 직사각형 모양이고, 여행길을 떠나기 위해 미로를 탈출하려고 한다. 미로는 다음과 같이 구성되어져있다.




빈 칸: 언제나 이동할 수 있다. ('.')


벽: 절대 이동할 수 없다. ('#')


열쇠: 언제나 이동할 수 있다. 이 곳에 처음 들어가면 열쇠를 집는다. ('a', 'b', 'c', 'd', 'e', 'f')


문: 대응하는 열쇠가 있을 때만 이동할 수 있다. ('A', 'B', 'C', 'D', 'E', 'F')


민식이의 현재 위치: 빈 곳이고, 민식이가 현재 서 있는 곳이다. ('0')


출구: 달이 차오르기 때문에, 민식이가 가야하는 곳이다. 이 곳에 오면 미로를 탈출한다. ('1')




달이 차오르는 기회를 놓치지 않기 위해서, 미로를 탈출하려고 한다. 한 번의 움직임은 현재 위치에서 수평이나 수직으로 한 칸 이동하는 것이다.


민식이가 미로를 탈출하는데 걸리는 이동 횟수의 최솟값을 구하는 프로그램을 작성하시오.","첫째 줄에 미로의 세로 크기 N과 가로 크기 M이 주어진다. (1 ≤ N, M ≤ 50) 둘째 줄부터 N개의 줄에 미로의 모양이 주어진다. 같은 타입의 열쇠가 여러 개 있을 수 있고, 문도 마찬가지이다. 그리고, 문에 대응하는 열쇠가 없을 수도 있다. '0'은 한 개, '1'은 적어도 한 개 있다. 열쇠는 여러 번 사용할 수 있다.","첫째 줄에 민식이가 미로를 탈출하는데 드는 이동 횟수의 최솟값을 출력한다. 만약 민식이가 미로를 탈출 할 수 없으면, -1을 출력한다.","1 7
f0.F..1

---

5 5
....1
#1###
.1.#0
....A
.1.#.

---

7 8
a#c#eF.1
.#.#.#..
.#B#D###
0....F.1
C#E#A###
.#.#.#..
d#f#bF.1

---

3 4
1..0
###.
1...

---

3 5
..0..
.###.
..1.A

---

4 5
0....
.#B#A
.#.#.
b#a#1

---

1 11
c.0.C.C.C.1

---

3 6
###...
#0A.1a
###...","7

---

-1

---

55

---

3

---

6

---

19

---

12

---

-1",
2919,카드 놀이,Platinum I,"솔리테어는 혼자 하는 카드 게임을 총칭하는 말이다. 창영이는 새로운 솔리테어를 만들었다. 이 게임은 숫자가 쓰여 있는 카드를 이용한다. 맨 처음에 카드를 섞고, N개의 그룹으로 나눈다. 이 그룹에 포함되어있는 카드의 개수는 모두 같지 않을 수도 있다. 각 그룹의 카드는 놓은 순서대로 한 줄로 놓여져 있다.


각 턴에서 플레이어는 그룹 하나를 고른 다음에, 그룹의 가장 첫 번째 위치에 있는 카드를 정답 그룹의 가장 뒤에 놓는다. 그럼 고른 그룹의 두 번째에 있던 카드가 가장 첫 번쨰 위치가 된다.


정답 그룹에 놓은 카드는 중간에 제거하거나 교체할 수 없고, 순서를 바꿀 수 없다.


게임은 모든 카드가 정답 그룹에 놓이게 되면 게임은 끝난다. 이 게임의 목표는 모든 카드를 정답 그룹에 놓는 것이다. 이때, 가장 좋은 정답 그룹을 만들려고 한다. 두 그룹 A와 B가 있을 때, 이를 수열로 생각한 다음에 사전순으로 앞설 수록 좋은 그룹이다.


가능한 가장 좋은 그룹을 찾는 프로그램을 작성하시오.","첫째 줄에 그룹의 개수 N(1 ≤ N ≤ 1,000)이 주어진다. 다음 줄부터 N개 줄에는 각 그룹에 있는 수의 개수 L(1 ≤ L ≤ 1,000)이 주어지고, 다음에는 그룹에 있는 수 L개가 앞에있는 수부터 순서대로 주어진다. 그룹에 있는 수는 100,000,000보다 작거나 같은 양의 정수이다.",첫째 줄에 가장 좋은 정답 그룹을 공백으로 구분해서 출력한다.,"3
1 2
1 100
1 1

---

2
5 10 20 30 40 50
2 28 27

---

2
3 5 1 2
3 5 1 1","1 2 100

---

10 20 28 27 30 40 50

---

5 1 1 5 1 2",
3876,sed 이용,Gold IV,"sed는 입력으로 주어지는 문자열에 등장하는 문자열 α를 다른 문자열 β로 바꾸는데 사용되는 리눅스 유틸이다. 여기서 입력으로 주어지는 문자열은 파일의 각 한 줄이다. sed는 다음과 같은 2가지 과정을 거친다.




입력 문자열에서 겹치지 않는 α를 표시한다. 이때, α가 서로 겹칠 수는 있다. 만약, 겹치지 않게 선택하는 경우가 여러 가지 있을 때는 가장 왼쪽 것을 선택한다.


위에서 표시한 모둔 문자열 α를 문자열 β로 바꾼다. 나머지 문자는 바꾸지 않고 그대로 놔둔다.




예를 들어, α가 ""aa""이고, β가 ""bca"", 입력 문자열이 ""aaxaaa""라면 sed를 실행한 결과는 ""bcaxbcaa""가 된다. (""aaxbcaa"", ""bcaxabca""는 될 수 없다) 이 결과 ""bcaxbcaa""를 가지고 다시 sed를 실행하면 결과는 ""bcaxbcbca""가 된다.


문자열을 바꾸는 규칙의 쌍 (α
i
, β
i
) (i = 1,2,...,n), 초기 문자열 γ, 최종 문자열 δ가 주어진다. 이때, sed를 이용해서 γ를 δ로 바꿀 때, 문자열 바꾸는 회수의 최솟값을 구하려고 한다.


하나의 규칙(α
i
, β
i
)은 위에서 설명한 것 같이, 입력 문자열에서 겹치지 않는 모든 부분 문자열 α
i
를 β
i
로 동시에 바꾸는 것을 의미한다.


한 규칙(α
i
, β
i
)을 여러 번 사용해도 되고, 사용하지 않아도 된다.","입력은 여러 개의 테스트 케이스로 이루어져 있다. 각 테스트 케이스는 다음과 같은 형식이다.



n
α
1
 β
1

α
2
 β
2

...
α
n
 β
n

γ
δ


n은 문자열을 바꾸는 규칙의 쌍의 개수이다. α
i
와 β
i
는 공백으로 구분되어 있으며, 1 ≤ |α
i
| < |β
i
| ≤ 10을 만족한다. (|s|는 문자열 s의 길이) 모든 i≠j에 대해서 α
i
≠α
j
이며, n ≤ 10, 1 ≤ |γ| < |δ| ≤ 10 이다. 모든 문자열을 알파벳 소문자로만 이루어져 있고, 입력의 마지막 줄에는 0이 하나 주어진다.","각 테스트 케이스에 대해서, γ를 δ로 바꿀 때 필요한 문자열 바꾸는 회수의 최솟값을 출력한다. 만약 γ를 δ로 바꿀 수 없다면, -1을 출력한다.","2
a bb
b aa
a
bbbbbbbb
1
a aa
a
aaaaa
3
ab aab
abc aadc
ad dee
abc
deeeeeeeec
10
a abc
b bai
c acf
d bed
e abh
f fag
g abe
h bag
i aaj
j bbb
a
abacfaabe
0","3
-1
7
4",
6612,개미의 이동,Gold I,"개미 N마리가 나무 판자 위에서 행진을 하고 있다. 개미는 1초에 1cm씩 앞으로 전진한다. 두 개미가 같은 곳에서 만나게 되면, 즉시 방향을 바꾸고 반대 방향으로 전진하게 된다. 개미가 나무의 끝에 도착하게 되면, 개미는 땅으로 떨어지고, 다른 개미에게 영향을 끼칠 수 없게 된다. (개미의 크기는 무시할 수 있다)




위의 그림은 시간이 0인 순간이다. 1초가 지난 후에 E와 A는 2에서 만나고, 두 개미는 방향을 바꾸게 된다. 1.5초가 지난 후에는 A와 B가 만나게 되고 동시에 C와 D도 만나게 된다. 네 개미는 모두 방향을 바꾼다. 0.5초가 지난 후 (3초)에는 E가 땅으로 떨어지게 된다.


개미의 움직임을 시뮬레이트하는 프로그램을 작성하시오.","입력은 여러 개의 테스트 케이스로 이루어져 있다. 각 테스트 케이스의 첫째 줄에는 나무의 길이 L (단위: cm, 1 ≤ L ≤ 99,999)과 개미의 수 A (1 ≤ A ≤ L+1)가 주어진다.


다음 A개 줄에는 개미의 위치 X
i
 (0 ≤ X
i
 ≤ L)와 개미가 바라보고 있는 방향 (L: 왼쪽, R: 오른쪽)이 주어진다. 두 개미가 같은 위치에 있는 경우는 없다.","각 테스트 케이스 마다, ""The last ant will fall down in T seconds - started at P.""를 출력한다.


T는 마지막 개미가 떨어진 시간, P는 그 개미가 시간 0 때 있었던 위치이다. 두 개미가 동시에 떨어지는 경우에는 ""started at P and Q""를 출력한다. (P < Q)","90000 1
0 R
10 1
0 L
14 5
3 L
6 L
13 L
8 R
1 R","The last ant will fall down in 90000 seconds - started at 0.
The last ant will fall down in 0 seconds - started at 0.
The last ant will fall down in 13 seconds - started at 6 and 8.",
1093,스티커 수집,Platinum III,"영훈이의 취미는 스티커 수집이다. 서로 다른 스티커가 N개가 있고, 모두 번호가 0번부터 N-1번까지 매겨져 있다. 각 스티커는 한 개뿐이다. 각 스티커의 가격과 가치가 주어진다. 그리고, 영훈이가 현재 가지고 있는 스티커도 주어진다.


이때, 영훈이는 스티커를 팔고 사는 행동을 반복해서 가지고 있는 스티커의 가치의 합이 적어도 K가 되게 하려고 한다.


영훈이가 처음에 돈이 얼마가 있어야 영훈이가 가지고 있는 스티커의 가치의 합이 적어도 K가 되는지를 구하시오. 가능한 돈이 한 개가 아니라면 가장 작은 값을 출력한다.","첫째 줄에 N이 주어진다. N은 32보다 작거나 같은 자연수이다. 둘째 줄에는 각 스티커의 가격이 주어진다. 셋째 줄에는 각 스티커의 가치가 주어진다. 넷째 줄에는 K가 주어진다. 다섯째 줄에는 영훈이가 현재 가지고 있는 스티커의 개수가 주어진다. 여섯째 줄에는 영훈이가 가지고 있는 스티커의 번호가 주어진다. 가격은 30,000,000보다 작거나 같은 자연수이고, 영훈이가 가지고 있는 스티커의 개수는 0보다 크거나 같고, N보다 작거나 같은 정수이다. K는 0보다 크거나 같고, 1,000,000,000보다 작거나 같은 정수이다. 가치는 1 이상 30,000,000 이하의 정수이다.


영훈이가 가지고 있는 스티커의 수가 0인 경우 여섯번째 줄은 주어지지 않는다.",첫째 줄에 문제의 정답을 출력한다. 만약 불가능 할 때는 -1을 출력한다.,"2
2 15
2 21
13
0

---

5
9 18 7 6 18
12 27 10 10 25
67
2
4 0

---

4
14 14 12 6
19 23 20 7
10
3
3 2 1

---

10
43 33 14 31 42 37 17 42 40 20
116 71 38 77 87 106 48 107 91 41
811
1
6","15

---

22

---

0

---

-1",
17114,하이퍼 토마토,Gold I,"시프트의 토마토 농장은 아래 그림과 같이 토마토를 보관하는 큰 11차원 창고를 가지고 있다. 창고는 
m 
×
 n 
×
 o 
×
 p 
×
 q 
×
 r 
×
 s 
×
 t 
×
 u 
×
 v 
×
 w
 의 격자 모양이고, 각 칸에 토마토를 하나씩 보관할 수 있다.


 




 


창고에 보관되는 토마토들 중에는 잘 익은 것도 있지만, 아직 익지 않은 토마토들도 있을 수 있다. 보관 후 하루가 지나면, 익은 토마토들의 인접한 곳에 있는 익지 않은 토마토들은 익은 토마토의 영향을 받아 익게 된다. 하나의 토마토에 인접한 곳은 $\begin{bmatrix} \pm 1 \\ 0 \\ 0 \\ 0 \\ 0 \\ 0 \\ 0 \\ 0 \\ 0 \\ 0 \\ 0 \end{bmatrix}$, $\begin{bmatrix} 0\\ \pm 1 \\ 0 \\ 0 \\ 0 \\ 0 \\ 0 \\ 0 \\ 0 \\ 0 \\ 0 \end{bmatrix}$, $\begin{bmatrix} 0 \\ 0 \\ \pm 1 \\ 0 \\ 0 \\ 0 \\ 0 \\ 0 \\ 0 \\ 0 \\ 0 \end{bmatrix}$, $\begin{bmatrix} 0 \\ 0 \\ 0 \\ \pm 1 \\ 0 \\ 0 \\ 0 \\ 0 \\ 0 \\ 0 \\ 0 \end{bmatrix}$, $\begin{bmatrix} 0 \\ 0 \\ 0 \\ 0 \\ \pm 1 \\ 0 \\ 0 \\ 0 \\ 0 \\ 0 \\ 0 \end{bmatrix}$, $\begin{bmatrix} 0 \\ 0 \\ 0 \\ 0 \\ 0 \\ \pm 1 \\ 0 \\ 0 \\ 0 \\ 0 \\ 0 \end{bmatrix}$, $\begin{bmatrix} 0 \\ 0 \\ 0 \\ 0 \\ 0 \\ 0 \\ \pm 1 \\ 0 \\ 0 \\ 0 \\ 0 \end{bmatrix}$, $\begin{bmatrix} 0 \\ 0 \\ 0 \\ 0 \\ 0 \\ 0 \\ 0 \\ \pm 1 \\ 0 \\ 0 \\ 0 \end{bmatrix}$, $\begin{bmatrix} 0 \\ 0 \\ 0 \\ 0 \\ 0 \\ 0 \\ 0 \\ 0 \\ \pm 1 \\ 0 \\ 0 \end{bmatrix}$, $\begin{bmatrix} 0 \\ 0 \\ 0 \\ 0 \\ 0 \\ 0 \\ 0 \\ 0 \\ 0 \\ \pm 1 \\ 0 \end{bmatrix}$, $\begin{bmatrix} 0 \\ 0 \\ 0 \\ 0 \\ 0 \\ 0 \\ 0 \\ 0 \\ 0 \\ 0 \\ \pm 1 \end{bmatrix}$의 스물 두 방향에 인접해 있는 토마토를 의미한다. 토마토가 혼자 저절로 익는 경우는 없다고 가정한다. 시프트는 창고에 보관된 토마토들이 며칠이 지나면 다 익게 되는지 그 최소 일수를 알고 싶어 한다.


m
,
 n
,
 o
,
 p
,
 q
,
 r
,
 s
,
 t
,
 u
,
 v
,
 w
 와 익은 토마토들과 익지 않은 토마토들의 정보가 주어졌을 때, 며칠이 지나면 토마토들이 모두 익는지, 그 최소 일수를 구하는 프로그램을 작성하라. 단, 창고의 일부 칸에는 토마토가 들어있지 않을 수도 있다.","첫 줄에는 문제의 설명에서 창고의 크기를 나타내는 자연수 
m
,
 n
,
 o
,
 p
,
 q
,
 r
,
 s
,
 t
,
 u
,
 v
,
 w
가 주어진다. 단, 1 ≤ 
mnopqrstuvw
 ≤ 10
6
 이다.


둘째 줄부터는 창고에 저장된 토마토들의 정보가 주어진다. 창고 안의 격자 공간을 (1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)부터 (
m
,
 n
,
 o
,
 p
,
 q
,
 r
,
 s
,
 t
,
 u
,
 v
,
 w
)까지의 좌표로 나타낸다고 하면,




둘째 줄에는 (1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)부터 (
m
, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)까지에 들어 있는 토마토 
m
개의 정보가 주어지고,


이러한 줄이 
n
번 반복되어  (1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)부터 (
m
, 
n
, 1, 1, 1, 1, 1, 1, 1, 1, 1)까지에 들어 있는 토마토 
mn
개의 정보가 주어지고,


이러한 
n
개의 줄이 
o
번 반복되어 (
m
, 
n
, 
o
, 1, 1, 1, 1, 1, 1, 1, 1)까지에 들어 있는 토마토 
mno
개의 정보가 주어지고,


이러한 
no
개의 줄이 
p
번 반복되어 (
m
, 
n
, 
o
, 
p
, 1, 1, 1, 1, 1, 1, 1)까지에 들어 있는 토마토 
mnop
개의 정보가 주어지고,


⋯ 이와 같은 방법으로 
nopqrstuvw
개의 줄에 걸쳐 (
m
,
 n
,
 o
,
 p
,
 q
,
 r
,
 s
,
 t
,
 u
,
 v
,
 w
)까지에 들어 있는 토마토 
mnopqrstuvw
개의 정보가 모두 주어진다.




정수 1은 익은 토마토, 정수 0은 익지 않은 토마토, 정수 -1은 토마토가 들어있지 않은 칸을 나타낸다.","토마토가 모두 익을 때까지 최소 며칠이 걸리는지를 계산해 출력한다. 만약 저장될 때부터 모든 토마토가 익어있는 상태이면 0을 출력해야 하고, 토마토가 모두 익지는 못하는 상황이면 -1을 출력해야 한다.","6 4 1 1 1 1 1 1 1 1 1
0 0 0 0 0 0
0 0 0 0 0 0
0 0 0 0 0 0
0 0 0 0 0 1

---

5 3 1 1 1 1 1 1 1 1 1
0 -1 0 0 0
-1 -1 0 1 1
0 0 0 1 1

---

5 3 2 1 1 1 1 1 1 1 1
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
0 0 1 0 0
0 0 0 0 0","8

---

-1

---

4",
20133,모래시계 2,Platinum I,"모래시계 가공업자 택희의 뒤를 이어서 국렬이가 좌표평면 위에 주어진 점들을 받아서 그 안에서 모래시계를 추출하는 작업을 한다.


모래시계는 아래와 같이 생겼다.




[그림] 모래시계


좀 더 정확히 말하면, 다음의 조건을 만족하는 것을 모래시계라고 할 것이다.




삼각형 2개로 두 삼각형이 한 점을 공유한 상태여야 한다.


삼각형들끼리 서로 겹치면 안 된다.




만일 어떤 두 모래시계에 대해, 두 모래시계에 속한 정점과 간선의 합집합이 두 모래시계 중 한쪽과 동일할 때, 이 두 모래시계는 동일한 모래시계라고 한다. 이 조건을 만족하지 않는 모든 두 모래시계는 서로 다른 모래시계이다.


택희처럼 국렬이도 모래시계의 개수를 빠르게 세고 싶다. 국렬이가 택희에게 도전할 수 있게 도와주자.","다음과 같이 입력이 주어진다.


N


x
1
 
y
1

. . .


x
N
 
y
N",만들 수 있는 모래시계의 개수를 출력하여라.,"5
1 2
-2 1
-3 -2
2 -3
0 0",6,
1171,사오정,Platinum I,"민식이는 애들과 토론 중이다. 안타깝게 민식이의 남의 말을 제대로 알아듣지 못한다. 민식이 귀가 다른 사람이 한 말을 인식하는 방법은 다음과 같다. 일단 민식이는 다른 사람이 말한 말을 2진수로 바꾸어 듣는다. 그리고 다른 사람이 한 말의 i번째 비트는 민식이가 인식하는 이진수의 j번째 비트에 위치하게 되는데 항상 |j - i| ≤ D가 성립한다. 이렇게 만들어진 이진수로 민식이는 알아듣게 된다.


만약 다른 사람이 한 말이 0110이라면 민식이가 알아듣는 이진수의 후보는 0101, 0110, 1001, 1010으로 총 4가지이다.




문제는 다른 사람이 말하는 이진수와 정수 D, K가 주어지면 민식이가 알아듣는 이진수 후보의 개수와 이 후보들 중 K번째로 작은 이진수를 출력하는 문제이다.","첫 줄에는 이진수 비트의 개수 N(1 ≤ N ≤ 2,000)과 D(0 ≤ D < N), K(1 ≤ K ≤ 100,000,000)가 공백으로 구분되어 주어진다. 두 번째 줄에는 다른 사람이 말한 N비트의 2진수가 주어진다.","첫 줄에 민식이가 알아들을 것으로 예상되는 2진수의 총 후보의 개수를 100,000,000로 나눈 나머지를 출력한다. 다음 줄에는 이 이진수의 후보 중 K번째로 작은 2진수를 출력한다.","4 1 3
0110","4
1001",
2287,모노디지털 표현,Gold I,"몇 개의 숫자 K(K는 1, 2, …, 9중 하나)와 사칙 연산(덧셈, 뺄셈, 곱셈, 나눗셈)만을 사용하여 어떤 자연수 X를 수식으로 표현한 것을 X의 K-표현이라 부른다. 수식에는 괄호가 포함될 수 있으며, 나눗셈은 나눈 몫만을 취한다.


예를 들어 12의 5-표현을 몇 개 써 보면 5+5+(5/5)+(5/5), 55/5+5/5, (55+5)/5 등이 있다. K-표현의 길이를 사용한 K의 개수라 하면, 각각의 길이는 6, 5, 4가 된다.


K가 주어졌을 때, 어떤 자연수의 K-표현 중 가장 짧은 길이를 알아보려 한다.","첫째 줄에 K가 주어진다. 다음 줄에는 표현 식을 찾을 수의 개수 n(1 ≤ n ≤ 1,000)이 주어진다. 다음 줄에는 K-표현 중 가장 짧은 길이를 알아보려 하는 자연수 a(1 ≤ a ≤ 32,000)가 주어진다.","입력되는 순서대로 K-표현의 최소 길이를 n개의 줄에 출력한다. 만약 K-표현의 최소 길이가 8보다 크다면 “NO""를 출력한다.","5
2
12
31168","4
NO",
2195,문자열 복사,Gold V,"어떤 원본 문자열 S가 주어졌을 때, 이 문자열의 부분을 복사하여 P라는 새로운 문자열을 만들려고 한다. 복사를 할 때에는 copy(s, p) 이라는 함수를 이용하는데, 이는 S의 s번 문자부터 p개의 문자를 P에 복사해서 붙인다는 의미이다.


예를 들어 S=""abaabba"", P=""aaabbbabbbaaa""인 경우를 생각해 보자. 이때는 copy(3, 2), copy(4, 3), copy(2, 2), copy(5, 2), copy(2, 3), copy(1, 1) 를 수행하여 P를 만들 수 있다. 각 단계별로 P는 ""aa"", ""aaabb"", ""aaabbba"", …와 같이 변하게 된다.


이와 같은 copy 연산을 이용하여 S에서 P를 만들려고 하는데, 이때 가능하면 copy 함수를 조금 사용하려고 한다.


S와 P가 주어졌을 때, 필요한 copy 함수의 최소 사용횟수를 구하는 프로그램을 작성하시오.","첫째 줄에 S, 둘째 줄에 P가 주어진다. S와 P는 영어 대소문자와 숫자로만 되어 있다. S의 길이는 1,000을 넘지 않으며, P의 길이는 1,000을 넘지 않는다. copy함수만을 이용하여 S에서 P를 만들어낼 수 없는 경우는 입력으로 주어지지 않는다고 가정하자. 각 문자열은 최소한 한 개의 문자로 이루어져 있다.",첫째 줄에 copy 함수의 최소 사용횟수를 출력한다.,"xy0z
zzz0yyy0xxx",10,
10589,마법의 체스판,Gold IV,"진수는 동생 지수로부터 크기가  n × m인 마법의 체스판을 받았다. 마법의 체스판은 신기한 기능이 많이 있는데 그중에는 체스판의 색상을 반전시킬 수 있는 기능이 있다. 이 기능을 사용하면 칸들을 포함하는 직사각형을 선택하여 하얀색은 검은색으로 검은색은 하얀색으로 바꿀 수 있다.


초기에는 칸들의 색상이 일반적인 체스판처럼 칠해져 있다. 다르게 말하면 변을 공유하는 칸들은 서로 색상이 다르다. 진수는 위에서 설명한 기능을 최소한으로 이용하여 모든 칸의 색상을 같게 하고 싶다. 하지만 아무리 고민해도 방법을 찾지 못하였다. 그래서 진수는 당신에게 이 문제를 풀어 달라고 요청했다.","첫 번째 줄에 행과 열의 개수를 나타내는 두 개의 정수 n과 m이 주어진다.  (1 ≤ n, m ≤ 50)","첫 번째 줄에는 반전 횟수 k를 출력한다.


다음 k개 줄에는 줄 마다 직사각형의 모서리를 포함하는 좌표와 마주보는 모서리의 좌표를 출력한다. 


행은 1번부터 n번까지 있으며 열은 1부터 m번까지 있다.",2 2,"2
1 1 1 1
2 2 2 2",
14258,XOR 그룹,Platinum V,"N*M 격자에 서로 다른 수가 하나씩 들어가 있다. XOR 그룹이라는 것을 정의를 하여 합을 최대로 하려한다. XOR 그룹이란 위, 아래, 오른쪽, 왼쪽으로 인접한 칸에 수가 있다면, 그 칸과 연결되어 그 수를 모두 XOR한 값을 가지는 그룹이 된다. 만약, 중간에 수가 빠져있으면, 연결이 되지 않으므로, 한 격자판에 여러 XOR 그룹이 있을 수 있다.


이제 격자판에서 작은 수부터 제거해 나갈 것이다. 하나를 지울 때 마다 XOR 그룹이 변하는데, XOR그룹의 값의 합의 최대가 될 때, 그 값을 구하여라.","첫째 줄에 n, m이 주어진다.(1 ≤ n, m ≤ 1,000)


다음 n줄에는 격자의 i번째 줄의 수 m개가 주어진다. 수는 1,000,000보다 크지 않은 음이 아닌 정수이다.",XOR 그룹의 값의 합이 최대가 되는 값을 구하여라,"3 4
9 1 15 16
3 4 10 6
2 5 7 11",42,
2927,남극 탐험,Diamond V,"상근이는 ""얼음을 꿈꾸다"" 여행사의 사장이다. 이 여행사는 남극 근처의 섬 N개를 구매해 당일치기 여행을 제공하고 있다. 관광객들에게 가장 인기 있는 동물은 황제 펭귄으로 섬에서 쉽게 찾을 수 있다.


여행사는 점점 인기를 얻게 되었고, 이제 보트를 이용하는 것이 효율적이지 않은 상황까지 이르렀다. 상근이는 섬 사이에 다리를 건설해 관광객을 버스로 이동시키려고 한다. 상근이는 컴퓨터 프로그램을 이용해서 다리를 건설하는 과정을 관리하려고 한다.


섬은 1번부터 N번까지 번호가 매겨져 있다. 가장 처음에는 아무 다리도 없으며, 각 섬에 펭귄이 몇 마리 살고있는지는 모두 알고있다. 펭귄의 수는 변할 수 있다. 하지만, 항상 0보다 크거나 같고, 1000보다 작거나 같다.


상근이의 프로그램은 다음과 같은 세 가지 명령을 수행할 수 있어야 한다.




""bridge A B"" - 섬 A와 B사이에 다리를 건설하는 명령이다. (A와 B는 다르다) 이전까지 지어진 다리를 이용해서 이동할 수 없는 경우에만 다리를 지어야 한다. 다리를 지어야 하면 ""yes"", 지을 필요가 없이 이미 이동할 수 있으면 ""no""를 출력한다.


""penguins A X"" - 섬 A에 살고있는 펭귄의 수를 다시 세보니 X마리가 되었다는 명령이다. 아무것도 출력할 필요가 없다.


""excursion A B"" - 관광객들이 섬 A에서 시작해 B에서 끝나는 여행 경로를 이용하는 명령이다. A에서 B로 갈 수 있는 경우에는 이동하는 섬에 있는 모든 펭귄의 수를 구해 출력한다. (A와 B 포함) 이동할 수 없는 경우에는 ""impossible""를 출력한다.




상근이의 프로그램을 작성하시오.","첫째 줄에 섬의 수 N (1 ≤ N ≤ 30,000)이 주어진다.


둘째 줄에는 각 섬에 있는 펭귄의 수가 주어진다.


셋째 줄에는 명령의 개수 Q (1 ≤ Q ≤ 300,000)가 주어진다.


다음 Q개 줄에는 문제에서 주어진 명령 중 하나가 주어진다.","""bridge""나 ""excursion"" 명령이 주어질 때 마다 출력한다.","5
4 2 4 5 6
10
excursion 1 1
excursion 1 2
bridge 1 2
excursion 1 2
bridge 3 4
bridge 3 5
excursion 4 5
bridge 1 3
excursion 2 4
excursion 2 5

---

6
1 2 3 4 5 6
10
bridge 1 2
bridge 2 3
bridge 4 5
excursion 1 3
excursion 1 5
bridge 3 4
excursion 1 5
penguins 3 10
excursion 1 3
bridge 1 5","4
impossible
yes
6
yes
yes
15
yes
15
16

---

yes
yes
yes
6
impossible
yes
15
13
no",
29772,병사 분배,Diamond V,"어떤 나라에는 장군 $3$명 $A$, $B$, $C$와 병사 $N$명이 존재한다. 각각의 병사는 $1$번부터 $N$번까지의 서로 다른 번호로 구분되며 어떤 장군 밑으로 들어가냐에 따라 발휘할 수 있는 능력치가 달라지며 능력치는 항상 양의 정수이다. 
병사 능력치의 합
이란 병사들이 특정 장군 밑에 소속되어 발휘할 수 있는 능력치들의 합이다.


장군들은 훈련과 전투 모두 독립적으로 진행하기 때문에 한 장군에게 소속된 병사가 적다면 훈련과 전투에 지장이 생긴다. 각 장군이 훈련과 전투를 수행하기 위해 필요한 병사의 최소 인원 $K$가 주어질 때 모든 장군이 원활하게 훈련과 전투에 임할 수 있도록 병사들의 소속을 정하면서 
병사 능력치의 합
을 최대로 하여라.","첫 번째 줄에 병사의 수 $N$, 전술을 위해 필요한 병사들의 최소 인원 $K$가 공백으로 구분되어 주어진다. $(3 \le N \le 200\,000$, $1 \le K \le \lfloor \cfrac{N}{3} \rfloor)$


두 번째 줄에 $A$ 장군에게 소속되었을 때 병사들의 능력치가 $1$번 병사부터 $N$ 번 병사까지 차례대로 공백으로 구분되어 주어진다. $(1 \le A_i \le 10^9)$


세 번째 줄에 $B$ 장군에게 소속되었을 때 병사들의 능력치가 $1$번 병사부터 $N$ 번 병사까지 차례대로 공백으로 구분되어 주어진다. $(1 \le B_i \le 10^9)$


네 번째 줄에 $C$ 장군에게 소속되었을 때 병사들의 능력치가 $1$번 병사부터 $N$ 번 병사까지 차례대로 공백으로 구분되어 주어진다. $(1 \le C_i \le 10^9)$","병사 능력치의 합
의 최댓값을 출력한다.","4 1
1 2 3 4
3 1 2 2
2 3 1 3

---

10 2
6 3 3 8 7 1 5 1 7 5
4 8 5 10 3 4 9 10 1 3
8 7 3 4 2 7 7 8 9 6","13

---

78",
18252,별이 빛나는 밤에,Diamond IV,"준겸이는 별을 굉장히 좋아한다! 그래서 준겸이는 연말을 맞아 걸어둘 밤하늘 무늬 장식판에 별 모양 장식물을 달아 예쁘게 장식하려고 한다. 장식판은 직사각형 모양으로, 위쪽 변과 아래쪽 변 위에 별 모양 장식물을 각각 하나씩 달아 벽에 고정시킨다.  준겸이는 조금 더 예쁜 장식판을 만들기 위해서, 고정판에 레일을 달아 별이 움직일 수 있게 만들었다. 하지만 레일을 잘못 달면 균형이 맞지 않을 수도 있으므로, 레일은 장식판의 끄트머리와 닿지 않으면서 밑변과 평행하게 달기로 하였다. 또한 각 레일 위를 움직일 수 있는 별은 하나씩이고, 모든 레일에는 별이 반드시 달려 있다. 
레일은 서로 겹칠 수 있지만, 별은 각 레일 위에서 독립적으로 움직임에 유의하자.




인구는 준겸이의 집에 놀러 왔다가 우연히 준겸이의 장식판을 보게 되었다. 그런데, 깔끔한 것을 좋아하는 인구는 별의 배치가 너무 난잡하다는 생각을 하게 되었다. 인구는 미니멀리즘을 정말 좋아해서, 세 별을 골라 만들 수 있는 삼각형의 넓이가 작을수록 기분이 정말 좋을 것이다. 준겸이는 그런 인구를 위해 별을 레일 위에서 적절하게 움직여, 임의의 세 별을 골라 만든 삼각형 넓이의 최댓값이 가능한 한 작도록 별을 배치하려고 한다. 준겸이와 같이 별을 배치해 보자!","첫째 줄에 레일의 개수 
N
이 주어진다. (1 ≤ 
N
 ≤ 10,000)


둘째 줄에 맨 위에 있는 별의 좌표 
x
1
, 
y
1
과 맨 아래에 있는 별의 좌표 
x
2
,
 
y
2
가 공백을 사이에 두고 차례로 주어진다. (0 ≤  
x
1
, 
y
1
, 
x
2
, 
y
2
 ≤ 10
9
, 
y
2
 < 
y
1
)


그 다음 
N
개의 줄에 걸쳐 레일이 존재하는 y좌표 
y
와 x좌표의 범위 
x
st
, 
x
en
이 차례로 주어진다. (
y
2
 < 
y
 < 
y
1
, 0 ≤ 
x
st
 < 
x
en
 ≤ 10
9
)


주어지는 모든 좌표는 정수이다.","첫째 줄에 삼각형 넓이의 최댓값이 가능한 한 작도록 별을 배치했을 때 삼각형 넓이의 최댓값을 출력한다. 모범 답안과의 절대/상대 오차가 10
-6
 이하인 경우 정답으로 인정된다.","4
2 4 0 0
1 2 4
1 2 3
2 3 5
3 2 4

---

4
5 9 9 2
7 4 11
4 7 12
6 6 10
5 3 9","4.000000000

---

0",
23042,AND와 OR,Gold I,"당신에게 $N$개의 수가 주어집니다. 당신은 다음과 같은 작업을 하고 싶은 만큼 할 수 있습니다.




두 수를 고르고, 이 두 수를 두 수와 bitwise AND 및 bitwise OR가 모두 같은 두 음이 아닌 정수로 바꿉니다.




당신은 작업을 수행한 후 이 수들의 곱을 최소화하고 싶습니다. $N$개의 수의 최소화된 곱을 구하세요. 단, 이 곱이 매우 커질 수 있으니 $10^{9} + 7$로 나눈 나머지를 대신 출력합니다.


Bitwise AND와 bitwise OR에 대한 설명은 노트 란을 참고하세요.","첫째 줄에 $2$ 이상 $300\,000$ 이하인 정수 $N$이 주어집니다.


둘째 줄에 $N$개의 양의 정수가 공백을 사이에 두고 주어집니다. 각 정수는 $2^{30}$보다 작습니다.","첫째 줄에 최소화된 곱을 $10^{9} + 7$로 나눈 나머지를 출력합니다.


곱을 $\mathbf{10}^{\mathbf{9}} + \mathbf{7}$로 나눈 나머지를 최소화하는 것이 아님에 주의하세요.","3
3 6 10",60,"Bitwise operation은 각 연산을 비트 단위로 시행하는 것입니다.


예를 들어, $28$과 $87$을 bitwise AND 연산한다고 합시다. 먼저 $28$과 $87$을 비트가 잘 드러나도록 2진수로 바꾸겠습니다.








0001 1100


$=28$






0101 0111


$=87$








각 위치의 비트를 순서대로 
AND
해서 아래쪽에 적습니다. 
AND
 연산의 경우 두 비트가 모두 
1
이어야만 결과가 
1
이고, 그렇지 않은 경우 
0
입니다.








 


0001 1100


$=28$






AND


0101 0111


$=87$






 


0001 0100


$=20$








마찬가지로 bitwise OR 연산을 시행할 수도 있습니다. 
OR
 연산의 경우 두 비트가 모두 
0
이어야만 결과가 
0
이고, 그렇지 않은 경우 
1
입니다.








 


0001 1100


$=28$






OR


0101 0111


$=87$






 


0101 1111


$=95$"
14733,행사장 대여 (Large),Platinum V,"상현이는 국방부 퀘스트를 수행하기 전에 이별 파티를 기획하고 있다. 따라서 파티를 진행하기 위해 행사장을 대여하려고 한다.


이 대여 업체는 전직 프로그래머들만 일하기 때문에 대여 방식이 독특하다. 상현이가 대여 장소를 정하면 그 장소를 완전히 포갤 수 있는 N개의 직사각형을 만든다. 그 후 직사각형의 개수 N과 각 직사각형들의 좌측 하단과 우측 상단의 좌표를 알려준다. N개의 직사각형들은 일부분 혹은 전체가 겹칠 수도 있다.


상현이가 빌린 행사장의 넓이를 구하는 프로그램을 작성하라.","첫째 줄에 직사각형의 개수 N(2 ≤ N ≤ 3,000)이 주어진다.


이어 N개의 줄에 네 정수 x1, y1, x2, y2(-50,000 ≤ x1 < x2 ≤ 50,000, -50,000 ≤ y1 < y2 ≤ 50,000)가 순서대로 주어진다. 이는 좌측 하단의 좌표 (x1, y1), 우측 상단의 좌표 (x2, y2)이다.",첫째 줄에 상현이가 빌린 행사장의 넓이를 출력하라,"3
4 2 6 3
4 0 5 1
0 0 7 8",56,
21865,Railroad,Diamond IV,"평소 ""더 지니어스""라는 프로그램을 좋아하던 태수는 데스매치에서 나왔던 모노레일 게임에 관심을 갖기 시작했고 더 다양한 종류의 타일을 이용한 게임을 하나 만들어왔다.


기존 모노레일 게임은 다음과 같은 2개의 타일만을 이용해서 플레이가 진행됐다. (각각 1번 타일(좌), 2번 타일(우)이라 칭한다.)




하지만 태수는 여기에 다음과 같은 2종류의 타일을 추가하려고 한다. (각각 3번 타일(좌), 4번 타일(우)이라 칭한다.)




우리는 이 타일들이 무한히 많이 있는 상태로 게임을 진행한다. 원래의 모노레일 게임은 두 명의 플레이어가 서로 번갈아가며 타일을 놓지만, 친구가 없는 태수는 이러한 게임을 할 수 없기 때문에 살짝 다른 스타일로 게임을 진행하려고 한다.




$N \times M$ 크기의 격자가 있다. 각 타일을 놓을 수 있는 곳은 정해져있다. 격자에서 
L
이 써있는 곳은 1번 타일을 놓아야만 하고, 
O
가 써있는 곳은 3번 또는 4번 타일을 놓아야만 한다. 
X
가 써있는 곳은 어느 타일도 놓을 수 없고, 
.
이 써있는 곳은 2번 타일을 놓거나 아예 놓지 않아야한다. 타일을 회전시켜 격자에 놓아도 된다고 할 때, 중간에 초록색 길이 끊겨있는 부분 없이 전부 이어지도록 타일을 놓으려고 한다. 과연 어떻게 놓아야하겠는가?




태수가 이 게임을 성공할 수 있을지 판단하고, 가능하다면 그러한 배치를 찾아주는 프로그램을 작성하자.","첫째 줄에 $N$, $M$이 공백을 사이에 두고 주어진다. $(1 \leq N,M \leq 300)$ 그 다음 $N$줄에 걸쳐 
L
, 
O
, 
X
, 
.
으로만 이루어진 길이 $M$의 문자열이 주어진다.","조건에 맞는 배치를 만들 수 없다면 첫째 줄에 
NO
를 출력한다. 그렇지 않다면 첫째 줄에 
YES
를 출력하고, 두 번째 줄부터 $N$줄에 걸쳐 해당 배치를 출력한다.


입력에서 
X
로 주어진 부분은 출력에서도 
X
로 출력해야하고, 빈공간은 
.
, 나머지는 아래 그림에 맞춰 출력하면 된다. (괄호 안은 아스키 코드 값을 의미한다. 예제에서 모든 타일에 대한 정보가 주어지니 정확히 무엇인지 모르겠으면 복사 붙여넣기를 활용하도록 하자.)","4 4
L..L
.LL.
.LL.
L..L

---

3 3
LOL
OOO
LOL

---

4 4
..XX
..XX
XXLL
XXLL

---

2 2
.L
LL","YES
r--7
|r7|
|LJ|
L--J

---

YES
rv7
>+<
L^J

---

YES
..XX
..XX
XXr7
XXLJ

---

NO",
18446,우체국 5,Ruby I,"원형으로 큰 길(순환로)이 뻗어 있고, 길 옆으로 V개의 마을이 자리잡고 있다. 큰 길의 둘레 길이는 정수 L이다. 이 문제에서 큰 길은 0 이상 L-1 이하의 정수가 늘어져 있는 원이고, 각 마을의 위치는 길 상의 정수 좌표로 표현된다. 한 위치에 여러 마을이 있을 수 있다. 좌표가 x, y인 두 마을의 거리는 min(|x - y|, L - |x - y|) 이다. 


우리는 이들 마을이 있는 곳에 우체국을 P개 지으려고 한다. 물론 모든 마을마다 다 짓는 건 아니다. 전체 마을 중 몇 곳을 골라, 그 위치에 우체국을 짓게 된다. 우리는 그 때 각 마을과 그 마을과 가장 가까운 우체국 사이의 거리의 합이 최소가 되게 하고 싶다.


각 마을의 위치와 짓고자 하는 우체국 개수를 입력받아서, 각 마을과 그 마을과 가장 가까운 우체국 사이 거리의 합으로 있을 수 있는 최소값을 계산하고, 그런 결과를 낼 수 있도록 각 우체국을 지을 위치를 출력하는 프로그램을 작성하라.","첫 줄에는 세 정수 V, P, L이 주어진다. (1 ≤ P ≤ V ≤ 250 000, 1 ≤ L ≤ 10
12
) 


다음 줄에는 각 마을의 위치를 나타내는 V개의 정수 좌표가 나온다. 좌표는 비내림차순으로 정렬되어 있다. 각 좌표의 범위는 0 이상 L-1 이하이다.","첫째 줄에는, 각 마을과 거기서 가장 가까운 우체국 사이 거리들의 합의 최소값을 나타내는 정수 S를 출력한다.


다음 줄에는, 우체국을 지을 마을들을 골라, 그 마을의 위치를 나타내는 P개의 정수를 비내림차순으로 출력한다.","10 5 200
1 2 3 6 7 9 11 22 44 50

---

10 5 51
1 2 3 6 7 9 11 22 44 50","9
2 7 22 44 50

---

8
1 6 9 22 44",
9202,Boggle,Platinum V,"상근이는 보드 게임 ""Boggle""을 엄청나게 좋아한다. Boggle은 글자가 쓰여 있는 주사위로 이루어진 4×4 크기의 그리드에서 최대한 많은 단어를 찾는 게임이다. 


상근이는 한 번도 부인을 Boggle로 이겨본 적이 없다. 이렇게 질 때마다 상근이는 쓰레기 버리기, 설거지와 같은 일을 해야 한다. 이제 상근이는 프로그램을 작성해서 부인을 이겨보려고 한다.


Boggle에서 단어는 인접한 글자(가로, 세로, 대각선)를 이용해서 만들 수 있다. 하지만, 한 주사위는 단어에 한 번만 사용할 수 있다. 단어는 게임 사전에 등재되어 있는 단어만 올바른 단어이다.


1글자, 2글자로 이루어진 단어는 0점, 3글자, 4글자는 1점, 5글자는 2점, 6글자는 3점, 7글자는 5점, 8글자는 11점이다. 점수는 자신이 찾은 단어에 해당하는 점수의 총 합이다.


단어 사전에 등재되어 있는 단어의 목록과 Boggle 게임 보드가 주어졌을 때, 얻을 수 있는 최대 점수, 가장 긴 단어, 찾은 단어의 수를 구하는 프로그램을 작성하시오.","첫째 줄에 단어 사전에 들어있는 단어의 수 w가 주어진다. (1 < w < 300,000) 다음 w개 줄에는 단어가 주어진다. 단어는 최대 8글자이고, 알파벳 대문자로만 이루어져 있다. 단어 사전에 대한 정보가 모두 주어진 이후에는 빈 줄이 하나 주어진다.


그 다음에는 Boggle 보드의 개수 b가 주어진다. (1 < b < 30) 모든 Boggle은 알파벳 대문자로 이루어져 있고, 4줄에 걸쳐 주어진다. 각 Boggle의 사이에는 빈 줄이 하나  있다.","각각의 Boggle에 대해, 얻을 수 있는 최대 점수, 가장 긴 단어, 찾은 단어의 개수를 출력한다. 한 Boggle에서 같은 단어를 여러 번 찾은 경우에는 한 번만 찾은 것으로 센다. 가장 긴 단어가 여러 개인 경우에는 사전 순으로 앞서는 것을 출력한다. 각 Boggle에 대해서 찾을 수 있는 단어가 적어도 한 개인 경우만 입력으로 주어진다.","5
ICPC
ACM
CONTEST
GCPC
PROGRAMM

3
ACMA
APCA
TOGI
NEST

PCMM
RXAI
ORCN
GPCG

ICPC
GCPC
ICPC
GCPC","8 CONTEST 4
14 PROGRAMM 4
2 GCPC 2",
27066,나무 블럭 게임,Gold V,"올해도 집에서 쓸쓸히 혼자 새해를 맞이하는 주원이는 제야의 종이 울리기 전까지 심심함을 달랠 무언가를 찾고 있다.


주원이는 근처에 굴러다니는 $N$개의 나무 블럭을 발견했다. 각 나무 블럭에는 음이 아닌 정수가 한 개씩 적혀있었다. 심심한 주원이는 나무 블럭들을 가지고 혼자서 할 수 있는 간단한 게임을 떠올렸다.


처음에 $N$개의 나무 블럭은 $N$개의 주머니에 한 개씩 들어있다. 이때 주원이는 다음 작업을 원하는 만큼 반복할 수 있다.




서로 다른 두 주머니를 고른 다음 둘을 하나로 합친다.




예를 들어, 첫 번째 주머니에 2가 적힌 나무 블럭과 5가 적힌 나무 블럭이, 두 번째 주머니에 3이 적힌 나무 블럭이 들어있다고 하자. 이 두 주머니를 합치면 각각 2, 3, 5가 적힌 나무 블럭 총 세 개가 하나의 주머니에 들어 있게 된다. 따라서 주머니의 총 개수는 하나 줄어든다.


게임의 모든 과정이 끝난 뒤 남아있는 주머니의 개수가 $K$개라고 할 때, 각각에 대해 들어있는 나무 블럭에 적힌 수의 평균을 구하자. 각 주머니에서 계산한 $K$개의 평균들을 오름차순으로 나열했을 때 $\left\lfloor\cfrac{K+1}{2}\right\rfloor$번째에 위치한 값이 주원이의 점수가 된다.


제야의 종이 울리기 전에 주원이가 게임을 마스터할 수 있도록 나무 블럭의 정보가 주어지면 얻을 수 있는 점수의 최댓값을 구해주는 프로그램을 만들어주자.","첫째 줄에 나무 블럭의 개수 $N$이 주어진다.


둘째 줄에 각 나무 블럭에 적혀있는 정수 $A_1, A_2, \cdots, A_N$이 공백으로 구분되어 주어진다.",게임에서 얻을 수 있는 가장 큰 점수를 출력한다. 절대/상대 오차는 $10^{-6}$까지 허용한다.,"4
2 0 2 2

---

2
1 2","2

---

1.500000",
1983,숫자 박스,Gold II,"그림과 같이 숫자 박스는 위와 아래의 두 행과 N개의 열로 나누어져 있다. 따라서 숫자 박스는 전체 2N개의 칸으로 이루어져 있고, 각 칸에는 0이 아닌 -10 이상 10 이하의 정수가 적힌 숫자판이 들어갈 수 있다. 아래 그림은 N=7 인 경우 어떤 숫자 박스의 상태를 보여주고 있다. 빈칸은 숫자판이 들어있지 않은 칸을 나타내며, 위와 아래의 행에 들어있는 숫자판의 개수는 같지 않을 수도 있다.








-3


-1


-2


 


5


-1


 






 


-3


2


4


 


5


-2








숫자 박스의 ""값""은 각 열의 위와 아래에 있는 두 숫자들의 곱을 모두 더한 값으로 정의된다. 빈칸은 0으로 계산한다. 예를 들면, 위 그림의 숫자 박스의 값은 (-3)×0 + (-1)×(-3) + (-2)×2 + 0×4 + 5×0 + (-1)×5 + 0×(-2) = -6 이다. 각 행에 주어진 숫자판들에 대해 그 순서를 유지하면서 좌우로 움직이면 다른 숫자 박스의 “값”을 얻을 수 있다. 위의 예에서 윗 행에 있는 5와 -1을 오른쪽으로 각각 한 칸씩 옮기고, 아래 행의 -3을 왼쪽으로 한 칸, 2와 4를 오른쪽으로 각각 한 칸씩 옮기면 그 결과 숫자 박스는 다음과 같다.








-3


-1


-2


 


 


5


-1






-3


 


 


2


4


5


-2








이 숫자 박스의 “값”은 9 + 25 + 2 = 36이 된다. 주어진 숫자 박스의 위와 아래의 행에 놓인 숫자판들을 그 순서는 유지하면서 위의 조건을 만족하도록 움직여서 얻을 수 있는 숫자 박스의 최댓값을 구하는 프로그램을 작성하시오. 숫자판들은 좌우 빈칸으로만 움직일 수 있으며, 건너뛰는 형태로 다른 숫자판과 그 위치가 교환될 수는 없다. 다시 말하면, 빈칸을 제외하면 각 행의 숫자판들의 순서는 항상 그대로 유지되어야 한다.","첫 줄에는 숫자 박스의 열의 수를 나타내는 정수 N(1 ≤ N ≤ 400)이 주어진다. 그 다음 두 줄에는 각각 숫자 박스의 위와 아래의 행에 놓인 초기 숫자판들의 숫자가 하나 이상의 공백을 두고 나타나는데, 숫자판이 없는 빈칸은 0으로 표시된다. 단, 숫자판의 숫자는 모두 -10 이상 10 이하의 0이 아닌 정수이다.",입력으로 주어진 숫자 박스의 각 행의 숫자판들을 가로로 이동시켜 얻을 수 있는 숫자 박스의 최댓값을 첫 번째 줄에 출력한다.,"7
-3 -1 -2 0 5 -1 0
0 -3 2 4 0 5 -2",36,
7575,바이러스,Platinum V,"새로운 컴퓨터 바이러스가 발견되어서 이를 치료하는 백신 프로그램을 개발하려고 한다. 백신 프로그램을 개발하기 위해서는 바이러스 코드를 알아야 하는데, 감염된 프로그램들에 공통으로 존재하는 부분이 바이러스로 의심되는 부분이다. (프로그램의 코드는 양의 정수들의 나열로 표현된다.) 단, 바이러스는 자신이 탐지되는 것을 막기 위해서, 자신의 코드를 반대로 기입하기도 한다. 또한, 프로그램들의 코드 일부가 우연히 같을 수 있기 때문에, 공통으로 나타나는 코드의 길이가 K 이상인 경우에만 바이러스 코드로 추정한다.




프로그램 1: 10 8 23 93 21 42 52 22 13 1 2 3 4


프로그램 2: 1 3 8 9 21 42 52 22 13 41 42


프로그램 3: 9 21 42 52 13 22 52 42 12 21




예를 들어, K = 4이고, 바이러스에 감염된 3개의 프로그램의 코드가 위와 같다고 하면, 길이가 4인 ""42 52 22 13"" 코드가 프로그램 1과 2에 나타나고, ""13 22 52 42""이 프로그램 3에 나타나므로 이 코드는 바이러스로 추정된다.


바이러스에 감염된 프로그램이 N 개 주어졌을 때, 바이러스 코드로 추정되는 부분이 있는지 여부를 판정하는 프로그램을 작성하시오.","첫 번째 줄에는 감염된 프로그램의 개수 N 과 바이러스 코드 추정을 위한 최소 길이를 나타내는 정수 K 가 주어진다. 단, 2 ≤ N ≤ 100이고, 4 ≤ K ≤ 1,000이다. 두 번째 줄부터 각 프로그램에 대한 정보가 주어지는데, 먼저 i 번째 프로그램의 길이를 나타내는 정수 M
i
가 주어지고, 다음 줄에 프로그램 코드를 나타내는 M
i
개의 양의 정수가 공백을 사이에 두고 주어진다. 단, 10 ≤ M
i
 ≤ 1,000이고, 프로그램 코드를 나타내는 각 정수의 범위는 1이상 10,000 이하이다.","바이러스 코드로 추정되는 부분이 있으면 YES를 출력하고, 없으면 NO를 출력해야 한다.","3 4
13
10 8 23 93 21 42 52 22 13 1 2 3 4
11
1 3 8 9 21 42 52 22 13 41 42
10
9 21 42 52 13 22 52 42 12 21",YES,
9240,로버트 후드,Platinum III,"로버트 후드는 로빈 후드의 동생이다. 로버트 후드는 자신의 형처럼 전설적인 인물이 되기 위해 활 쏘기를 연습하고 있다.


이번에 노팅엄에서 열린 활 쏘기 대회는 현대에 열리는 양궁과 규칙이 다르다. 양궁은 더 많은 점수를 쏜 사람이 승리하는 방식이다. 하지만, 노팅엄 활 쏘기 대회에서는 과녁에 맞은 화살 사이의 거리 중 최댓값이 가장 큰 사람이 승리한다.


로버트 후드는 총 C발을 발사했고, 모든 화살은 과녁에 적중했다. 과녁을 이차원 평면으로, 화살은 점으로 나타낸다. 화살의 좌표가 주어졌을 때, 가장 먼 화살의 거리를 구하는 프로그램을 작성하시오.","첫째 줄에 로버트 후드가 발사한 화살의 수 C (2 ≤ C ≤ 100,000)가 주어진다. 다음 C개 줄에는 화살의 좌표가 주어진다. 좌표는 정수이고, 절댓값은 1,000을 넘지 않는다.","가장 먼 두 화살의 거리를 출력한다. 상대/절대 오차가 10
-6
 이내인 경우에만 정답이다.","2
2 2
-1 -2

---

5
-4 1
-100 0
0 4
2 -3
2 300","5.0

---

316.86590223",
23022,숙제,Gold II,"Albert는 앞으로 n개의 숙제를 해야한다 (편의상 1번부터 n번까지 번호가 붙어있다).


현재 시각은 S 이고, i번째 숙제의 내용은 정해진 시각 t[i]에 공개 된다 (어떤 숙제는 이미 공개 되었지만 Albert가 아직 제출 하지 않았을 수 있다). 각 숙제별로 벌점이 있어서, 만약 Albert가 i번째 숙제를 제출한 시각이 y[i] 라면 (y[i] - t[i]) × v[i] 만큼의 벌점이 부여된다.


숙제는 어렵지 않아서 모든 숙제는 내용이 공개 되는 즉시 풀어서 제출할 수 있지만, 숙제를 하나 제출하고나면 반드시 최소한의 휴식을 취해야 한다. Albert가 취할 수 있는 최소한의 휴식은 ""1 단위 시간"" 이다 (필요하다면 더 많이 쉬는 것도 가능하다).


예를 들어 n = 5, S = 3, t = [1, 2, 3, 4, 5], 그리고 v = [8, 3, 2, 13, 3]이라 하자.




숙제를 순서대로 할 경우, 각 숙제를 제출한 시각은 y = [3, 4, 5, 6, 7]이 된다 (현재 시각이 3임에 유의하자). 이 경우, 총 벌점은 2 × 8 + 2 × 3 + 2 × 2 + 2 × 13 + 2 × 3 = 58 이다.


숙제를 1, 4, 2, 5, 3번 순서로 할 경우, 각 숙제를 제출한 시각은 y = [3, 5, 7, 4, 6]이 된다. 이 경우, 총 벌점은 2 × 8 + 3 × 3 + 4 × 2 + 0 × 13 + 1 × 3 = 36 이다.


숙제를 1, 5, 4, 3, 2 순서대로 할 경우, 각 숙제를 제출한 시각은 y = [3, 8, 7, 6, 5]이 된다. 이때, 숙제 1을 시각 3에 제출하고 숙제 5가 공개될 때 까지 ""2 단위 시간"" 만큼 휴식한다. 이 경우, 총 벌점은 2 × 8 + 6 × 3 + 4 × 2 + 2 × 13 + 0 × 3 = 42 이다.




이 예제에서 두 번째 방법이 벌점을 최소화 하는 방법이다.


Albert가 모든 숙제를 다 제출하면서 달성 가능한 최소한의 벌점이 몇점인지 구해보자.","첫 줄에 테스트 케이스의 수 T가 주어진다.


각 테스트 케이스는 세 줄에 걸쳐 주어진다.


첫 줄에 두 정수 n과 S가 공백으로 구분되어 주어진다.


둘째 줄에 숙제가 언제 나오는지 나타내는 n개의 정수가 (t[1], ..., t[n]) 공백으로 구분되어 주어진다.


셋째 줄에 숙제의 벌점을 나타내는 n개의 정수가 (v[1], ..., v[n]) 공백으로 구분되어 주어진다.",각 테스트 케이스의 정답인 최소 벌점을 각 줄에 출력한다.,"2
5 3
1 2 3 4 5
8 3 2 13 3
5 30
10 20 30 40 50
8 3 2 13 3","36
197",
11284,초성 중성 종성,Bronze I,"한글 글자 하나가 주어진다. 이 글자를 초성, 중성, 종성으로 분해하는 프로그램을 작성하시오.","첫째 줄에 글자 하나가 주어진다. 항상 유니코드 U+AC00..U+D7A3 범위에 포함되어있는 한글이고, UTF-8로 인코딩 되어 있다.","첫째 줄에 초성, 둘째 줄에 중성, 셋째 줄에 종성을 출력한다. 종성이 없는 경우에는 빈 줄을 출력한다.


출력해야 하는 초성은 ㄱ, ㄲ, ㄴ, ㄷ, ㄸ, ㄹ, ㅁ, ㅂ, ㅃ, ㅅ, ㅆ, ㅇ, ㅈ, ㅉ, ㅊ, ㅋ, ㅌ, ㅍ, ㅎ 중 하나이고, 중성은 ㅏ, ㅐ, ㅑ, ㅒ, ㅓ, ㅔ, ㅕ, ㅖ, ㅗ, ㅘ, ㅙ, ㅚ, ㅛ, ㅜ, ㅝ, ㅞ, ㅟ, ㅠ, ㅡ, ㅢ, ㅣ중 하나, 종성은 ㄱ, ㄲ, ㄳ, ㄴ, ㄵ, ㄶ, ㄷ, ㄹ, ㄺ, ㄻ, ㄼ, ㄽ, ㄾ, ㄿ, ㅀ, ㅁ, ㅂ, ㅄ, ㅅ, ㅆ, ㅇ, ㅈ, ㅊ, ㅋ, ㅌ, ㅍ, ㅎ 중 하나이다.","가

---

닭

---

백

---

준","ㄱ
ㅏ

---

ㄷ
ㅏ
ㄺ

---

ㅂ
ㅐ
ㄱ

---

ㅈ
ㅜ
ㄴ",
9992,비밀 메시지,Gold I,"상근이는 창영이가 보낸 비밀 메시지를 받았다. 메시지는 알파벳 대문자로만 이루어져 있으며, 길이는 2보다 크거나 같다.


메시지를 해독하려면 메시지에 연산을 수행해야 한다. 연산을 하려면 문자열 S에 S의 일부(전부는 안됨) 문자를 앞에서부터 지운 문자열 또는 S의 일부(전부는 안됨) 문자를 뒤에서부터 지운 문자열을 S의 앞이나 뒤에 붙여야 한다.


예를 들어, 문자열 ABC에 연산을 수행할 수 있는 방법은 총 8가지가 있다.




AABC (A + ABC)


ABABC (AB + ABC)


BCABC (BC + ABC)


CABC (C + ABC)


ABCA (ABC + A)


ABCAB (ABC + AB)


ABCBC (ABC + BC)


ABCC (ABC + C)




상근이가 해독을 완료한 문자열이 입력으로 주어진다. 이때, 이 문자열을 만드는 방법의 수를 출력한다. 연산은 여러 번 수행할 수 있다. 만든 문자열이 같더라도, 연산의 방법이 다르다면 다른 방법으로 친다. 예를 들어, AA에서 AAA를 만드는 방법은 총 4가지가 있다.",첫째 줄에 해독 완료한 문자열이 주어진다. 길이는 100을 넘지 않는다.,"첫째 줄에 입력으로 주어진 문자열을 만드는 방법의 수를 출력한다. 처음 문자열의 길이는 2보다 크거나 같아야 한다. 방법의 수가 매우 커질 수 있기 때문에, 2014로 나눈 나머지를 출력한다. 만약, 불가능한 경우에는 0을 출력한다.",ABABA,8,"ABABA를 만드는 방법은 총 8가지가 있다.




ABA에서 시작 -> AB + ABA


ABA에서 시작 -> ABA + BA


AB에서 시작 -> AB + A -> AB + ABA


AB에서 시작 -> AB + A -> ABA + BA


BA에서 시작 -> A + BA -> AB + ABA


BA에서 시작 -> A + BA -> ABA + BA


ABAB에서 시작 -> ABAB + A


BABA에서 시작 -> A + BABA"
15500,이상한 하노이 탑,Silver II,"승민이는 
기존 하노이 탑 문제
를 약간 변형한 이상한 하노이 탑 문제를 만들었다.


이상한 하노이 탑 문제와 기존 하노이 탑 문제와 다른 점이 2가지가 있는데 하나는 ""쌓아 놓은 원판은 항상 위의 것이 아래의 것보다 작아야 한다.(중간 과정 역시 그래야함)"" 라는 조건이 삭제되었다는 점이고 또 다른 하나는 첫 번째 장대에 원판들이 반경 상관없이 무작위로 배치되어 있다는 점이다.


승민이는 이 문제를 진수에게 주었고 원판을 옮긴 횟수가 12345보다 같거나 작으면 피자를 사주기로 하였다. 진수를 도와 피자를 먹게 해주자!","첫 번째 줄에는 원판의 개수 N (1 ≤ N ≤ 123) 이 주어진다.


두 번째 줄에는 첫 번째 장대에 있는 원판들의 반경 나타내는 정수 a
i
 (1 ≤ a
i
 ≤ N) 들이 공백을 두고 주어진다. (제일 아래에 있는 원판의 반경부터 주어진다.)","첫 번째 줄에 원판을 옮긴 횟수 K (0 ≤ K ≤ 12345) 를 출력한다.


다음 K 개 줄에 걸쳐 A B (1 ≤ A, B ≤ 3) 를 출력하는데 A 번째 장대 맨위에 있는 원판 하나를 B 번째 장대 맨위로 옮긴다는 뜻이다.","3
2 3 1","4
1 2
1 3
1 3
2 3",아래는 예제를 푸는 과정을 나타낸다.
15883,First In Last Out,Gold IV,"다음 16진법 식이 성립하도록 각 영문자에 0 ∼ f 사이의 16진수를 배정하라.


단, 서로 다른 영문자에는 서로 다른 숫자가 배정되어야 하며, 각 수의 첫 글자는 0이 될 수 없다.",없다.,"첫 번째 줄부터 모든 해답을 한 줄에 한 개씩 사전순으로 출력한다.


각 해답은 LIST + FILO = STACK 의 형태로 16진수로 표현해야 하며, a, b, c, d, e, f 는 소문자이다.


0, 1, 2, 3, 4, 5, 6, 7, 8, 9, a, b, c, d, e, f 의 순서를 사전순으로 간주한다.",,"...
d812 + 48d9 = 120eb
d812 + 48da = 120ec
...","예제 출력에 쓰여 있는 해답은 출력 형식을 설명하기 위한 용도이며, 이외의 해답이 존재할 수도 존재하지 않을 수도 있다."
28399,황혼,Platinum IV,"오스타니아는 $N$개의 도시와 이를 잇는 $M$개의 도로로 구성된 나라이다. 도시는 $1$번부터 $N$번까지 차례대로 번호가 붙어 있으며, $i$ $(1\le i\le M)$번째 도로는 $u_i$번 도시에서 $v_i$번 도시로 가는 단방향 도로이다. $i$번째 도로를 거쳐서 이동하면 $w_i$만큼의 시간이 소요된다. 임의의 서로 다른 두 도시에 대해 한 도시에서 다른 도시로 가는 도로는 $1$개 이하이다. 편의상 $u$번 도시에서 $v$번 도시로 가는 도로를 거쳐서 이동하는 데 걸리는 시간을 $w(u,v)$라고 하자.


웨스탈리스는 오스타니아와 냉전 관계에 놓여있는 국가이다. 웨스탈리스는 여러 첩보원을 통해 오스타니아에 대한 $K$개의 정보를 얻었다. 각각의 정보는 하나의 단순 경로로 표현된다. 엄밀히 말해, $j$ $(1\le j\le K)$번째 정보는 $s_j$개의 서로 다른 도시의 나열 $(p_{j,1},p_{j,2},\cdots ,p_{j,s_j})$로 구성되며, $p_{j,t}$번 도시에서 $p_{j,t+1}$번 도시로 가는 도로가 존재한다. $(1\le t<s_j)$ 어떤 도시도 서로 다른 두 개의 정보에 동시에 속해 있지 않다.


웨스탈리스의 첩보원 코드네임 <황혼>은 현재 오스타니아의 $1$번 도시에 있다. 웨스탈리스 정부는 정보 수집을 위해 황혼에게 $x$번 도시까지 이동하라는 지시를 내렸다. 웨스탈리스 최고의 스파이인 황혼은 정보 수집의 효율을 최대화하기 위해 $K$개의 단순 경로 중 어느 것도 포함하지 않는 경로로 이동하기로 했다. 구체적으로, 황혼이 방문한 도시를 차례대로 $(q_1,q_2,\cdots ,q_l)$이라고 하자. 이때, 다음 조건을 모두 충족해야 한다.




$q_i$번 도시에서 $q_{i+1}$번 도시로 가는 도로가 존재한다. $(1\le i<l)$


$(p_{z,1},p_{z,2},\cdots ,p_{z,s_z}) =(q_i,q_{i+1},\cdots ,q_{i+s_z-1})$를 충족하는 정수 $i$와 $z$가 존재하지 않는다.


1번과 2번 조건을 충족하면서 $x$번 도시까지 가는데 걸리는 시간$(=\sum_{i=1}^{l-1}w(q_i,q_{i+1}))$이 최소가 되어야 한다.




당신은 $1$이상 $N$이하의 모든 정수 $x$에 대해 황혼이 $x$번 도시까지 이동할 수 있는지 판별하고, 이동할 수 있다면 황혼이 $x$번 도시까지 가는 데 걸리는 시간을 계산해야 한다.","첫 번째 줄에 세 정수 $N$, $M$, $K$가 공백으로 구분되어 주어진다. $(2\le N\le 2\times 10^5;$ $1\le M\le 3\times 10^5;$ $0\le K\le\frac{N}{2} )$


$1+i$번째 줄에는 오스타니아의 도로를 나타내는 $u_i,v_i,w_i$가 공백으로 구분되어 주어진다. 임의의 $i$에 대해 $u_i$번 도시에서 $v_i$번 도시로 가는 도로는 유일하다. $(1\le i\le M;$ $1\le u_i,v_i\le N;$ $1\le w_i\le 10^9;$ $w_i$는 정수$;$ $u_i\neq v_i)$


$1+M+j$번째 줄에는 단순 경로를 나타내는 $s_j+1$개의 정수 $s_j$, $p_{j,1}$, $\cdots$, $p_{j,s_j}$가 공백으로 구분되어 주어진다. $K$개의 단순 경로에 대해 각 도시는 최대 $1$번 나타나며, 입력에 주어진 순서대로 도로를 따라 이동할 수 있음이 보장된다. $(1\le j\le K;$ $s_j\ge 2;$ $\sum_{j=1}^{K}s_j\le N)$","공백으로 구분된 $N$개의 정수를 첫 번째 줄에 출력한다.


$i$번째 정수는 황혼이 모든 조건을 충족하며 $i$번 도시까지 가는데 걸리는 시간이어야 한다. 만약 $i$번 도시에 도달할 수 없다면 
-1
을 출력한다.","4 4 1
1 2 2
1 3 1
2 4 2
3 4 5
2 2 4

---

4 4 2
1 2 2
1 3 1
2 4 2
3 4 5
2 1 3
2 2 4

---

11 12 3
1 2 40
2 3 40
3 1 40
2 4 20
3 6 10
9 1 1
10 11 1
3 7 1
7 6 2
6 7 3
7 8 4
4 5 3
4 1 2 4 5
3 3 7 8
2 10 11","0 2 1 6

---

0 2 -1 -1

---

0 40 80 60 -1 83 81 90 -1 -1 -1",
2466,책장,Diamond IV,"찬수는 1번에서 N번까지 번호가 매겨진 N권의 책을 가지고 있다. 찬수는 이 책을 꽂을 수 있는 책장을 설계하려고 한다. 찬수가 가지고 있는 i번 책의 두께는 t
i
이고, 높이는 h
i
이다. 단, 1 ≤ i ≤ N이다. 이 책들을 번호 순서대로 책장에 꽂아야하고 번호의 순서를 임의로 바꾸어 꽂을 수 없다.


이 책들을 책장의 가장 아래 칸부터 위 칸의 순서로, 같은 칸에서는 왼쪽부터 오른쪽으로 책의 번호 순서로 꽂는다. 한번 위 칸으로 옮겨와서 책을 꽂으면 다시 아래 칸으로 내려가서 책을 꽂을 수 없다. 책장의 칸의 높이는 그 칸에 꽂는 책들 중 가장 높이가 높은 책에 의해 결정되며 책이 꽂혀있는 칸들의 높이의 합이 책장의 높이가 된다. 책장의 폭은 꽂혀있는 책의 두께의 합이 가장 큰 칸에 의해 결정된다. 단, 책장을 구성하는 나무의 두께는 고려하지 않는다. 


책을 모두 꽂은 후의 책장 전체의 높이를 H, 책장의 폭을 L이라고 할 때, 찬수는 H와 L중 최댓값을 최소로 하는 책장을 설계하려고 한다.


이 책장의 H와 L중 최댓값을 최소로 하는 책장을 구하는 프로그램을 작성하시오.","입력의 첫 번째 줄에 책의 수를 나타내는 하나의 정수 N이 주어진다. 두 번째 줄부터 N개의 줄에, 책들의 번호 순서대로 한 줄에 한권씩, 각 책에 대한 두께 t
i
와 높이 h
i
를 나타내는 두 정수가 하나의 빈칸을 사이에 두고 주어진다.",첫째 줄에 책을 모두 꽂은 후의 책장 전체의 높이와 책장의 폭 중에서 최댓값을 최소로 하는 값을 하나의 정수로 출력한다.,"7
8 6
2 3
6 5
4 5
5 7
1 2
5 4

---

9
2 2
7 5
3 8
4 4
7 4
8 7
9 2
6 6
7 9","16

---

22",
3659,RFID 추적,Platinum III,"선영이는 창고를 하나 운영하고 있다. 고객이 선영이에게 물건을 주문을 했을 때, 선영이는 물건을 창고에서 찾아서 박스에 포장해 택배로 보낸다.


창고에 보관되는 모든 물건에는 RFID 칩이 하나씩 붙어져 있다. 또, 창고의 천장에는 물건의 위치를 추적하기 위한 센서가 붙여져 있다.


각 센서의 범위는 r이다. 즉, 센서와의 일직선 거리가 많아야 r인 칩의 위치를 알 수 있다는 뜻이다. 하지만, 센서와 물건 사이의 일직선이 벽과 교차하거나 접하는 경우에는 교차하거나 접한 벽의 개수만큼 범위가 줄어든다. 또, 센서가 너무 가까이 있으면 간섭을 일으킬 수 있기 때문에, 모든 센서들 사이의 거리는 적어도 r이다. 센서나 물건이 벽에 위치한 경우는 없다.


각 물건에 대해서, 그 물건의 RFID 칩을 읽을 수 있는 센서를 구하는 프로그램을 작성하시오.","첫째 줄에 테스트 케이스의 개수가 주어진다. 테스트 케이스는 100개를 넘지 않는다.


각 테스트 케이스의 첫째 줄에는 센서의 수 s, 센서의 범위 r, 벽의 수 w, 물건의 수 p가 주어진다. (1 ≤ s ≤ 250,000, 1 ≤ r ≤ 20, 0 ≤ w ≤ 10, 1 ≤ p ≤ 10,000)


다음 s개 줄에는 센서의 위치 (xi, yi)가 주어진다. 각 센서 간의 거리는 적어도 r이다. (-10,000 ≤ xi, yi ≤ 10,000)


다음 w개 줄에는 네 정수 bxi, byi, exi, eyi가 주어진다. (-10,000 ≤ bxi, byi, exi, eyi ≤ 10,000) 벽은 (bxi, byi)와 (exi, eyi)를 잇는 선분이고, 선분의 길이는 양수이다.


마지막 p개 줄에는 물건의 위치 (pxi, pyi)가 주어진다. (-10,000 ≤ pxi, pyi ≤ 10,000)","각 테스트 케이스에 대해서, 각 물건을 감지할 수 있는 센서의 개수와 위치를 출력한다. 만약, 센서가 여러 개라면, x좌표가 증가하는 순으로, x좌표가 같으면 y좌표가 증가하는 순으로 출력한다.","1
4 3 4 7
0 0
-1 3
2 3
11 5
-4 -1 5 -1
3 4 6 1
11 4 11 3
12 5 12 8
1 1
0 -2
4 4
11 2
13 5
13 7
14 5","3 (-1,3) (0,0) (2,3)
1 (0,0)
0
0
1 (11,5)
0
0",
1280,나무 심기,Platinum IV,"1번부터 N번까지 번호가 매겨져 있는 N개의 나무가 있다. i번 나무는 좌표 X[i]에 심어질 것이다.


동호는 나무를 1번 나무부터 차례대로 좌표 X[i]에 심으려고 한다. 1번 나무를 심는 비용은 없고, 각각의 나무를 심는데 드는 비용은 현재 심어져있는 모든 나무 까지 거리의 합이다. 만약 3번 나무를 심는다면, 1번 나무와의 거리 + 2번 나무와의 거리가 3번 나무를 심는데 드는 비용이다.


2번 나무부터 N번 나무까지를 심는 비용의 곱을 출력하는 프로그램을 작성하시오.","첫째 줄에 나무의 개수 N (2 ≤ N ≤ 200,000)이 주어진다. 둘째 줄부터 N개의 줄에 1번 나무의 좌표부터 차례대로 주어진다. 각각의 좌표는 200,000보다 작은 자연수 또는 0이다.","문제의 정답을 1,000,000,007로 나눈 나머지를 출력한다.","5
3
4
5
6
7

---

3
5
13
9

---

4
1
8
15
1

---

10
4
59
94
89
4
59
94
89
4
59

---

5
199999
197532
99069
83762
14539","180

---

64

---

3087

---

591860767

---

499739175",
10160,암호,Gold I,"새로 바뀐 KOI 웹사이트의 암호는 N개의 영문 알파벳 대문자로 이루어진다. 특별히 암호는 영문 알파벳 중 처음 K개를 사용해서 만든다. 예를 들어, K=5이면, ‘A', 'B', 'C', 'D', 'E'만으로 암호를 만들게 된다. 하지만 문자가 중복되어 나타날 수도 있고 전혀 안 나타날 수도 있다. 


최근 연구에 의해서 2가지의 특정 패턴이 암호에 상당히 많이 나타난다는 사실이 알려졌다. 이 특정 패턴은 ABCBC 와 ABABC 이다. 해커들이 이 정보를 이용할 수 있기 때문에 암호를 만들 때 이 두 패턴 중 어떤 것도 암호 안에 나타나는 것을 피하는 것이 안전한 암호를 만드는 방법이 될 수 있다. 따라서 위의 패턴이 나타나지 않는 암호를 안전한 암호라고 부르고, KOI 웹사이트는 사용자들이 안전한 암호만을 사용하도록 결정하였다. 


예를 들어, N=6, K=3일 때, 위 패턴을 포함하는 암호들은 다음과 같은 12가지가 있다. 




ABCBCA, ABCBCB, ABCBCC, AABCBC,


BABCBC, CABCBC, ABABCA, ABABCB,


ABABCC, AABABC, BABABC, CABABC 




가능한 총 암호의 개수 3
6
 = 729에서 위의 12가지를 제외하면 717가지의 안전한 암호를 만들 수 있다. 


암호의 길이 N, 문자의 가지 수 K가 주어질 때, 만들 수 있는 안전한 암호의 총 개수를 구하는 프로그램을 작성하시오.","첫 줄에는 각각 암호의 길이와 문자의 가지 수를 나타내는 정수 N 과 K가 공백을 사이에 두고 주어진다. 이 두 정수 값의 범위는 5 ≤ N ≤ 1,000,000, 3 ≤ K ≤ 26이다.","출력은 한 줄로 이루어진다. 안전한 암호의 총 개수를 1,000,000,009으로 나눈 나머지를 출력한다. 계산 과정에서 32비트 정수 변수가 표현할 수 있는 범위를 넘어서 64비트 정수 변수를 사용해야 할 수도 있음에 주의하라.","6 3

---

10 3","717

---

56245",
2042,구간 합 구하기,Gold I,"어떤 N개의 수가 주어져 있다. 그런데 중간에 수의 변경이 빈번히 일어나고 그 중간에 어떤 부분의 합을 구하려 한다. 만약에 1,2,3,4,5 라는 수가 있고, 3번째 수를 6으로 바꾸고 2번째부터 5번째까지 합을 구하라고 한다면 17을 출력하면 되는 것이다. 그리고 그 상태에서 다섯 번째 수를 2로 바꾸고 3번째부터 5번째까지 합을 구하라고 한다면 12가 될 것이다.","첫째 줄에 수의 개수 N(1 ≤ N ≤ 1,000,000)과 M(1 ≤ M ≤ 10,000), K(1 ≤ K ≤ 10,000) 가 주어진다. M은 수의 변경이 일어나는 횟수이고, K는 구간의 합을 구하는 횟수이다. 그리고 둘째 줄부터 N+1번째 줄까지 N개의 수가 주어진다. 그리고 N+2번째 줄부터 N+M+K+1번째 줄까지 세 개의 정수 a, b, c가 주어지는데, a가 1인 경우 b(1 ≤ b ≤ N)번째 수를 c로 바꾸고 a가 2인 경우에는 b(1 ≤ b ≤ N)번째 수부터 c(b ≤ c ≤ N)번째 수까지의 합을 구하여 출력하면 된다.


입력으로 주어지는 모든 수는 -2
63
보다 크거나 같고, 2
63
-1보다 작거나 같은 정수이다.","첫째 줄부터 K줄에 걸쳐 구한 구간의 합을 출력한다. 단, 정답은 -2
63
보다 크거나 같고, 2
63
-1보다 작거나 같은 정수이다.","5 2 2
1
2
3
4
5
1 3 6
2 2 5
1 5 2
2 3 5","17
12",
2102,보석 줍기,Platinum IV,"수영이는 고대 유적을 탐사하던 도중 보석을 발견했다. 유적 속에는 N(1 ≤ N ≤ 100,000)개의 보석들이 일렬로 놓여 있었다. 각각의 보석의 가치는 다를 수 있기 때문에, 수영이는 가급적 많은 이득을 얻을 수 있도록 보석을 가져가려 한다. 이때, 다음 세 가지의 조건이 만족되어야 한다.




보석들과 함께 함정이 설치되어 있기 때문에 1번 보석이 놓여있는 곳부터, N번 보석이 놓여 있는 곳까지 순서대로 이동해야 한다. 물론 1번 보석부터 N번 보석까지가 차례로 놓여있다고 가정하며, 보석을 줍다가 도중에 뒤로 돌아갈 수 없는 것이다. 각각의 보석이 놓여 있는 위치에서 수영이는 두 가지 선택을 할 수 있는데, 그 자리에 있는 보석을 줍거나 줍지 않고 그 다음 보석이 놓여 있는 곳으로 이동하게 된다.


또한 보석들과 함께 경보 장치가 설치되어 있는데, 이 장치는 보석을 한 개 주우면 작동하게 된다. 보석을 한 개 더 줍게 되면 이 경보 장치는 유적을 무너뜨리도록 설계되어 있다. 단, 경보 장치를 속일 수 있는 방법이 있는데, M(1 ≤ M ≤ N)개 이상의 연속적인 보석을 줍게 되면 경보 장치가 인식하지 못하게 된다. 따라서 보석을 줍기 시작하면 그 위치에 있는 보석을 포함하여 M개 이상의 보석을 연속적으로 주워야 하고, 줍기를 멈춘 후에는 다시 줍기 시작할 수 없다. 즉, 보석을 주울 기회는 오직 한 번 뿐이며, 보석을 주울 때에는 연속적으로 M개 이상 주워야 한다.


주운 보석들의 가치의 합이 크더라도, 보석의 개수가 많다면 무게가 많이 나가서 힘들 수도 있다. 물론, 보석들의 가치의 합이 충분히 크다면 무거움을 감수할 수도 있다. 따라서 수영이는 주운 보석들의 가치의 평균이 최대가 되도록 하려 한다.




보석들의 개수가 매우 많기 때문에, 수영이는 이 문제를 컴퓨터를 이용하여 풀기로 하였다. 보석들에 대한 정보가 주어졌을 때, 위의 조건들을 만족하면서 보석을 주울 때, 가치의 평균의 최댓값을 구하는 프로그램을 작성하시오.","첫째 줄에 두 정수 N, M이 주어진다. 다음 N개의 줄에는 차례로 각 보석의 가치가 주어진다. 각 보석의 가치는 0 이상 2,000 이하의 정수이다.","첫째 줄에 가치의 평균의 최댓값을 1,000배 한 정수를 출력한다. 반올림 문제가 생길 수 있으므로, 정수 연산을 하여 1,000×(가치의 총 합)/(보석의 개수)을 출력하도록 한다.","10 6
6
4
2
10
3
8
5
9
4
1",6500,
4963,섬의 개수,Silver II,"정사각형으로 이루어져 있는 섬과 바다 지도가 주어진다. 섬의 개수를 세는 프로그램을 작성하시오.




한 정사각형과 가로, 세로 또는 대각선으로 연결되어 있는 사각형은 걸어갈 수 있는 사각형이다. 


두 정사각형이 같은 섬에 있으려면, 한 정사각형에서 다른 정사각형으로 걸어서 갈 수 있는 경로가 있어야 한다. 지도는 바다로 둘러싸여 있으며, 지도 밖으로 나갈 수 없다.","입력은 여러 개의 테스트 케이스로 이루어져 있다. 각 테스트 케이스의 첫째 줄에는 지도의 너비 w와 높이 h가 주어진다. w와 h는 50보다 작거나 같은 양의 정수이다.


둘째 줄부터 h개 줄에는 지도가 주어진다. 1은 땅, 0은 바다이다.


입력의 마지막 줄에는 0이 두 개 주어진다.","각 테스트 케이스에 대해서, 섬의 개수를 출력한다.","1 1
0
2 2
0 1
1 0
3 2
1 1 1
1 1 1
5 4
1 0 1 0 0
1 0 0 0 0
1 0 1 0 1
1 0 0 1 0
5 4
1 1 1 0 1
1 0 1 0 1
1 0 1 0 1
1 0 1 1 1
5 5
1 0 1 0 1
0 0 0 0 0
1 0 1 0 1
0 0 0 0 0
1 0 1 0 1
0 0","0
1
1
3
1
9",
27436,벌집 2,Silver III,"위의 그림과 같이 육각형으로 이루어진 벌집이 있다. 그림에서 보는 바와 같이 중앙의 방 1부터 시작해서 이웃하는 방에 돌아가면서 1씩 증가하는 번호를 주소로 매길 수 있다. 숫자 N이 주어졌을 때, 벌집의 중앙 1에서 N번 방까지 최소 개수의 방을 지나서 갈 때 몇 개의 방을 지나가는지(시작과 끝을 포함하여)를 계산하는 프로그램을 작성하시오. 예를 들면, 13까지는 3개, 58까지는 5개를 지난다.","첫째 줄에 N(1 ≤ N ≤ 9 × 10
18
)이 주어진다.",입력으로 주어진 방까지 최소 개수의 방을 지나서 갈 때 몇 개의 방을 지나는지 출력한다.,13,3,
22865,가장 먼 곳,Gold IV,"$N$개의 땅 중에서 한 곳에 자취를 하려고 집을 알아보고 있다. 세 명의 친구 $A$, $B$, $C$가 있는데 이 친구들이 살고 있는 집으로부터 가장 먼 곳에 집을 구하려고 한다.


이때, 가장 먼 곳은 선택할 집에서 거리가 가장 가까운 친구의 집까지의 거리를 기준으로 거리가 가장 먼 곳을 의미한다.


예를 들어, $X$ 위치에 있는 집에서 친구 $A$, $B$, $C$의 집까지의 거리가 각각 3, 5, 4이라 가정하고 $Y$ 위치에 있는 집에서 친구 $A$, $B$, $C$의 집까지의 거리가 각각 5, 7, 2라고 하자.


이때, 친구들의 집으로부터 땅 $X$와 땅 $Y$ 중 더 먼 곳은 땅 $X$이다. 왜냐하면 $X$에서 가장 가까운 친구의 집까지의 거리는 3이고, $Y$에서는 $2$이기 때문이다.


친구들이 살고 있는 집으로부터 가장 먼 곳을 구해보자.","첫번째 줄에 자취할 땅 후보의 개수 $N$이 주어진다.


2번째 줄에는 친구 $A$, $B$, $C$가 사는 위치가 공백으로 구분되어 주어진다. 이때 친구들은 $N$개의 땅 중 하나에 사는 것이 보장된다. (같은 위치에서 살 수 있다.)


3번째 줄에는 땅과 땅 사이를 잇는 도로의 개수 $M$이 주어진다.


그 다음줄부터 $M + 3$번째 줄까지 땅 $D$, 땅 $E$, 땅 $D$와 땅 $E$와 사이를 연결하는 도로의 길이 $L$이 공백으로 구분되어 주어진다. 이 도로는 양뱡항 통행이 가능하다.",친구들이 살고 있는 집으로부터 가장 먼 곳의 땅 번호를 출력한다. 만약 가장 먼 곳이 여러 곳이라면 번호가 가장 작은 땅의 번호를 출력한다.,"6
1 2 5
8
1 2 1
2 3 4
1 4 2
2 5 3
1 6 5
5 6 2
3 4 2
4 5 6",3,
1019,책 페이지,Platinum V,"지민이는 전체 페이지의 수가 N인 책이 하나 있다. 첫 페이지는 1 페이지이고, 마지막 페이지는 N 페이지이다. 각 숫자가 전체 페이지 번호에서 모두 몇 번 나오는지 구해보자.","첫째 줄에 N이 주어진다. N은 1,000,000,000보다 작거나 같은 자연수이다.","첫째 줄에 0이 총 몇 번 나오는지, 1이 총 몇 번 나오는지, ..., 9가 총 몇 번 나오는지를 공백으로 구분해 출력한다.","11

---

7

---

19

---

999

---

543212345","1 4 1 1 1 1 1 1 1 1

---

0 1 1 1 1 1 1 1 0 0

---

1 12 2 2 2 2 2 2 2 2

---

189 300 300 300 300 300 300 300 300 300

---

429904664 541008121 540917467 540117067 533117017 473117011 429904664 429904664 429904664 429904664",
25433,PLCS,Ruby V,"PLCS(Prime Longest Common Subsequence, 소수 최장 공통 부분 수열)문제는 두 수열이 주어졌을 때, 모두의 부분 수열이 되는 수열 중 길이가 소수이면서 가장 긴 것을 찾는 문제이다.


문자열 $A$, $B$와 PLCS에 포함되어야 하는 문자 $X$와 PLCS에 포함되면 안되는 문자 $Y$가 주어진다. 문자 $X$를 포함하고 문자 $Y$를 포함하지 않는 문자열 $A$, $B$의 공통 부분 수열 중 길이가 소수이면서 가장 긴 문자열의 길이를 출력하자. 이러한 문자열이 존재하지 않으면 -1을 출력한다.


문자열 $A$, $B$와 문자 $X$, $Y$는 알파벳 소문자로 구성되어 있으며, 문자열 $A$, $B$에는 문자 $X$가 
정확히 하나씩
 존재한다.","첫째 줄에 문자열 $A$가 주어진다.


둘째 줄에 문자열 $B$가 주어진다. $(1 ≤ |A|$, $|B| ≤ 50,000)$


셋째 줄에 문자 $X$가 주어진다.


넷째 줄에 문자 $Y$가 주어진다. $(X \neq Y)$","첫째 줄에 문자 $X$를 포함하고 문자 $Y$를 포함하지 않는 문자열 $A$, $B$의 PLCS의 길이를 출력한다. 이러한 PLCS가 존재하지 않으면 -1을 출력한다.","aabbcbad
ababacda
c
b

---

aabaaa
cccbcc
b
c

---

aabaaa
bca
b
x","3

---

-1

---

2",
12867,N차원 여행,Silver II,"수빈이는 여행을 좋아한다. 더 이상 지구에서 여행할 곳이 없어진 수빈이는 N차원 우주로 여행을 떠났다. 우주의 각 점은 좌표 N개로 이루어 지며, 각각의 좌표는 1부터 N까지 인덱스가 매겨져 있다.


수빈이는 원점(모든 좌표가 0인 곳)에서  여행을 시작하며, 아래와 같은 방법으로 움직인다.




첫 번째로 움직일 좌표의 인덱스를 고른다. (1부터 N까지 중의 하나)


그 다음, 그 좌표의 값을 1만큼 증가시킨 곳이나 감소시킨 곳으로 이동한다. (다른 좌표는 이동하기 전과 같아야 한다)




수빈이는 여행을 떠나기 전에 여행 계획을 작성해 놓았고, 같은 점을 두 번 이상 방문하는지 아닌지 알아보려고 한다.


수빈이가 여행 계획에서 고른 좌표 인덱스와, 좌표가 증가하는 방향으로 이동했는지, 감소하는 방향으로 이동했는지가 주어진다. 수빈이가 첫 번째 점과 마지막 점을 포함한 모든 점을 중복해서 방문하지 않게 방문할 수 있다면 1을, 아니면 0을 구하는 프로그램을 작성하시오.","첫째 줄에 N (1 ≤ N ≤ 1,000,000,000)이 주어진다.


둘째 줄에는 수빈이의 여행 계획의 길이 M (1 ≤ M ≤ 50)이 주어진다.


셋째 줄에는 수빈이가 여행 계획에서 고른 좌표의 인덱스가 순서대로 주어진다.


넷째 줄에는 증가하는 방향으로 이동할 것인지, 감소하는 방향으로 이동할 것인지를 나타내는 문자열이 주어지며, +는 증가하는 방향, -는 감소하는 방향을 나타낸다.","모든 점을 중복해서 방문하지 않을 수 있으면 1을, 아니면 0을 출력한다.","1
1
1
+

---

2
4
1 2 1 2
++--

---

3
5
1 2 3 1 2
+++--","1

---

0

---

1","예제 2의 경우에 (0,0) -> (1,0) -> (1,1) -> (0,1) -> (0,0)으로 이동하게 되어서 (0, 0)을 두 번 방문하게 되고, 예제 3의 경우에는 (0,0,0) -> (1,0,0) -> (1,1,0) -> (1,1,1) -> (0,1,1) -> (0,0,1) 으로 방문하게 되어서 모든 점을 중복하지 않게 방문한다."
18231,파괴된 도시,Gold V,"저명한 역사학자 지수는 오래된 지도 한 장을 주웠다. 이 지도는 
N
개의 도시와 
M
개의 도로로 이루어져 있으며, 각 도시는 1부터 
N
까지 하나씩 번호가 매겨져있다. 지도에는 불에 탄 모습의 
K
개의 도시가 있었는데, 지수는 이 지도가 전쟁 당시 파괴된 도시를 표시한 지도임을 알아차렸다. 연구한 바에 의하면, 어떤 도시에 그 당시 사용했던 폭탄을 떨어뜨리면 이 도시를 포함하여 인접한 도시들은 전부 파괴된다고 한다.




지수는 이 사실을 토대로 당시 폭탄이 떨어진 지점들을 알아내기 위해 우리를 초대했다. 우리는 폭탄이 떨어진 지점들을 전부 알아내야 한다. 어떤 방법으로도 지도와 같은 모양이 나오지 않을 수 있다. 이 경우도 판별해보자.","첫째 줄에 도시의 개수 
N
(1 ≤ 
N
 ≤ 2000)과 도로의 개수 
M
(1 ≤ 
M
 ≤ min(
N
×(
N
-1)/2, 100,000))이 주어진다.


그 다음 
M
개의 줄에는 도시 
U
i
와 
V
i
가 주어진다. (1 ≤ 
U
i
, 
V
i
 ≤ 
N
)


이는 도시 
U
i
와 
V
i
가 하나의 도로로 연결되었음을 의미한다. 
U
i
와 
V
i
가 같은 경우는 없으며, 같은 도시 쌍을 잇는 도로는 최대 하나만 존재한다.


그 다음 줄에 파괴된 도시의 개수 
K
(1 ≤ 
K
 ≤ 
N
)가 주어진다.


그 다음 줄에 파괴된 도시의 번호를 의미하는 
K
개의 정수 
P
i
(1 ≤ 
P
i
 ≤ 
N
)가 공백으로 구분되어 주어진다. 파괴된 도시의 번호가 중복되는 경우는 없다.","만약, 어떤 경우라도 지도와 같은 모양이 나오지 않는다면 
-1
을 출력하라.


그렇지 않은 경우, 첫째 줄에 폭탄이 떨어진 도시의 개수 
T
를 출력하라.


그 다음 줄에는 폭탄이 떨어진 도시의 번호를 의미하는 
T
개의 정수를 공백으로 구분하여 출력하라. 출력에 중복된 도시의 번호가 존재해선 안된다.


만약, 정답으로 가능한 경우가 여러 가지라면 그중 하나를 출력하라.","5 10
1 2
1 3
1 4
1 5
2 3
2 4
2 5
3 4
3 5
4 5
4
1 2 3 4

---

5 3
1 2
3 2
5 4
4
1 2 4 5

---

11 14
1 2
1 3
1 9
1 10
1 4
1 6
9 10
9 8
3 10
10 11
6 8
6 7
6 5
4 5
10
10 3 1 9 11 8 6 7 4 5","-1

---

2
1 4

---

3
5 6 10",
29793,라라와 용맥 변환,Gold III,"여러분, 그거 알아요?


자연에서 태어난 모든 생명들은 바람과 물로 이루어져 햇빛을 받아 이 땅에 존재한다고 해요. 그래서 땅을 보면 우리가 어떻게 살아야 하는지 알 수 있대요.


바람처럼 열린 마음으로 날아오르고 강처럼 쉬지 않고 앞으로 나아가다가 햇빛처럼 괴로운 마음들을 따뜻하게 달래 주고 산처럼 고요히 머무르다 가면 되는 거래요.


-라라 튜토리얼 스토리 중-
 






메이플스토리의 직업 라라는 
용맥 분출
이라는 스킬을 이용해 사냥한다.


라라는 
해
, 
강
, 
바람
의 세 종류 용맥을 발견할 수 있는데, 용맥 분출을 사용하면 용맥을 
소모
하여 해당 위치에 지속적으로 데미지를 주는 
토지령
이라는 소환수를 소환할 수 있다. 토지령 역시 
해
, 
강
, 
바람
의 세 종류 토지령이 있고, 소모한 용맥과 같은 종류의 토지령이 소환된다. 각 토지령은 종류별로 한 마리씩만 소환할 수 있고, 토지령을 소환할 때 같은 종류의 토지령이 이미 소환되어 있다면 기존에 소환되어 있던 같은 종류의 토지령은 사라지고 종류별로 가장 마지막에 소환된 토지령만이 남는다.


예를 들어 
해의 토지령
과 
강의 토지령
이 소환되어 있는 상태에서 용맥 분출로 
바람 용맥
을 소모했을 경우, 그 위치에 
바람의 토지령
이 소환된다. 그러나 여기서 
해 용맥
을 소모했을 경우, 기존에 있던 
해의 토지령
이 사라지고 새로운
 해의 토지령
이 소환된다. 
강의 토지령
과 
바람의 토지령
은 
해의 토지령
과는 종류가 다르기 때문에 사라지지 않는다.


용맥 분출에는 한 가지 단점이 있는데, 적절한 종류의 용맥을 소모하지 못한다면 소환했던 토지령이 너무 빠르게 사라져 몬스터에게 충분한 데미지를 주지 못할 수도 있다. 이를 보완하기 위해 라라는 또 다른 스킬인 
용맥 변환
을 가지고 있다. 용맥 변환을 사용할 때마다 원하는 위치의 용맥 하나를 원하는 다른 종류의 용맥으로 변환할 수 있다.


예를 들어 
해 용맥
, 
해 용맥
, 
해 용맥
이 순서대로 있는 상태에서 두 번째 용맥에 용맥 변환을 사용해 
바람 용맥
으로 변환할 수 있다. 이 경우 용맥의 배치는 
해 용맥
, 
바람 용맥
, 
해 용맥
이 된다. 이어서 세 번째 용맥에 용맥 변환을 사용해 
강 용맥
으로 변환할 경우, 용맥의 배치는 
해 용맥
, 
바람 용맥
, 
강 용맥
이 된다.


라라는 $N$개의 용맥이 일렬로 있고, 각 용맥마다 체력이 $H$인 몬스터가 한 마리씩 있는 직선형 맵에서 사냥하려고 한다. 라라는 이 맵의 가장 왼쪽 용맥에서부터 시작하고, 다음과 같은 과정이 반복되어 사냥이 진행된다.




라라가 현재 위치한 곳의 용맥을 소모하여 용맥 분출을 한다. 소모한 용맥에 따른 토지령이 소환되고, 기존에 소환되어 있던 같은 종류의 토지령은 즉시 사라진다.


현재 소환되어 있는 모든 토지령이 그 위치에 있는 몬스터에게 데미지를 주고, 체력을 $1$ 감소시킨다. 몬스터의 체력이 $0$이 되었다면 그 몬스터는 처치된다.


라라가 오른쪽으로 인접한 용맥으로 이동한다. 이동할 수 있다면 반드시 이동을 하고, 맵의 오른쪽 끝에 도달해 이동할 용맥이 없다면 현재 토지령이 소환되어 있는 위치의 몬스터가 모두 처치되고, 사냥을 끝마친다.




라라는 맵에 있는 
모든
 몬스터를 처치하기 위해 사냥을 시작하기 전 용맥 변환으로 용맥의 종류를 바꿀 것이다. 단, 용맥 변환은 쿨타임이 있는 스킬이기 때문에 빠른 사냥을 위해 최소한의 횟수로 사용할 것이다.


맵의 
모든
 몬스터를 처치하면서 용맥 변환을 최소한으로 사용할 때, 그 횟수를 라라에게 알려주자.","첫 번째 줄에는 맵에 있는 용맥의 수와 몬스터의 체력을 나타내는 두 정수 $N$, $H$가 공백으로 구분되어 주어진다. $(1 \le N, H \le 1\,000\,000)$


두 번째 줄에는 맵에 있는 용맥의 종류를 순서대로 나타내는 길이 $N$의 공백 없는 문자열이 주어진다.


문자열은 
S
, 
R
, 
W
로만 이루어져 있고, 각각 용맥의 세 종류인 
해
, 
강
, 
바람
을 나타낸다.","맵의 
모든
 몬스터를 처치하기 위해 사용해야 하는 용맥 변환 횟수의 최솟값을 출력한다.


만약 아무리 많은 용맥 변환을 사용하더라도 맵의 
모든
 몬스터를 처치할 수 없다면 대신 
-1
을 출력한다.","3 4
SRW

---

3 1
SSS

---

3 2
SSS

---

3 3
SSS

---

4 4
SSSS","0

---

0

---

1

---

2

---

-1",
16195,"1, 2, 3 더하기 9",Silver I,"정수 4를 1, 2, 3의 합으로 나타내는 방법은 총 7가지가 있다. 합을 나타낼 때는 수를 1개 이상 사용해야 한다.




1+1+1+1


1+1+2


1+2+1


2+1+1


2+2


1+3


3+1




정수 n과 m이 주어졌을 때, n을 1, 2, 3의 합으로 나타내는 방법의 수를 구하는 프로그램을 작성하시오. 단, 사용한 수의 개수는 m개 이하 이어야 한다.","첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, 정수 n과 m이 주어진다. n은 양수이며 1,000보다 작거나 같다. m도 양수이며, n보다 작거나 같다.","각 테스트 케이스마다, n을 1, 2, 3의 합으로 나타내는 방법의 수를 1,000,000,009로 나눈 나머지를 출력한다. 단, 사용한 수의 개수는 m개 이하 이어야 한다.","3
4 2
7 5
10 6

---

4
4 1
4 2
4 3
4 4

---

7
7 1
7 2
7 3
7 4
7 5
7 6
7 7

---

10
10 1
10 2
10 3
10 4
10 5
10 6
10 7
10 8
10 9
10 10","3
37
151

---

0
3
6
7

---

0
0
6
22
37
43
44

---

0
0
0
10
61
151
228
264
273
274",
1243,팰린드롬,Diamond IV,"뒤집어도 같은 말이 되는 단어를 팰린드롬(Palindrome)이라고 한다. N개의 서로 다른 영어 단어가 주어질 때 이를 이어 붙여 길이가 L인 팰린드롬을 모두 몇 가지 방법으로 만들 수 있는지 출력하는 프로그램을 작성하시오. 단, 하나의 단어를 중복해서 사용할 수 있으며, 서로 다른 조합이나 순서로 단어를 붙여 같은 팰린드롬을 만든 경우 다른 방법으로 간주한다.


예를 들어 N이 5, L이 4라고 하고 A, AA, BB, BC, CB 이렇게 5개의 영어 단어가 주어졌다고 하자. 이 경우 아래와 같이 총 9개의 방법으로 팰린드롬을 만들 수 있다.




A|A|A|A


AA|A|A


A|AA|A


A|A|AA


AA|AA


A|BB|A


BB|BB


BC|CB


CB|BC","첫째 줄에 N이, 둘째 줄에 L이 주어진다. N은 50이하의 자연수, L은 30이하의 자연수이다. 셋째 줄부터 N개의 줄에 한 줄에 하나씩 영문자 대문자로만 이루어진 길이가 15이하인 영어 단어가 주어진다. 주어지는 모든 영어 단어는 서로 다르다.",첫째 줄에 입력으로 주어진 단어를 이어 붙여 길이가 L인 팰린드롬을 만들 수 있는 방법의 수를 출력한다. 그 방법의 수는 21억을 넘지 않는다.,"5
4
A
AA
BB
BC
CB",9,
4900,7 더하기,Silver III,"7 세그먼트 디스플레이는 오른쪽 그림과 같이 일곱개의 LED로 이루어져 있다. 각각의 LED는 켜있거나 꺼져있을 수 있고, 독립적으로 작동한다. 이러한 LED의 조합은 총 127가지가 있으며, 주로 숫자 0부터 9까지를 표현하는데 사용된다. 



	프로그래머는 이 디스플레이에 7비트 숫자를 전송해서 조정할 수 있다. 예를 들어, 1을 표시하려면 1번과 3번 LED만 켜야한다. 따라서, 0001010을 전송하면 된다. 이 7비트 숫자를 코드라고 하며, 보통 10진수로 표현한다. 



	LED의 조합은 총 127가지가 있기 때문에, 코드는 3자리 숫자로 나타낼 수 있다. 예를 들어, 1은 0001010을 전송하면 되고 이 수의 10진수 값은 10이기 때문에, 코드로는 010으로 나타낸다.



	한 자리 이상의 수를 나타낼 때는 코드를 이어서 사용하면 된다. 예를 들어, 13은 010079로 나타내면 되고, 144는 010106106으로 나타내면 된다.







	7 세그먼트 디스플레이 상에서 코드로 나타낸 두 수가 주어졌을 때, 두 수의 합을 7 세그먼트 디스플레이에서 코드로 출력하는 프로그램을 작성하시오.","입력은 여러 개의 테스트 케이스로 이루어져 있다. 각 테스트 케이스는 A+B=꼴이며, A와 B는 두 수 a와 b를 7 세그먼트 디스플레이 상에서의 코드로 표현한 값이다. (0 < a,b < a+b < 1,000,000,000) 마지막 줄에는 BYE가 주어진다.","각 테스트 케이스에 대해서, 한 줄에 하나씩 A+B=C를 출력한다. A와 B는 입력에서 주어진 값이며, C는 a+b를 다시 7 세그먼트 디스플레이 코드로 나타낸 값이다.","010079010+010079=
106010+010=
BYE","010079010+010079=010106106
106010+010=106093",
4096,팰린드로미터,Silver IV,"승환이는 팰린드롬을 좋아한다. 지금 승환이의 자동차의 주행 거리계에 100000이 적혀있다. 승환이는 1km만 더 주행을 하면 100001이 된다! 승환이는 엄청나게 흥분했다.


주행 거리계에 적혀져 있는 수가 주어졌을 때, 몇 km를 더 주행하면 팰린드롬이 되는지 구하는 프로그램을 작성하시오. 승환이는 모든 자리가 팰린드롬이 되어야 한다. 따라서, 주행 거리계에 00121인 경우에는 팰린드롬이 아니다.","입력은 여러 테스트 케이스로 이루어져 있다. 각 테스트 케이스는 한 줄로 이루어져 있고, 현재 승환이의 주행 거리계에 적혀있는 수가 주어진다.이 숫자는 2자리와 9자리 사이(포함)이다. 예를 들어, 주행 거리계에 적히는 숫자의 갯수는, 입력으로 주어진 수의 숫자의 갯수와 같다. 그래서, 입력이 00456이라면, 5자리 숫자이다. 마지막 줄에는 0이 적혀있다.",각 테스트 케이스에 대해서 주행 거리계의 수가 팰린드롬이 되기 위해 주행해야 하는 최소 거리를 출력한다. 만약 이미 팰린드롬이라면 0을 출력한다.,"100000
100001
000121
00456
0","1
0
979
44",
20302,민트 초코,Gold IV,"상원이는 아주 특별한 방법으로 디저트를 고른다.


상원이는 정수의 곱셈과 나눗셈으로만 이뤄진 임의의 수식을 적고, 그 결과가 정수이면 “민트 초코”를, 정수가 아닌 유리수이면 “치약”을 먹기로 했다.


상원이가 적은 수식이 주어졌을 때, 어떤 디저트를 먹게 될지 맞혀보자.","첫째 줄에 수식을 이루는 수의 개수 $N$이 주어진다. ($1 \leq N \leq 100\ 000$)


둘째 줄에 수식이 주어진다. 수식은 정수와 연산자(
*
, 
/
)가 공백으로 구분되어 주어진다. 수식은 정수와 연산자가 번갈아 주어지며, 항상 정수로 시작해서 정수로 끝난다. 수식을 이루는 모든 정수는 $-100\ 000$ 이상 $100\ 000$ 이하이다.


올바른 수식만 주어지고, $0$으로 나누는 경우는 주어지지 않는다.","상원이가 고른 디저트가 “민트 초코”인 경우 
mint chocolate
, “치약”인 경우 
toothpaste
를 출력한다.","6
1 * 2 / 3 / 4 * 5 * 6

---

6
1 * 2 / 3 / 4 / 5 * 6","mint chocolate

---

toothpaste",
27111,출입 기록,Silver V,"위병소에서 근무하는 헌병은 오늘 근무를 끝마치고 보안 점검을 위해 출입 기록을 살펴보던 중, 오늘 출입 기록의 일부가 누락되었다는 사실을 깨달았다!


오늘 기록된 출입 기록은 총 $N$개이며, 출입 기록은 반드시 출입자가 출입한 시간순으로 기록된다.


$i$번째 출입 기록은 두 개의 정수 $a_i, b_i$로 기록되는데, $a_i$는 출입하는 사람의 번호를 의미하며, $b_i$가 $1$이면 부대로 들어갔다는 뜻이고 $b_i$가 $0$이면 부대에서 나왔다는 뜻이다. 또한, 출입 기록을 시작하기 전과 출입 기록을 끝낸 후에는 부대 내에 아무도 없었다고 한다.


오늘의 출입 기록을 토대로 오늘 하루동안 누락된 출입 기록의 최소 개수를 구하여라.","첫 번째 줄에 출입 기록의 개수 $N$이 주어진다. $(1\leq N\leq 200\,000)$


두 번째 줄부터 $N+1$번째 줄까지, $i$번째 출입 기록을 나타내는 정수 $a_i$와 $b_i$가 공백으로 구분되어 주어진다. $(1\leq a_i\leq 200\,000;$ $0\leq b_i\leq 1)$",오늘 하루 동안 누락된 출입 기록의 최소 개수를 출력한다.,"8
1 1
2 1
1 1
4 1
3 0
5 1
4 0
1 0

---

4
100 1
345 1
345 0
100 0","4

---

0",
17613,점프,Platinum II,"개구리가 수직선 위의 0에서 출발해서 
오른쪽(x좌표가 증가하는 방향)
으로 점프들을 수행한 후 어떤 수 x > 0에 도착하려 한다. 이 때, 점프 간격은 1로부터 시작해서 항상 직전 점프한 간격의 2배로 증가해야 한다.


만일 점프간격을 2배씩 계속 증가시켜 마지막 점프에서 목표 수 x를 지나칠 것 같으면, 필요한 경우 언제든지 점프 간격을 다시 처음 상태인 간격 1로 되돌아 갈 수 있다. 이것을 재시작이라고 부른다. 예를 들어, 아래 <그림 1>과 같이 x = 19에 도달하기 위해서 2번의 재시작을 수행해서 (1+2+4+8)+(1+2)+(1)= 19 와 같이 7번의 점프로 도착할 수 있다.




<그림 1>


개구리가 0에서 출발해서 어떤 양의 정수 N에 도달하기 위한 점프 횟수의 최솟값을 J(N)으로 나타내고 N의 점프넘버라고 부를 것이다. 예를 들어, <그림 1>을 보면 J(1) = 1, J(3) = 2, J(7) = 3, J(15) = 4, J(16) = 5, J(18) = 6, J(19) = 7과 같음을 알 수 있다.


여러분은 어떤 특정 구간 [x, y]안의 수들의 점프넘버들 중 최댓값을 찾아서 출력한다. 즉, 아래 조건을 만족하는 w를 찾아서 출력한다.


w = max{J(i) | x ≤ i ≤ y}","첫 번째 줄에는 여러분에게 주어질 구간의 개수 T가 주어진다.(1 ≤ T ≤ 2,000) 이후 T개의 줄에 대해 답을 구해야 할 구간을 나타내는 두 정수 x, y가 공백을 사이에 두고 주어진다 (1 ≤ x ≤ y ≤ 10
9
).","T개의 줄에 각각 하나의 정수를 출력한다. 각 줄에 출력되는 정수는 구간 [x, y]안의 수들의 점프넘버들 중 최댓값이다. 각 정수는 입력으로 주어지는 구간의 순서에 맞게 출력되어야 한다. 즉, 첫 번째 줄에 출력되는 정답은 첫 번째로 주어지는 구간에 대응되어야 한다.","3
1 4
7 7
12 16","3
3
7",
17947,상남자 곽철용,Platinum V,"우리의 우상 곽철용은 화투로 노름을 하는 것을 매우 좋아한다. 이번에 그는 지인들과 함께 새로운 게임을 해보려고 한다. 


게임은 M명의 참가자로 진행되며, 4 × N장의 카드를 가지고 한다. 카드에 적힌 숫자는 1부터 4 × N까지의 수이며, 중복되는 숫자가 적힌 카드는 존재하지 않는다. M명의 참가자들은 우선 4 × N장의 카드에서 각각 2개의 카드를 뽑아서 버린다. 그리고 다시 M명의 참가자들은 각각 2개의 카드를 뽑는다. 게임의 승부는 두번째에 뽑은 두 장의 카드에 적힌 숫자에 따라 결정된다. 각 참가자의 점수는 두 장의 카드에 적힌 숫자를 K로 나눈 나머지의 차이다. 


곽철용은 두번의 카드 뽑기 후, 초조한 마음에 자신이 이 게임에서 이길 수 있는지 매우 궁금해졌다. 그래서 자신보다 점수가 높은 사람들이 최대 몇 명인지 알고자 한다. 여러분들이 상남자 곽철용의 초조한 마음을 풀어주도록 하자.","첫째 줄에 양의 정수 N, M, K가 주어진다. (1 ≤ M ≤ N ≤ 100,000, 1 ≤ K ≤ 4 × N)


둘째 줄부터 M+1번째 줄까지 각 참가자가 첫 번째 카드 뽑기에서 뽑은 카드에 적힌 두 개의 양의 정수 a
i
와 b
i
가 주어진다. (1 ≤ a
i
, b
i 
≤ 4 × N)


M+2번째 줄에는 곽철용이 두번째 카드 뽑기에서 뽑은 카드에 적힌 두 개의 양의 정수 A와 B가 주어진다. (1 ≤ A, B ≤ 4 × N)",첫째 줄에 곽철용보다 높은 점수를 가진 사람들이 최대 몇 명인지 출력한다.,"5 5 5
10 2
3 7
4 8
14 6
12 18
9 11",1,
3783,세제곱근,Gold I,"어떤 양의 정수가 주어졌을 때, 이 수의 세제곱근을 구하는 프로그램을 작성하시오.","첫째 줄에 테스트 케이스의 개수 T가 주어진다. 테스트 케이스는 한 줄로 구성되어 있다. 세제곱근을 구하고자 하는 수가 한 줄에 하나씩 입력으로 주어지며, 이 수는 150자리 이하이다. 수는 0으로 시작할 수도 있다.","각 테스트 케이스에 대해서, 입력으로 주어진 수의 세제곱근을 소수점 10째짜리까지 출력한다. 이때, 반올림을 하는 것이 아니고, 버림을 해야 한다.","5
1
8
1000
2
33076161","1.0000000000
2.0000000000
10.0000000000
1.2599210498
321.0000000000",
23089,사탕나무,Platinum III,"안즈는 사탕나무를 생일선물로 받았다.


사탕나무는 \(N\)개의 사탕을 트리 형태로 이은 것을 말한다. 각 사탕은 길이가 1인 간선으로 연결되어있고, 임의의 두 사탕 사이의 최단 경로는 유일하다.


안즈는 이 사탕나무에서 기준이 되는 사탕을 하나 골라, 그 사탕과의 최단거리가 \(K\)이하인 모든 사탕을 다 먹어버리려고 한다!


그런데 안즈는 문득 기준으로 어떤 사탕을 골라야 사탕을 가장 많이 먹을 수 있을지 궁금해졌다.


하지만 그 순간 안즈는 매우 귀찮아졌기 때문에, 여러분에게 해결을 부탁했다.","첫째 줄에 \(N\)과 \(K\)가 주어진다.


이어서 \(N\)-1개의 줄에, 사탕나무의 간선을 이루는 두 사탕 번호 \(u\), \(v\)가 공백으로 구분되어 주어진다.


주어지는 입력은 트리임이 보장된다.",안즈가 먹을 수 있는 최대 사탕 개수를 출력한다.,"8 1
1 3
2 3
3 4
4 5
3 6
4 7
6 8",5,
14869,요리 강좌,Diamond IV,"여러분은 요리에 관심이 많아 요리 자격증을 취득하려고 한다. 요리 자격증을 취득하기 위해서는 총 M개의 강좌를 순서대로 한 번씩만 수강해야 한다. 이 요리 강좌는 N개의 학원에서 수강할 수 있는데, 학원마다 강좌별 수강비용은 다를 수 있다.


아래 표는 M = 5, N = 4인 경우, 학원별, 강좌별 수강비용의 예를 보여준다.








 


강좌1


강좌2


강좌3


강좌4


강좌5










학원1


1


2


1


3


8






학원2


1


2


3


7


2






학원3


1


8


8


1


2






학원4


10


1


1


8


8








여러분은 비용을 줄이기 위해 중간에 학원을 변경할 수 있는데, 학원을 변경할 때마다 T의 추가 비용이 든다. 단, 학원 변경은 다음 규칙을 지켜야 한다.




하나의 학원에서 연속으로 수강할 수 있는 강좌의 수는 최소 S개, 최대 E 개다. 단, 마지막 강좌를 수강하는 학원에서는 강좌 S개 이상을 연속해서 들을 필요가 없다.




S = 2이고 E = 3이라고 가정하자. 강좌1을 학원1에서 수강했다면, 강좌2는 무조건 학원1에서 수강해야 하고, 강좌 3은 학원1에서 수강할 수도 있고 다른 학원에서 수강할 수도 있다. 만약 강좌1부터 강좌3을 학원1에서 수강했다면, 강좌4는 무조건 다른 학원에서 수강해야 한다.

또한, S = 1이고 E = 2인 경우, 강좌1과 강좌2를 학원3에서 수강하고, 강좌3과 강좌4를 학원1에서 수강하고, 강좌5를 다시 학원3에서 수강하는 것도 가능하다.




학원마다 직전 강좌를 특정한 학원에서 수강한 학생은 받지 않는데, 이를 ‘불허용 학원’이라고 하자. 각 학원마다 불허용 학원은 하나씩 존재한다.




예를 들어, 아래 표의 학원1에 대한 정보는 학원2→학원1로 변경하는 것은 불가능하다는 것을 의미한다. 단, 학원2→학원4→학원1처럼 학원4 수강을 거쳐 변경하는 것은 가능하다.








 


불허용 학원










학원1


학원2






학원2


학원3






학원3


학원4






학원4


학원3








예를 들어, S = 2, E = 3, T = 2이고, 위 수강비용 표와 불허용 학원 표가 주어졌을 때, 강좌 순서대로 수강하는 학원의 번호가




예1) 1 → 1 → 1 → 1 → 3 인 경우, 규칙 (a)에 위배되어 수강이 가능하지 않다.


예2) 2 → 2 → 1 → 1 → 1 인 경우, 규칙 (b)에 위배되어 수강이 가능하지 않다.


예3) 3 → 3 → 1 → 1 → 3 인 경우는 가능한 수강 방법이고, 전체 비용은 1+8+T+1+3+T+2 = 19이다.


예4) 1 → 1 → 1 → 3 → 3 인 경우는 가능한 수강 방법이고, 전체 비용은 1+2+1+T+1+2 = 9이다.




강좌 비용, 강좌 선택에 필요한 규칙 정보가 주어졌을 때, 모든 강좌를 순서대로 수강하기 위해 필요한 최소 비용을 구하시오.","표준 입력으로 다음 정보가 주어진다. 첫 번째 줄에는 학원의 개수 N과 강좌 개수 M(3 ≤ N ≤ 3,000, 1 ≤ M ≤ 3,000, N × M ≤ 3,000,000), 학원 한 곳에서 연속 수강 가능한 최소 강좌 개수 S와 최대 강좌 개수 E(1 ≤ S ≤ E ≤ M), 그리고 학원 변경 비용 T(0 ≤ T ≤ 35,000)가 주어진다. 다음 N개의 줄에는 각 학원의 강좌별 수강비용이 주어진다. (수강비용은 1 이상 35,000 이하이다.) 처음 줄에는 학원1의 M개의 수강비용이 강좌 순서대로 공백을 사이에 두고 주어지고, 그 다음 줄부터 학원2, 학원3, ... , 학원N의 정보가 한 줄에 하나씩 순서대로 주어진다. 그 다음 N개의 줄에는 학원마다 불허용 학원 번호가 순서대로 주어진다.",표준 출력으로 최소 비용을 출력한다.,"4 5 2 3 2
1 2 1 3 8
1 2 3 7 2
1 8 8 1 2
10 1 1 8 8
2
3
4
3

---

4 5 1 1 0
1 2 1 3 8
1 2 3 7 2
1 8 8 1 2
10 1 1 8 8
2
3
4
3","9

---

9",
1945,직사각형,Gold II,"2차원 평면상에 N개의 직사각형이 있다. 직사각형의 각 변은 각 좌표축과 평행하다. 이들 직사각형은 다른 직사각형와 겹쳐지거나 일치할 수 있으며, 다른 것의 내부에 그려질 수도 있다. 직사각형의 각 꼭짓점은 자연수 좌표를 가진다.




위의 그림의 경우는 8개의 직사각형이 그려진 경우이다. 이제 이 2차원 평면에 원점 (0,0)을 지나는 직선을 하나 그릴 수 있다. 이 직선은 직사각형들과 교차할 수 있는데, 위의 그림의 경우 2, 5, 6, 7, 8번 직사각형들과 교차하게 된다. (단지 직사각형의 꼭짓점만을 스쳐 지나가더라도 교차하는 것으로 간주한다.)


가장 많은 직사각형과 교차하도록 원점을 지나는 직선을 그린다고 할 때, 최대 몇 개의 직사각형과 교차할 수 있는지를 구하는 프로그램을 작성하시오. 위의 그림의 경우 직선을 어떻게 그린다고 해도 6개 이상의 직사각형과는 교차하지 않으므로, 5개가 최대가 된다.","첫째 줄에 직사각형의 개수 N(1 ≤ N ≤ 10,000)이 주어진다. 둘째 줄부터 N개의 줄에는 직사각형의 왼쪽 아래 꼭짓점의 좌표 xbl, ybl과 오른쪽 위 꼭짓점의 좌표 xtr, ytr이 순서대로 빈칸 하나를 사이에 두고 주어진다. 입력되는 좌표는 1,000,000,000 이하의 자연수이고, xbl < xtr, ybl < ytr 을 만족한다.",첫째 줄에 최대로 교차할 수 있는 직사각형의 개수를 출력한다.,"8
1 8 7 11
18 10 20 12
17 1 19 7
12 2 16 3
16 7 19 9
8 4 12 11
7 4 9 6
10 5 11 6",5,
21757,나누기,Gold II,"$N$개의 정수 수열 $A_1, A_2, \dots , A_N$이 주어진다. 수열을 각각이 연속된 네 부분으로 나누려고 한다. 단, 각 부분은 최소 하나의 수를 포함해야 한다. 또, 각 부분의 합은 모두 같아야 한다. 즉, 어떤 $i, j, k$ ($1 \le i < j < k < N$)에 대해서 $[A_1, \dots, A_i], [A_{i+1}, \dots, A_j], [A_{j+1}, \dots, A_k], [A_{k+1}, \dots, A_N]$으로 나눈다.


예를 들어 주어진 수열이 $4, −1, 2, 1, −3, 1, 2, 2, 1, 3$이라고 하자. 이 수열을 아래와 같이 나누면 각 부분의 합이 달라서 허용되는 형태가 아니다.


$[4, −1, 2], [1, −3, 1, 2], [2, 1], [3]$


아래과 같이 나눈 경우 각 부분의 합이 모두 같다.


$[4, −1], [2, 1], [−3, 1, 2, 2, 1], [3]$


아래와 같이 나눈 경우들도 각 부분의 합이 모두 같다.


$[4, −1], [2, 1, −3, 1, 2], [2, 1], [3]$ 혹은 $[4, −1, 2, 1, −3], [1, 2], [2, 1], [3]$


수열을 입력 받아 위와 같이 나눌 수 있는 가능한 방법의 개수를 계산하는 프로그램을 작성하라.","첫 번째 줄에 수열의 길이 $N$이 주어진다.


두 번째 줄에 $N$개의 정수 $A_1, A_2, \dots , A_N$이 공백 하나씩을 사이로 두고 주어진다.","첫 번째 줄에 가능한 방법의 개수를 출력한다.


출력 값이 매우 클 수 있으므로 C, C++ 언어에서는 
long long
 형의 변수를, Java에서는 
long
 형의 변수를 사용해야 한다.","4
1 1 1 1

---

10
4 -1 2 1 -3 1 2 2 1 3","1

---

3",
1426,카드 넣기,Platinum IV,"세준이는 N장의 카드를 가지고 있다. 각각의 카드에는 정수가 쓰여 있고, 문자도 하나 쓰여져 있다. 그리고, 세준이는 카드를 넣을 수 있는 통을 하나 가지고 있다.


세준이는 카드를 아무렇게나 통에 넣고는 했는데, 어느 날 다솜이가 세준이의 카드 통에 정수를 써놓고 도망갔다.


세준이는 정말 화가 나서 정수를 지우고 싶었지만, 지우는 방법을 몰라서 새로운 규칙을 만들어서 카드를 통에 넣으려고 한다.


카드를 통에 넣는 방법은 다음과 같다. 일단 카드 한 장을 고른다. 그리고 카드에 쓰여져 있는 번호보다 작거나 같은 통에 카드를 넣는다.


이렇게 카드를 넣는 방법은 여러 가지가 존재한다. 하지만 세준이는 앞에서부터 차례대로 카드에 쓰여져 있는 문자를 문자열로 만들어서 그 문자열이 가장 사전 순으로 앞서는 문자열을 알고 싶어한다.


예를 들면, 카드가 세 장이 있다. (1, A), (2, B), (3, C)가 있다. 그리고 통에 쓰여져 있는 정수는 2 2 1 이다. 그럼 일단 첫 번째 통에 2번 카드를 넣고, 두 번째 통에 3번 카드를 넣고, 세 번째 통에 1번 카드를 넣으면, 문자열은 BCA가 돼서 규칙에 맞게 넣으면서 가장 사전순으로 빠른 문자열이 나온다.


세준이가 가지고 있는 카드와 통에 쓰여져 있는 정수가 주어졌을 때, 사전순으로 가장 빠른 문자열을 구하는 프로그램을 작성하시오.","첫째 줄에 세준이가 가지고 있는 카드의 개수 N이 주어진다. 이 값은 50보다 작거나 같은 자연수이다. 둘째 줄에는 세준이가 가지고 있는 카드의 정보가 한 줄에 하나씩 주어진다. 카드의 정보는 정수와 문자 하나가 공백을 사이에 두고 주어진다. 정수는 1,000보다 작거나 같은 자연수이고, 문자는 알파벳 대문자이다. 마지막 줄에는 통에 쓰여 있는 정수가 공백을 사이에 두고 주어진다. 이 값은 1,000보다 작거나 같다.",첫째 줄에 사전순으로 제일 빠른 문자열을 출력한다. 만약 규칙대로 통에 넣을 수 없으면 -1을 출력한다.,"3
1 A
2 B
3 C
2 2 1

---

5
1 B
2 B
3 B
4 A
5 A
1 1 1 1 5

---

2
1 A
1 A
2 2","BCA

---

ABBBA

---

-1",
14229,DNA 문자열,Gold II,"DNA란 A, C, G, T로만 이루어진 문자열을 의미한다.


영선이는 인간 유전자를 연구하기 위해 세계에서 가장 권위있는 생물학자 효빈이를 고용했다. 효빈이가 연구하는 DNA는 문자열 S이다. 효빈이는 S에 포함되어 있지 않은 가장 짧은 DNA 문자열을 찾으려고 한다.


예를 들어, S = ""AGGTCTA""인 경우 정답은 ""AC""나 ""CC""가 된다. 하지만, ""AG""는 S에 포함되어 있기 때문에 정답이 아니며, ""AAA""는 길이가 3이기 때문에 (2인 정답이 존재해서) 정답이 아니다.


S가 주어졌을 때, S에 포함되어 있지 않은 가장 짧은 DNA 문자열을 구하는 프로그램을 작성하시오.","첫째 줄에 S가 주어진다. S의 길이는 2,000을 넘지 않는 자연수이다.",S에 포함되어 있지 않은 가장 짧은 DNA 문자열을 아무거나 출력한다.,"AGGTCTA

---

AGACGACGGAGAACGA

---

A

---

AAGATACACCGGCTTCGTG","AC

---

T

---

C

---

CAT",
5032,탄산 음료,Bronze II,"준민이는 탄산 음료를 좋아한다. 탄산 음료를 사느라 돈을 다 써버렸기 때문에, 이제 준민이는 가진 돈이 없어 탄산 음료를 사먹을 수 없다.


준민이는 항상 법을 지키며 사는 사람이기 때문에, 아무리 탄산 음료가 먹고 싶어도 훔치지 않는다. 따라서, 법적으로 문제가 없는 방법으로 탄산 음료를 구매할 것이다.


마침 빈 병을 특정 개수만큼 가져가면, 새 병으로 바꾸어주는 이벤트가 진행중이다. 준민이는 길에서 빈 병을 열심히 찾은 뒤, 탄산 음료를 먹으려고 한다.


준민이가 현재 가지고 있는 빈 병의 수와 길에서 발견한 빈 병의 수, 새 병으로 바꾸는데 필요한 빈 병의 수가 주어졌을 때, 준민이가 탄산 음료를 몇 개 먹을 수 있는지 구하는 프로그램을 작성하시오.","첫째 줄에 준민이가 가지고 있는 빈 병의 수 e, 그날 발견한 빈 병의 수 f, 새 병으로 바꾸는데 필요한 빈 병의 개수 c가 주어진다. (e < 1000, f < 1000, 1 < c < 2000) e, f, c는 모두 음이 아닌 정수이다.",첫째 줄에 준민이가 탄산 음료를 몇 개나 먹을 수 있는지를 출력한다.,"9 0 3

---

5 5 2","4

---

9",
16464,가주아,Silver I,"평소 도박을 즐겨하는 병규는 방학을 맞아, 한국 최대의 카지노 코스모스랜드를 찾았다. 일확천금의 꿈에 부풀어 여러 게임에 참여했지만, 입장 한 시간 만에 재산의 절반을 탕진하고 말았다.


평소 블랙잭에 자신이 있었던 병규는, 마지막 희망으로 블랙잭 테이블에 앉았다. 코스모스랜드에서는 일반 블랙잭과는 조금 다른 방식의 블랙잭인 ""HY블랙잭"" 이라는 게임을 만들어서 진행 중이었다. 규칙은 다음과 같다.




딜러가 로또 기계에서 2 이상의 정수가 써진 공을 하나 뽑는다. 이때 나온 수가 K라면 딜러의 수는 K가 된다.


플레이어는 딜러의 수 K를 확인하고, 카드를 받아 그 합이 정확히 K가 되도록 하면 게임에서 승리하게 된다.


각 카드에는 정수가 쓰여 있다. 일반 트럼프카드와 달리 1 이상 K-1 이하의 정수가 한 번씩 쓰여 있고, 오름차순으로 정렬되어 있다. 플레이어는 연속된 몇 장의 카드만 골라서 받을 수 있다.


만약 연속된 카드의 합으로 딜러의 수 K를 만들 수 없을 경우, 플레이어가 패배한다.




예를 들어, 딜러가 뽑은 공의 수가 9라면, 병규는 연속된 카드 2,3,4의 합으로 9를 만들 수 있으므로 병규의 승리가 된다. 하지만 딜러가 뽑은 공의 수가 4라면, 연속된 카드의 합으로 4를 만들 수 없으므로 병규의 패배가 된다.


K가 주어졌을 때, 병규가 이길 수 있는지 없는지 알려주는 프로그램을 작성하여 병규를 도와주자!","첫 번째 줄에, 테스트케이스의 수 N (1 ≤ N ≤ 10
3
)이 주어진다. 그 다음 줄부터 N개의 줄에 테스트케이스가 한 줄에 하나씩 주어진다. 각 테스트케이스에는 딜러가 뽑은 공의 수 K (2 ≤ K ≤ 10
9
)가 주어진다.","각 경우마다 병규가 이길 수 있다면, ""Gazua""를, 병규가 이길 수 있는 방법이 없다면 ""GoHanGang""을 출력한다. (큰따옴표는 출력하지 않는다)","2
9
4","Gazua
GoHanGang",
14647,준오는 조류혐오야!!,Bronze I,"심술쟁이 해커 임준오(동탄 주민)는 새를 싫어한다. 특히 비둘기를 싫어한다.


준오는 수업시간에 옆자리 짝꿍과 빙고게임을 하기로 했다. 준오와 짝꿍은 각자 원하는 숫자를 n×m 격자의 빙고판에 적었다. 그러고는 서로의 빙고판을 교환했는데, 준오는 짝꿍의 빙고판을 확인하자마자 화가 치밀어 올랐다. 짝꿍의 빙고판에 9가 들어간 숫자들이 엄청 많아서 비둘기가 떠올랐기 때문이다. 그래서 준오는 짝꿍의 빙고판을 부숴버렸다.


하지만 준오의 폭동에는 특별한 룰이 있다. 바로 모든 행과 열을 통틀어서 9가 가장 많이 쓰여 있는 행 또는 열을 단 하나만 부수는 것이다!


빙고판을 부수는 순간 준오와 선생님의 눈이 마주쳤고, 선생님은 빙고판에 남아있는 9의 개수만큼 준오를 때리기로 했다. 준오는 몇 대를 맞아야 할까?","첫째 줄에 직사각형 빙고판의 크기를 뜻하는 n(1 ≤ n ≤ 500)과 m(1 ≤ m ≤ 500)이 주어진다. 다음 줄부터 n개의 줄에 걸쳐 각 줄마다 m개의 숫자들이 주어진다. 이는 크기가 n×m인 짝꿍의 빙고판의 상태를 나타내며, 빙고판에는 10,000 이하의 음이 아닌 정수가 적힌다.",준오가 몇 대 맞아야 하는지 출력한다.,"3 4
1 2 3 9
4 5 9 6
9 7 8 9

---

4 4
11 12 19 14
99 39 14 90
13 47 81 99
32 72 29 66","2

---

4","첫 번째 예제에서, 3행 또는 4열을 부수면 2개의 9가 남고 준오는 총 2대를 맞는다.


두 번째 예제에서, 2행을 부수면 19, 99, 29가 남고 준오는 총 4대를 맞는다."
19945,새로운 언어 CC,Bronze I,"C언어는 int형 변수를 32개의 bit를 이용하여 2의 보수 방식을 따라서 이진수의 형태로 저장한다.


즉, 정수 10은 0000 0000 0000 0000 0000 0000 0000 1010으로 저장된다.


하지만 세상을 뒤흔들 새로운 언어 CC는 메모리를 줄이기 위해 int형 변수를 저장할 때 앞에서부터 연속된 0은 저장하지 않는다. 즉, 정수 10은 1010으로 저장된다. 그 외에 저장하는 방법은 C언어와 같다.


정수 
n
을 CC에 저장하는데 필요한 bit의 개수를 출력하여라. 단, 
n
이 0일 때는 1개의 bit를 사용하여 0을 저장한다.","언어 CC에 저장할 
n
이 주어진다.","변수 
n
을 저장하는데 필요한 bit의 개수를 출력한다.",10,4,
5576,콘테스트,Bronze II,"최근 온라인에서의 프로그래밍 콘테스트가 열렸다. W 대학과 K 대학의 컴퓨터 클럽은 이전부터 라이벌 관계에있어,이 콘테스트를 이용하여 양자의 우열을 정하자라는 것이되었다.


이번이 두 대학에서 모두 10 명씩이 콘테스트에 참여했다. 긴 논의 끝에 참가한 10 명 중 득점이 높은 사람에서 3 명의 점수를 합산하여 대학의 득점으로하기로 했다.


W 대학 및 K 대학 참가자의 점수 데이터가 주어진다. 이때, 각각의 대학의 점수를 계산하는 프로그램을 작성하라.",입력은 20 행으로 구성된다. 1 번째 줄부터 10 번째 줄에는 W 대학의 각 참가자의 점수를 나타내는 정수가 11 번째 줄부터 20 번째 줄에는 K 대학의 각 참가자의 점수를 나타내는 정수가 적혀있다. 이 정수는 모두 0 이상 100 이하이다.,W 대학 점수와 K 대학의 점수를 순서대로 공백으로 구분하여 출력하라.,"23
23
20
15
15
14
13
9
7
6
25
19
17
17
16
13
12
11
9
5

---

17
25
23
25
79
29
1
61
59
100
44
74
94
57
13
54
82
0
42
45","66 61

---

240 250",
2055,삼각형 찾기,Platinum V,"삼각형이란 세 개의 변으로 이루어진 면적이 양수인 도형이다. 격자 삼각형이란 삼각형의 세 꼭짓점의 좌표가 정수로 표현되는 삼각형을 말한다. 격자의 범위가 N×M으로 주어질 때, 가능한 삼각형의 개수를 구하는 프로그램을 작성하시오. 예를 들어 N=1, M=2일 경우에는 다음과 같은 18개의 경우가 있다.","첫째 줄에 두 정수 N, M이 주어진다.",첫째 줄에 답을 출력한다.,1 2,18,
20540,연길이의 이상형,Bronze III,"졸업을 앞둔 연길이는 크리스마스가 다가올수록 외로움을 느낀다.


그런 연길이를 위해 동우는 소개팅을 시켜주지는 않고 연길이의 이상향을 찾는 것을 도와주고자 한다.


MBTI 신봉자인 연길이는 자신과 정반대인 사람에게 매력을 느낀다. 즉, MBTI의 네가지 지표가 모두 자신과 반대인 사람이 연길이의 이상형이다.


MBTI는 다음과 같은 네 가지 척도로 성격을 표시한다. 각각의 척도는 두 가지 극이 되는 성격으로 이루어져 있다.








지표


설명






외향(
E
xtroversion)


내향(
I
ntroversion)


선호하는 세계:세상과 타인 / 내면 세계






감각(
S
ensation)


직관(i
N
tuition)


인식형태: 실제적인 인식/ 실제 너머로 인식






사고(
T
hinking)


감정(
F
eeling)


판단기준: 사실과 진실 위주 / 관계와 사람 위주






판단(
J
udging)


인식(
P
erceiving)


생활양식: 계획적인 생활 / 즉흥적인 생활








네 가지 척도마다 두 가지 경우가 존재하므로, 총 16가지의 유형이 만들어진다. 유형은 각 경우를 나타내는 알파벳 한 글자씩을 따서 네 글자로 표시한다. 다음은 MBTI의 유형들이다.








구분


감각/사고


감각/감정


직관/감정


직관/사고






내향/판단


ISTJ


ISFJ


INFJ


INTJ






내향/인식


ISTP


ISFP


INFP


INTP






외향/인식


ESTP


ESFP


ENFP


ENTP






외향/판단


ESTJ


ESFJ


ENFJ


ENTJ








연길이가 자신의 이상향을 무사히 찾을 수 있도록 도와주자!",연길이의 MBTI 4글자가 대문자로 주어진다.,연길이의 이상형에 해당하는 MBTI 4글자를  대문자로 출력한다.,"ESTJ

---

INFP","INFP

---

ESTJ",MBTI는  Myers-Briggs Type Indicator의 줄임말이다.
3024,마라톤 틱택토,Silver III,"상근(Albert), 민혁(Barbara), 선영(Casper), 창영(Dinko), 현진(Eustahije)이가 마라톤 틱택토 게임을 하려고 한다. 이 게임은 N×N 보드에서 진행한다.


맨 처음에 보드의 모든 칸은 비어있다. 플레이어는 턴을 번갈아가면서 자신의 영어 이름의 첫 글자를 빈 칸에 적는다. (두 사람의 영어 이름의 첫 글자가 같은 경우는 없다)


게임은 세 글자가 행, 열, 또는 대각선으로 연속할 때, 그 플레이어가 승리하며, 게임이 끝나게 된다.


보드판의 상태가 주어졌을 때, 게임이 끝났는지 아닌지를 결정하고, 끝났다면 승자가 누구인지 구하는 프로그램을 작성하시오.","첫째 줄에 보드판의 크기 N이 주어진다. (1 ≤ N ≤ 30)


다음 N개 줄에는 보드판의 상태가 주어진다. '.'는 빈 칸을 나타낸다.


항상 승리한 사람이 많아야 한 명인 경우만 입력으로 주어진다.","첫째 줄에 게임이 끝났다면, 승리한 사람의 영어 이름의 첫 글자를 출력한다. 그렇지 않다면, ""ongoing""을 출력한다. 게임을 승리한 사람이 없는데, 빈 칸이 없는 경우에도 ongoing을 출력해야 한다.","3
XOC
XOC
X..

---

4
....
..A.
AAB.
.B.B

---

3
ABB
AAA
BBA","X

---

ongoing

---

A",
5004,파워 블로거,Ruby V,"선영이는 블로그에 음식점 리뷰를 올리는 파워 블로거이다. 음식점 리뷰를 몇 년동안 하루에 몇 개씩 하다보니, 이제 지구에 있는 모든 음식점의 리뷰를 작성했다.


이제, 기내식 리뷰를 작성할 차례이다. 선영이는 사람들이 자신의 기내식 리뷰를 보고 항공편을 고르는 효과를 기대하고 있다.


이번 기내식 리뷰는 코스모폴리탄 다음 호에도 올라갈 예정이다. 코스모폴리탄의 편집장인 상근이는 선영이에게 기내식 리뷰를 해야하는 항공편 리스트를 주었다. 선영이는 출발과 도착 도시가 같은 각 항공편은 같은 기내식을 제공한다는 사실을 알고 있다. 따라서, 한 번만 타면 된다.


상근이가 준 리스트에 있는 항공편만 이용해서는 모든 리뷰를 할 수 없다. 따라서, 선영이는 비행기를 조금 더 예매하려고 한다. 이렇게 예매를 한 비행기의 기내식은 리뷰를 하지 않고, 리스트에 있는 기내식만 리뷰를 한다.


선영이는 모든 리뷰를 작성하면서 드는 비행기 티켓에 쓰는 돈을 최소로 하려고 한다. 선영이의 사무실은 스톡홀롬에 있고, 이 곳에서 여행이 시작되고 끝이 난다. 두 도시를 운항하는 비행기 티켓의 가격은 고정되어 있으며, 양방향 모두 같다. 항상 모든 리뷰를 완료하는 것이 가능하다.


선영이가 이용하는 호텔의 비용, 비행기의 출발과 도착 시간은 무시할 수 있고, 비행기는 매우 자주 운항하며 비행 시간은 매우 작다고 가정한다. 따라서, 비행기 티켓의 가격만 생각하고 문제를 풀면 된다.","첫째 줄에 N과 R이 주어진다. N은 공항의 수, R은 리뷰를 작성해야 하는 항공편의 수이다. 공항은 1부터 N까지 번호가 매겨져 있고, 스톡홀롬의 번호는 1이다. (2 ≤ N ≤ 13, 0 ≤ R ≤ 78)


다음 R개 줄에는 리뷰를 작성해야 하는 항공편의 정보이다. 각 줄은 3개의 정수 a, b, c로 이루어져 있으며, a와 b는 서로 다른 두 공항을, c는 비행기 티켓 가격이다. (1 ≤ a, b ≤ N, 1 ≤ c ≤ 10,000) 두 도시를 운항하는 비행기의 수는 한 개를 넘지 않는다.


다음 줄에는 선영이가 추가적으로 이용할 수 있는 항공편의 수 F가 주어진다. (0 ≤ F ≤ 200) 다음 F개 줄에는 위와 같은 형식으로 정보가 주어진다. 두 도시를 운항하는 비행기의 수가 여러 개일 수도 있다.


항상 리뷰를 모두 작성할 수 있는 경우만 입력으로 주어진다.",선영이가 모든 리뷰를 작성하고 스톡홀롬으로 돌아오는데 드는 비행기 티켓의 값의 최솟값을 출력한다.,"5 3
1 2 1000
2 3 1000
4 5 500
2
1 4 300
3 5 300

---

6 5
1 2 1000
2 3 1000
1 3 1000
2 4 1000
5 6 500
2
2 5 300
4 6 300","3100

---

5100",
21874,모자 게임,Gold II,"CS-House에서는 매주 목요일에 연세대학교 컴퓨터과학과에 대한 여러 이야기를 팟캐스트 형식으로 다룬다. 2021년 3월 18일에 진행한 CS-House에서는 ICPC World Final에 진출한 윤인섭 선배가 게스트로 나와서 알고리즘 및 Competitive Programming에 대해서 이야기를 했다. 이야기 도중에 시청자들과 함께 재미있는 문제들을 풀어보는 시간을 가졌는데, 그 문제 중 하나를 변형해서 연세대학교 신입생 프로그래밍 경진대회에 내기로 했다. 다음과 같은 문제를 생각해보자.




그림과 같이 $N$명의 사람이 앞을 보고 일렬로 서있다. 각 사람은 맨 뒷사람을 제외하고 $0$ 이상 $63$ 이하의 정수가 적힌 모자를 쓰고 있다.




각 사람은 자신보다 앞에 있는 사람의 모자에 적힌 수를 모두 볼 수 있지만, 자신을 포함해서 뒤에 있는 사람의 모자에 적힌 수는 볼 수 없다.






게임이 시작되면 맨 뒷 사람부터 순서대로 $0$ 이상 $63$ 이하의 정수 중 하나를 말한다.


게임을 시작하기 전 $N$명의 사람들이 모여 작전을 세우려고 한다. 자신이 말한 수와 자신의 모자에 적힌 수가 동일한 사람이 최대한 많아지도록 작전을 세워보자.




구현




이 문제를 풀기 위해서는 hat.cpp 파일을 제출해야 한다. hat.cpp 파일에 포함되어야 하는 함수는 다음과 같다..



void init(int N);




프로그램이 실행된 직후, 한 번만 호출된다. 
N
은 일렬로 서있는 사람의 수를 의미한다.





int call(vector<int> F, vector<int> B, int num);




앞에서부터 
(num+1)
번째에 서있는 사람이 말해야 하는 수를 
return
한다. 
num
은 $0$ 이상 $N-1$ 이하의 정수다.


F
는 앞에 있는 사람들이 쓴 모자의 수를 저장한 길이 $N$의 정수 배열이다. 
F[i]
에는 
i+1
번째 사람이 쓴 모자의 수가 저장되어 있다. 만약 
num+1
번째 사람이 
i+1
번째 사람이 쓴 모자의 수를 볼 수 없다면 해당 배열 값은 $0$이다.


B
는 뒤에 있는 사람들이 말한 수를 저장한 길이 $N$의 정수 배열이다. 
B[i]
에는 
i+1
번째 사람이 말한 수가 저장되어 있다. 만약 
num+1
번째 사람이 말하기 전에 
i+1
번째 사람이 말하는 차례가 오지 않았다면 해당 배열 값은 $0$이다.


각 게임마다 
call
은 총 $N$번 호출된다. 
call
이 호출될 때 마다 
num
에는 $N-1$부터 $0$까지 수가 순서대로 들어간다.




총 $T$번의 모자 게임이 동시에 진행되며, 각 게임별로 $N-1$명이 자신이 쓴 모자에 적힌 수와 동일한 수를 말해야 
맞았습니다!!
를 받을 수 있다. Grader가 실행 도중 
틀렸습니다
라고 판정한 경우, 그 즉시 프로그램이 종료된다.",,,,,
18291,비요뜨의 징검다리 건너기,Gold V,"비요뜨는 지금 강 앞에 서 있다. 강 위에는 징검다리가 놓여 있다.


징검다리는 비요뜨가 있는 방향에서부터 반대 방향까지 차례로 1번, 2번, ..., 
N
번의 번호를 가지고 있다.


비요뜨는 1번 징검다리 위에 올라갔다. 그리고 아래 두 가지 규칙을 지키며 징검다리를 건너려고 한다.




1 ≤ 
X
 ≤ 
N
 인 임의의 정수 
X
에 대해, 현재 있는 징검다리의 번호를 
i
번이라고 할 때 
i+X
번 징검다리로 뛸 수 있다.


N
번째 징검다리를 지나쳐선 안 되고, 정확히 도착해야 한다




비요뜨는 자신의 특기인 코딩을 살리기 위해 노트북을 켰지만, 실수로 노트북을 강에 빠뜨리고 말았다.


비요뜨를 대신해 강을 건너는 경우의 수를 구해 주자!","첫 번째 줄에 테스트 케이스의 수 
T
가 주어진다. (1 ≤ 
T
 ≤ 1000)


각 테스트 케이스는 한 줄로 구성되며, 징검다리의 개수를 의미하는 
N
이 주어진다. (1 ≤ 
N
 ≤ 10
9
)","각 테스트 케이스에 대해, 한 줄에 하나씩 규칙을 만족하면서 징검다리를 건너는 경우의 수를 10
9
+7로 나눈 나머지를 출력한다.","1
4",4,
16505,별,Silver II,출력 예제를 보고 별 찍는 규칙을 유추하여 별을 찍어 보자.,"첫 번째 줄에는 정수 
N 
(0 ≤ 
N
 ≤ 10)이 주어진다.","별 찍는 규칙에 따라 별을 출력한다.


각 줄 끝에는 필요없는 공백을 출력하지 않는다.","0

---

1

---

2

---

3

---

4","*

---

**
*

---

****
* *
**
*

---

********
* * * *
**  **
*   *
****
* *
**
*

---

****************
* * * * * * * *
**  **  **  **
*   *   *   *
****    ****
* *     * *
**      **
*       *
********
* * * *
**  **
*   *
****
* *
**
*",
10840,구간 성분,Gold I,"매 초마다 신호를 발생시키는 두 장치 A, B가 있다. 이 신호는 알파벳 소문자의 서열로 표현된다. A, B로부터 발생한 신호를 서열로 표시한 S
A
, S
B
의 예는 다음과 같다.




S
A
 = [a, f, c, d, r, d, e, s, d, c, f, w, s, z, r]


S
B
 = [g, e, d, s, r, d, d, e, m, z, r]




신호 서열의 어떤 구간에 포함된 문자의 종류와 개수가 순서에 상관없이 동일하면 이 두 ‘구간의 성분’은 같다고 한다. 아래에서 박스로 표시된 부분은 두 신호 S
A
, S
B
에서 성분이 같은 구간을 나타내고 있다.




즉 위의 예와 같이 성분이 같은 구간의 길이는 두 서열에서 반드시 같아야 한다. 그리고 같은 성분 의 구간은 하나 이상 존재할 수 있다. 우리는 두 신호 서열에 각각 존재하는 같은 성분 구간 중에 서 가장 긴 것을 찾으려고 한다.","첫 두 줄에 신호 서열이 공백 없는 하나의 문자열로 각각 주어진다. 이 문자열은 영문 소문자로만 구성되어 있다. 두 입력 문자열의 크기 N, M의 범위는 1 ≤ N, M ≤ 1,500 이다.","두 서열에서 같은 성분을 가진 구간 중에서 가장 긴 구간을 찾아, 그 구간의 길이를 출력해야 한다.","xraphy
edgeedgem

---

afcdrdesdefwszr
gedsrddemzr

---

computersystem
sesystuercomplexity","0

---

7

---

11",
17367,공교육 도박,Platinum V,"공교육의 수호자 수찬이는 공교육의 정수라고 할 수 있는 한국정보올림피아드의 문제를 가지고 게임을 하려고 한다. 수찬이는 2010년도 한국정보올림피아드 시·도 지역본선 중등부 1번 문제를 보고 영감을 받아 새로운 게임을 만들었다. 기존 게임은 1에서부터 6까지의 눈을 가진 3개의 주사위를 던져서 다음과 같은 규칙에 따라 상금을 받는 게임이다.




같은 눈이 3개가 나오면 10,000원+(같은 눈)*1,000원의 상금을 받게 된다.


같은 눈이 2개만 나오는 경우에는 1,000원+(같은 눈)*100원의 상금을 받게 된다.


모두 다른 눈이 나오는 경우에는 (그 중 가장 큰 눈)*100원의 상금을 받게 된다.




예를 들어, 3개의 눈 3, 3, 6이 주어지면 상금은 1,000+3*100으로 계산되어 1,300원을 받게 된다. 또 3개의 눈이 2, 2, 2로 주어지면 10,000+2*1,000 으로 계산되어 12,000원을 받게 된다. 3개의 눈이 6, 2, 5로 주어지면 그중 가장 큰 값이 6이므로 6*100으로 계산되어 600원을 상금으로 받게 된다.


수찬이가 만든 새로운 게임의 룰은 다음과 같다.




게임이 시작되면 플레이어는 주사위를 여러 번 던진다.


주사위를 던지다가 던진 눈의 값이 마음에 들면 언제든지 게임을 끝낼 수 있다. 그렇지 않다면 주사위를 한 번 더 던질 수 있다.


주사위는 최소 세 번 던져야 하며 최대 
N
번까지 던질 수 있다.


게임이 끝날 때 플레이어가 받는 상금은 가장 최근에 던진 주사위 세 번의 값을 가지고 기존 규칙에 따라 계산한다.




만약 수찬이가 주사위를 여섯 번 던져서 6, 6, 6, 5, 1, 5가 나왔다면 상금은 1,000+5*100으로 계산되어 1,500원을 받게 된다.


수찬이는 받을 수 있는 상금의 기댓값이 최대가 되도록 게임을 플레이한다. 
N
이 주어질 때 수찬이가 받는 상금의 기댓값을 구하는 프로그램을 작성하여라.","첫 번째 줄에 주사위를 던질 수 있는 최대 횟수 
N
 (3 ≤ 
N
 ≤ 1,000)가 주어진다.","첫 번째 줄에 최선의 전략을 사용했을 때 수찬이가 얻을 수 있는 상금의 기댓값을 출력한다.


실제 정답과 절대/상대 오차가 10
-6
 이하이면 정답으로 간주한다.","3

---

10","1229.166666666667

---

3300.645281421468",
10432,데이터 스트림의 섬,Silver IV,"n개의 정수 수열 a1, a2, a3, ..., an에 대해, 섬이란 다음 조건을 만족하는 연속된 부분수열을 말한다.




섬의 모든 수는 부분수열이 시작하기 직전 수보다 크다.


섬의 모든 수는 부분수열이 끝난 직후의 수보다 크다.




아래의 예시에는 각각의 예제 수열에 대한 모든 섬이 표시되어 있다.




이 문제에서 수열은 항상 12개의 음이 아닌 정수로 이루어져 있다.


이때, 총 섬의 개수를 출력하라.","첫 줄에 테스트 케이스의 수 P가 주어진다. (1 ≤ P ≤ 1000)


각 테스트 케이스는 테스트 케이스의 번호 T와 12개의 음이 아닌 정수로 이루어져 있다. 또한, 12개의 정수 중 첫 수와 마지막 수는 항상 0이다.",각 테스트 케이스마다 테스트 케이스의 번호와 섬의 수를 공백으로 구분하여 출력한다.,"4
1 0 0 1 1 2 2 1 1 0 1 2 0
2 0 1 2 4 3 1 3 4 5 2 1 0
3 0 1 2 4 4 1 0 2 4 1 0 0
4 0 1 2 3 4 5 6 7 8 9 10 0","1 4
2 8
3 6
4 10",
23023,소수 카드 게임,Platinum II,"Albert는 친구들과 소수 (prime) 카드 게임을 하기로 했다. 총 m명의 플레이어가 있고, 양의 정수가 하나씩 적혀있는 n장의 카드가 있다. 편의상 카드에 적힌 수를 v[1], v[2], ..., v[n]이라 하자.


먼저 플레이어들에게 카드를 나눠준 후, 각자 점수를 계산하여 승자를 가린다.


n장의 카드는 아래 규칙에 따라 m명의 플레이어에게 나누어져야 한다:




각 카드는 반드시 한 명의 플레이어에게 주어진다.


각 플레이어는 최소 한 장의 카드를 받는다.




n장의 카드를 모두 분배한 후 아래 규칙에 따라 각자 점수를 계산한다:




먼저, 자신이 받은 카드에 적힌 수를 모두 더한다. 이를 S라 하자.


S에 가장 가까우면서 S가 아닌 소수(prime number)를 P라 하자 (그런 소수가 여럿인 경우 아무 것 하나를 P라 한다).


해당 플레이어의 점수는 | S - P | 이다 ('|'는 절대값 기호이다).




예를 들어 n = m = 3이고 카드에 적힌 수가 [1, 2, 3]이라 하자. 이 때, 각 플레이어는 정확히 한 장씩 카드를 받는다.




1이 적힌 카드를 받은 플레이어의 점수는 1이다 (1에 가장 가까운 소수는 2이다).


2가 적힌 카드를 받은 플레이어의 점수는 1이다 (2에 가장 가까운 (2가 아닌) 소수는 3이다).


3이 적힌 카드를 받은 플레이어의 점수느 1이다 (3에 가장 가까운 소수는 2이다).


이 예제에서는 모든 플레이어의 점수가 1로 동일하다 (모두가 공동 승자이다).




다른 예로, n = 3, m = 2이고 카드에 적힌 수가 [23, 29, 41]이라 하자. 이 때, 한 플레이어는 카드 한 장을 받고 다른 플레이어는 두 장을 받게 된다. 아래와 같은 세 가지 방법으로 카드를 분배할 수 있다.




방법 1: [23] 과 [29, 41]로 분배하는 경우, 23에 가장 가까운 소수는 19이고 (29+41)에 가장 가까운 소수는 71이다. 따라서 두 플레이어의 점수는 각각 4와 1이다.


방법 2: [29] 과 [23, 41]로 분배하는 경우, 29에 가장 가까운 소수는 31이고 (23+41)에 가장 가까운 소수는 67이다. 따라서 두 플레이어의 점수는 2로 같다.


방법 3: [41] 과 [23, 29]로 분배하는 경우, 41에 가장 가까운 소수는 43이고 (23+29)에 가장 가까운 소수는 53이다. 따라서 두 플레이어의 점수는 각각 2와 1이다.




Albert는 게임의 흥미를 위해 승자의 점수가 최소가 되도록 카드를 나눠주고 싶다. 위에 언급한 두 번째 예제의 경우 방법 1은 승자의 점수가 4이고 방법 2와 3은 승자의 점수가 2가 되므로 정답은 2가 된다. Albert가 달성 할 수 있는 승자의 점수 최소값을 구해보자. 


소수 (prime number): 양의 정수 P가 1보다 크고 P의 약수가 1과 P뿐이면 소수이다.","첫 줄에 테스트 케이스의 수 T가 주어진다.


각 테스트 케이스는 두 줄에 걸쳐 주어진다.


첫 줄에 n과 m이 공백으로 구분되어 주어진다.


둘째 줄에 n개의 정수가 (v[1], ..., v[n]) 공백으로 구분되어 주어진다.",각 테스트 케이스의 정답을 각 줄에 출력한다.,"6
3 3
1 2 3
3 3
23 29 41
3 2
23 29 41
4 4
23 29 31 37
5 2
10 20 30 40 50
5 3
10 20 30 40 50","1
4
2
4
1
1",
18800,도로 공사,Diamond III,"SciOI시의 시장인 상렬이는 새로운 도로를 건설하려고 한다. 하지만 상렬이가 도로를 지으려는 땅은 너무 울퉁불퉁해, 땅을 다지는 작업만 해도 몇 년이 걸릴 것으로 예상된다. 상렬이가 도로를 지으려는 땅은 직선 형태이며, 높이가 서로 같거나 다른 N개의 조각으로 나뉘어져 있다. 도로의 높이는 음수일 수도 있다. 도로의 상태는 각 도로 조각의 높이를 나타내는 길이가 N인 수열 A로 표현된다.


다행히도 마법사인 상렬이는 연속한 K개 조각의 높이를 일정한 높이만큼 높이거나 낮추는 마법을 사용할 수 있다. 이때 K는 고정되어 있음에 주의하라.


예를 들어 N = 5이고 K = 2이며 도로의 상태가 다음과 같다고 하자.


3 5 6 2 9


상렬이가 세 번째와 네 번째 조각에 높이를 2 높이는 마법을 사용하면 도로의 상태는 다음과 같이 변한다.


3 5 8 4 9


또한 상렬이의 마법은 도로의 경계를 벗어나서도 사용할 수 있으며 도로의 범위를 넘어간 마법은 무시된다. 예를 들어, K = 3 일때 도로의 경계를 벗어나 0번째, 첫 번째, 두 번째 조각에 마법을 사용하는 것이 가능하며 이 때 0번째 조각에 사용한 마법은 무시되어 첫 번째와 두 번째 조각에만 마법을 사용하는 것이 된다.


상렬이는 도로를 정확히 어디에 지을지 아직 결정하지 못했지만 주어진 도로의 어떤 연속된 구간에 도로를 지을 것임은 확실하다. 상렬이는 어떤 구간에 도로를 짓게 된다면, 마법을 사용하여 그 구간에 속한 도로 조각들의 높이를 모두 같게 만들어야 한다. 그러나 마법을 너무 많이 사용하면 자신이 마법사라는 사실을 주변에 들킬 수 있기 때문에 상렬이는 최소한의 횟수로 마법을 사용하고자 한다.


상렬이가 생각하고 있는 도로를 건설할 구간의 후보는 총 Q개이다. 각각의 후보에 대해 상렬이가 최소로 사용해야 하는 마법의 수를 구하는 프로그램을 작성하여라. 모든 쿼리는 
독립적
이다.","첫 줄에는 N, K, 그리고 도로를 건설할 구간의 후보 수 Q가 주어진다. (1 ≤ K ≤ N ≤ 100,000​​​​, 1 ≤ Q ≤ 100,000)


둘째 줄에는 도로의 상태를 나타내는 길이 N의 수열 A가 주어진다. (-10
9
​ ≤ A
i
 ≤ 10
9
)


셋째 줄부터 Q개의 줄에는 도로를 건설할 구간의 후보가 각각 주어진다. i번째 후보는 두 정수 l
i
, r
i
로 표현되며, 이는 i번째 후보는 도로의 l
i
번째 조각부터 r
i
번째 조각까지로 이루어진 구간임을 의미한다. (1 ≤ l
i
 ≤ r
i
 ≤ N)","Q개의 줄에, 각 도로 구간의 후보에서 상렬이가 최소로 사용해야 하는 마법의 수를 출력한다. 만약 마법으로 도로 조각들의 높이를 원하는 대로 만들 수 없다면, -1을 출력한다.","5 2 3
1 3 3 2 2
1 2
2 5
1 4","1
1
2",
22900,나의 라임 오렌지 나무,Platinum II,"제제가 아끼는 라임 오렌지 나무인 밍기뉴는 정점의 개수가 $N$, 간선의 개수가 $N-1$인 연결 그래프이다. 밍기뉴의 $i$번 간선에는 $a_i$개의 라임 오렌지가 달려 있다. 제제와 포르투가는 밍기뉴 위에서 게임을 하려고 한다. 첫 번째 턴에는 제제가 밍기뉴의 뿌리인 $r$에 말을 놓고, 각 턴마다 두 사람은 다음 과정을 반복한다.




말이 놓인 정점과 인접한 간선을 아무거나 선택한다.


선택한 간선에 있는 라임 오렌지를 1개 이상 딴다.


말을 선택한 간선의 반대편 정점으로 이동한다.




더 이상 턴을 진행할 수 없을 때, 즉 말이 놓인 정점과 인접한 어느 간선에도 딸 라임 오렌지가 없을 때 그 턴의 플레이어는 게임에서 패배한다. $r = 1, 2, \cdots, N$일 때, 제제가 이긴다면 ""Zeze"", 포르투가가 이긴다면 ""Portuga""를 따옴표 없이 출력하는 프로그램을 작성하자.","첫 번째 줄에는 밍기뉴의 정점의 개수 $N$이 주어진다.


두 번째 줄부터 $N$번째 줄까지 $N-1$개의 줄에 간선과 그 간선에 달린 라임 오렌지의 개수가 $x_i \ y_i \ a_i$의 형태로 주어진다.","$r = 1, 2, \cdots, N$일 때 제제가 이긴다면 ""Zeze"", 포르투가가 이긴다면 ""Portuga""를 따옴표 없이 각각 $N$ 개의 줄에 걸쳐 출력한다.","3
3 1 1
1 2 1

---

20
19 2 837009437
19 3 555623333
9 6 932422073
7 11 384958865
5 7 279037157
19 5 301909012
9 14 577327858
10 15 372601829
10 16 965167094
13 10 840904695
1 13 927245827
4 1 133242826
12 4 276397978
19 12 736742142
8 17 642702689
9 8 70136361
9 18 971340052
19 9 307149033
19 20 523797433","Zeze
Portuga
Portuga

---

Zeze
Portuga
Portuga
Zeze
Portuga
Portuga
Zeze
Zeze
Zeze
Zeze
Portuga
Zeze
Zeze
Portuga
Portuga
Portuga
Zeze
Portuga
Zeze
Portuga",
2734,드럼통 쌓기,Gold III,"드럼통을 직사각형 쓰레기통에 예쁘게 쌓아보려고 한다. 아랫줄을 제외한 모든 실린더는 항상 자기 바로 아랫줄의 실린더 2개와 닿아있다. 가장 밑 줄의 실린더는 쓰레기통 벽에 닿아있기 때문에, 더이상 굴러가지 않는다. 마지막줄을 제외한 모든 줄은 자기 아랫줄의 드럼통 개수보다 하나 적은 드럼통이 있다.


드럼통의 반지름은 항상 1이다.




가장 위에 있는 실린더의 중심 좌표를 구하는 프로그램을 작성하시오. 값을 계산할 때, double을 사용하면 된다.","첫째 줄에 테스트 케이스의 개수 T(T<=1,000)가 주어진다. 각 테스트 케이스는 한 줄로 구성되어 있다. 첫 번째 숫자는 드럼통의 개수 N이 주어진다. 이어서 들어오는 N개의 숫자는 각 드럼통의 중심 x좌표이다. (드럼통의 바닥과 접하므로 y좌표는 항상 1이다). N은 1보다 크거나 같고, 10보다 작거나 같다. 


인접한 두 드럼통의 중심거리는 적어도 2.0이고, 많아야 3.4이다. (2.0인 이유는 드럼통이 겹치지 않기 위해서, 3.4인 이유는 k줄에 있는 드럼통과 k-2줄에 있는 드럼통이 서로 접하지 않게 하기 위해서)",각 테스트 케이스에 대해 한 줄에 하나씩 가장 위에 있는 드럼통의 중심좌표를 공백으로 구분하여 x좌표와 y좌표 순서대로 소수점 4자리까지 출력한다.,"5
4 1.0 4.4 7.8 11.2
1 1.0
6 1.0 3.0 5.0 7.0 9.0 11.0
10 1.0 3.0 5.0 7.0 9.0 11.0 13.0 15.0 17.0 20.4
5 1.0 4.4 7.8 11.2 14.6","6.1000 4.1607
1.0000 1.0000
6.0000 9.6603
10.7000 15.9100
7.8000 5.2143",
2373,Fibonacci Game,Platinum I,"당신은 N(2 ≤ N ≤ 1,000,000)개의 구슬을 가지고 다음과 같은 게임을 하려고 한다. 게임은 두 사람이 번갈아 가면서 진행하며, 1번 사람이 몇 개의 구슬을 가져가는 것으로 게임이 시작된다. 1번 사람이 처음에 구슬을 가져갈 때는 몇 개라도 가져갈 수 있지만 N개의 구슬을 다 가져가서는 안 된다. 그 후에 구슬을 가져갈 때는, 상대편이 바로 전에 가져간 개수의 2배 이하를 가져갈 수 있다. 즉, 상대편이 1개를 가져갔다면, 당신은 1개, 또는 2개를 가져갈 수 있는 것이다. 이런 식으로 게임을 진행하여, 마지막으로 구슬을 가져간 사람이 이기게 된다.


예를 들어, N = 3인 경우를 보자. 1번 사람이 몇 개를 가져가도 2번 사람이 남아있는 구슬을 다 가져갈 수 있다. 반면에 N=4인 경우에는, 1번 사람이 1개를 가져가면 이기게 된다.


1번 사람의 입장이 되어, 처음에 몇 개의 구슬을 가져갈 것인지를 결정하는 프로그램을 작성하시오. 만약 가능한 경우가 여러 가지 존재한다면, 더 적은 수의 구슬을 가져가는 것으로 한다. 만약 몇 개를 가져가도 지게 된다면, -1을 출력한다.",첫째 줄에 정수 N이 주어진다.,"가져갈 구슬의 개수, 또는 -1을 출력한다.",100,3,
11056,두 부분 문자열,Gold V,"두 문자열 A와 B가 주어진다. 이때, A와 B를 부분 문자열로 가지는 문자열 S를 구하는 프로그램을 작성하시오. 가능한 S가 여러 가지인 경우 길이가 가장 짧은 것을 출력한다.


예를 들어, A = ""baekjoon"", B = ""hongjun""인 경우 가능한 S중 길이가 가장 짧은 것 중 하나는 ""baekhongjouon""이다.","첫째 줄에 문자열 A, 둘째 줄에 문자열 B가 주어진다. 두 문자열은 알파벳 소문자로만 이루어져 있고, 길이는 1,000 이하이다.",첫째 줄에 A와 B를 부분 문자열로 가지는 가장 짧은 S의 길이를 출력한다.,"baekjoon
hongjun",13,
1837,암호제작,Bronze III,"원룡이는 한 컴퓨터 보안 회사에서 일을 하고 있다. 그러던 도중, 원룡이는 YESWOA.COM 으로부터 홈페이지 유저들의 비밀키를 만들라는 지시를 받았다. 원룡이는 비밀 키를 다음과 같은 방법으로 만들었다.


개인마다 어떤 특정한 소수 p와 q를 주어 두 소수의 곱 pq를 비밀 키로 두었다. 이렇게 해 주면 두 소수 p,q를 알지 못하는 이상, 비밀 키를 알 수 없다는 장점을 가지고 있다.


하지만 원룡이는 한 가지 사실을 잊고 말았다. 최근 컴퓨터 기술이 발달함에 따라, 소수가 작은 경우에는 컴퓨터로 모든 경우의 수를 돌려보아 비밀 키를 쉽게 알 수 있다는 것이다.


원룡이는 주성조교님께 비밀 키를 제출하려던 바로 직전에 이 사실을 알아냈다. 그래서 두 소수 p, q 중 하나라도 K보다 작은 암호는 좋지 않은 암호로 간주하여 제출하지 않기로 하였다. 이것을 손으로 직접 구해보는 일은 매우 힘들 것이다. 당신은 원룡이를 도와 두 소수의 곱으로 이루어진 암호와 K가 주어져 있을 때, 그 암호가 좋은 암호인지 좋지 않은 암호인지 구하는 프로그램을 작성하여야 한다.","암호 P(4 ≤ P ≤ 10
100
)와 K (2 ≤ K ≤ 10
6
) 이 주어진다.","만약에 그 암호가 좋은 암호이면 첫째 줄에 GOOD을 출력하고, 만약에 좋지 않은 암호이면 BAD와 소수 r을 공백으로 구분하여 출력하는데 r은 암호를 이루는 두 소수 중 작은 소수를 의미한다.","143 10

---

77 12","GOOD

---

BAD 7",
20056,마법사 상어와 파이어볼,Gold IV,"어른 상어
가 마법사가 되었고, 파이어볼을 배웠다.


마법사 상어가 크기가 N×N인 격자에 파이어볼 M개를 발사했다. 가장 처음에 파이어볼은 각자 위치에서 이동을 대기하고 있다. i번 파이어볼의 위치는 (r
i
, c
i
), 질량은 m
i
이고, 방향은 d
i
, 속력은 s
i
이다. 위치 (r, c)는 r행 c열을 의미한다.


격자의 행과 열은 1번부터 N번까지 번호가 매겨져 있고, 1번 행은 N번과 연결되어 있고, 1번 열은 N번 열과 연결되어 있다.


파이어볼의 방향은 어떤 칸과 인접한 8개의 칸의 방향을 의미하며, 정수로는 다음과 같다.








7


0


1






6


 


2






5


4


3








마법사 상어가 모든 파이어볼에게 이동을 명령하면 다음이 일들이 일어난다.




모든 파이어볼이 자신의 방향 d
i
로 속력 s
i
칸 만큼 이동한다.

	


이동하는 중에는 같은 칸에 여러 개의 파이어볼이 있을 수도 있다.






이동이 모두 끝난 뒤, 2개 이상의 파이어볼이 있는 칸에서는 다음과 같은 일이 일어난다.
	


같은 칸에 있는 파이어볼은 모두 하나로 합쳐진다.


파이어볼은 4개의 파이어볼로 나누어진다.


나누어진 파이어볼의 질량, 속력, 방향은 다음과 같다.
		


질량은 ⌊(합쳐진 파이어볼 질량의 합)/5⌋이다.


속력은 ⌊(합쳐진 파이어볼 속력의 합)/(합쳐진 파이어볼의 개수)⌋이다.


합쳐지는 파이어볼의 방향이 모두 홀수이거나 모두 짝수이면, 방향은 0, 2, 4, 6이 되고, 그렇지 않으면 1, 3, 5, 7이 된다.






질량이 0인 파이어볼은 소멸되어 없어진다.








마법사 상어가 이동을 K번 명령한 후, 남아있는 파이어볼 질량의 합을 구해보자.","첫째 줄에 N, M, K가 주어진다.


둘째 줄부터 M개의 줄에 파이어볼의 정보가 한 줄에 하나씩 주어진다. 파이어볼의 정보는 다섯 정수 r
i
, c
i
, m
i
, s
i
, d
i
로 이루어져 있다.


서로 다른 두 파이어볼의 위치가 같은 경우는 입력으로 주어지지 않는다.","마법사 상어가 이동을 K번 명령한 후, 남아있는 파이어볼 질량의 합을 출력한다.","4 2 1
1 1 5 2 2
1 4 7 1 6

---

4 2 2
1 1 5 2 2
1 4 7 1 6

---

4 2 3
1 1 5 2 2
1 4 7 1 6

---

7 5 3
1 3 5 2 4
2 3 5 2 6
5 2 9 1 7
6 2 1 3 5
4 4 2 4 2","8

---

8

---

0

---

9",
10892,Divide into triangle,Silver III,"광활한 영토가 있다. 이 영토는 xy 평면으로 나타낼 수 있고 정확히 3N개의 말뚝이 박혀 있다. 말뚝은 서로 다른 위치에 박혀 있으며, 세 개의 말뚝이 일직선 상에 있는 경우는 없다.


N명의 사람이 영토를 나누려고 한다. 그들은 각자 3개의 말뚝을 선택하여 말뚝들을 선분으로 이었을 때 생기는 삼각형의 영역을 각자의 영토로 인정하기로 하였다. 물론 두 사람이 선택한 영토가(경계나 모서리라도) 조금이라도 겹치는 일은 일어나서는 안 된다. 그러나 조건을 만족하면서 서로의 말뚝을 선택하는 일은 똑똑하지 못한 그들에게 상당히 어려운 일이었다. 그렇기에 지나가던 똑똑한 당신에게 이 일을 맡기기로 하였다.","첫 번째 줄에는 사람들의 수 N (1 ≤ N ≤ 300)이 주어진다.


다음 3N줄에는 각 말뚝의 위치를 나타내는 두 정수 x,y (−10
6
 ≤ x,y ≤ 10
6
) 가 공백으로 구분되어 주어진다. 말뚝은 입력 받는 순서대로 1에서 3N까지의 번호가 붙는다.",N개의 줄에 걸쳐서 각 사람이 선택한 세 말뚝의 번호를 공백으로 구분하여 출력한다. (잘 생각해보면 알겠지만 불가능한 경우는 없다.),"2
1 0
2 0
3 1
2 2
1 2
0 1","1 2 3
4 5 6",위와 같다
14451,안대 낀 스피드러너,Platinum V,"안대를 껴서 화면을 못 보는 채로 게임을 빨리 깨는 것을 ""blindfolded speedrun""이라고 한다.


한 어드벤쳐 게임의 blindfolded speedrun 가이드북을 작성하던 중 난관에 봉착했다. 문제가 되는 파트의 난이도 자체가 높은 것은 아니다. 장애물이 격자 형태로 놓여 있고, 왼쪽 아래에서 출발해서 오른쪽 위로 가면 되는 간단한 파트다. 심지어 이 장애물도 게임을 킬 때마다 랜덤으로 배치되는 게 아니라 위치가 고정되어 있다. 문제는 처음에 어느 방향으로 서 있는지가 랜덤이라는 것이다. 안대를 꼈으니 방향을 알 방법이 없다.


N×N 격자가 있고, 2≤N≤20이다. 몇몇 칸에는 거대한 장애물이 있어서 지나갈 수 없고, 나머지는 비어 있어서 자유롭게 지나갈 수 있다. 격자 외부도 벽으로 둘러싸여 있어서 밖으로 나갈 수 없다. 주인공은 처음에 왼쪽 아래에 있고, 어느 방향으로 서 있는지는 모르지만 위와 오른쪽 중 하나인 것은 확실하다. 주인공은 매초 ""전진"", ""좌회전"", ""우회전"" 중 하나만 할 수 있다. 각 행동에는 1초가 걸린다. 전진하려고 하는데 앞에 장애물이나 벽이 있으면 그 자리에 그대로 있는다.


우리는 어느 방향으로 서 있는지에 관계 없이 오른쪽 위로 도착하도록 할 수 있는 가장 짧은 배열을 작성해야 한다. 도착하면 바로 컷신이 재생되므로 도착한 뒤 다른 칸으로 이탈할 일은 없다.","첫 줄에는 N이 주어진다.


그 다음 N줄에는 격자의 행을 나타내는 길이 N의 스트링이 주어진다. E는 빈 칸이고, H는 장애물이다.


왼쪽 아래와 오른쪽 위는 무조건 E고, 왼쪽 아래에서 오른쪽 위로 가는 경로가 무조건 존재한다. (안 그러면 잘못 만든 게임이다.)",가이드북에 쓸 수 있는 배열의 최소 길이를 출력한다.,"3
EHE
EEE
EEE",9,"""전진, 우회전, 전진, 전진, 좌회전, 전진, 좌회전, 전진, 전진""의 순서를 따르면 6초 또는 9초만에 도착할 수 있다."
25312,200% Mixed Juice!,Silver I,"음료수가 담긴 병이 총 $N$개 있다. $i$번째 병에는 음료수가 총 $w_i$
ℓ
만큼 담겨있고, 음료수에는 설탕이 총 $v_i$
mg
만큼 들어 있다. 이 음료수들 중 일부를 섞어서 총용량이 정확히 $M$
ℓ
인 혼합 음료수를 만들려고 한다. 이때, 병에 있는 음료수를 일부만 사용해도 된다.


혼합 음료수의 설탕량은 섞은 음료수들 각각에 들어 있는 설탕량의 합으로 결정된다. 설탕은 음료수에 균일하게 녹아 있기 때문에, 어떤 병에 든 음료수를 일부만 사용할 경우 설탕 역시 그 비율만큼 들어가게 된다. 즉, $i$번째 음료수를 $a_i$
ℓ
만큼$(0 \le a_i \le w_i)$ 섞는다면, $i$번째 음료수에 해당하는 설탕량은 $\left(\frac{a_i}{w_i} \times v_i\right)$
mg
이다.


음료수를 섞어 총용량이 정확히 $M$
ℓ
인 혼합 음료수를 만들었을 때, 여기에 들어갈 수 있는 설탕량의 최댓값을 출력하여라.","첫 줄에는 두 정수 $N$과 $M$이 공백으로 구분되어 주어진다. $(1 \le N \le 100\,000;$ $1 \le M \le w_1 + w_2 + \cdots + w_N)$


다음 $N$개의 줄의 $i$번째 줄에는 두 정수 $w_i$와 $v_i$가 공백으로 구분되어 주어진다. $(1 \le w_i, v_i \le 100\,000)$","총용량이 정확히 $M$
ℓ
인 혼합 음료수에 들어갈 수 있는 설탕량의 최댓값을 기약분수로 표현했을 때 $\left(\frac{a}{b}\right)$
mg
이라고 하자. 이때 $a$와 $b$를 
/
를 사이에 두고 차례로 출력한다.","3 6
2 3
3 5
5 8",49/5,
2520,팬케이크 사랑,Bronze II,"오늘은 내가 팬케이크 요리사!


은주는 팬케이크를 만들기로 했다. 은주 앞에는 지금 재료들이 있다. 이 재료들을 보고 있자니, 팬케이크를 최대 몇 개나 만들 수 있을지 궁금해졌다.


팬케이크를 만들기 위해서는 먼저 반죽을 해야 한다. 우유 8컵, 계란 노른자 8개, 설탕 4스푼, 소금 1스푼, 밀가루 9컵이 있으면 팬케이크 반죽 16개를 만들 수 있다. 어떤 0 이상의 실수 x에 대해 모든 재료가 앞에 주어진 양의 x배 이상 있다면 은주는 ⌊16x⌋개의 반죽을 만들 수 있다.


그 다음 반죽에 토핑을 얹고 구우면 팬케이크가 만들어진다. 은주가 만들 수 있는 팬케이크의 종류와 각각에 필요한 토핑의 목록은 다음과 같다.




바나나 팬케이크: 바나나 1개


딸기 팬케이크: 딸기잼 30그램


초콜릿 팬케이크: 초콜릿 스프레드 25그램


호두 팬케이크: 호두 10개




바나나는 여러 조각으로 나누거나 여러 조각을 합쳐서 사용할 수 있다. 예를 들어 1/3 크기의 바나나 조각이 3개 있으면 하나로 합쳐서 바나나 팬케이크를 만들 수 있다.


은주가 가지고 있는 재료들의 양이 주어졌을 때, 만들 수 있는 팬케이크의 최대 개수를 구하는 프로그램을 작성하시오.","첫째 줄에 테스트 케이스의 개수가 주어진다. 각 테스트 케이스는 빈 줄로 구분되며, 두 줄로 이루어져 있다.


테스트케이스의 첫째 줄에는 5개의 정수가 있다. 처음부터 차례대로 c
m
, y, s
su
, s
sa
, f이다. 은주는 우유 c
m
컵, 계란 노른자 y개, 설탕 s
su
스푼, 소금 s
sa
스푼, 밀가루 f컵을 가지고 있는 것이다.


두 번째 줄에는 4개의 정수가 있다. 이 수는 b, g
s
, g
c
, w이다. 은주는 바나나 b개, 딸기잼 g
s
그램, 초콜릿 g
c
그램, 호두 w개가 있다.


주어지는 모든 양은 0보다 크거나 같고, 10
6
보다 작거나 같다.",각 테스트 케이스에 대해 한 줄에 하나의 정수를 출력한다. 이 정수는 은주가 만들 수 있는 팬케이크의 최대 개수이다.,"2

16 16 8 2 17
10 47 100 19

16 16 8 2 17
10 470 100 19","16
30","첫 번째 테스트 케이스에서 주어진 재료를 가지고 바나나 팬케익 10개, 딸기 팬케익 1개, 초콜릿 팬케익 4개, 호두 팬케익 1개를 만들 수 있다.


  두 번째 테스트 케이스에서 주어진 재료 중 밀가루가 팬케익 30개를 만들 수 있는 양이다."
6146,신아를 만나러,Silver I,"키파는 신아를 만나러 아침 일찍(무려 6시에!) 일어났다. 간밤에 거센 비가 내려서 새로 산 장화를 신고 (0, 0)에 있는 집을 나선 키파는 무려 N(1 ≤ N ≤ 10
4
)개의 웅덩이가 있는 것을 보고 놀랐다. 각각의 웅덩이는 (A
i
, B
i
)(|A
i
| ≤ 500, |B
i
| ≤ 500)에 위치해 있으며 키파는 눈이 좋아 이 웅덩이를 모두 볼 수 있다.


신아가 일찍 일어날 수도 있기 때문에 어서 (X, Y)에 있는 신아의 집에 최대한 빨리 도달해서 그녀가 잘 때 서프라이즈를 해 주고 싶지만, 장화가 새 것이기 때문에 웅덩이를 밟지 않는 것도 중요하다. 만일 키파가 상하좌우로만 이동할 수 있다면 웅덩이를 밟지 않으면서 신아에게 갈 수 있는 최소 거리는 얼마인가? 신아에게 가기 위해 웅덩이를 밟아야만 하는 경우는 없다고 가정한다.","첫째 줄에 X, Y와 N이 공백을 사이에 두고 주어진다.


i+1 (1 ≤ i ≤ N) 번째 줄에 A
i
와 B
i
가 공백을 사이에 두고 주어진다.",첫째 줄에 키파가 웅덩이를 밟지 않고 신아에게 갈 수 있는 최소 거리를 출력하라.,"1 2 7
0 2
-1 3
3 1
1 1
4 2
-1 1
2 2",11,"신아는 (1, 2)에 있다. 키파는 예제 입력에서 주어진 7개의 웅덩이를 모두 볼 수 있다.



   4 . . . . . . . . 
   3 . M . . . . . . 
Y  2 . . M B M . M . 
   1 . M . M . M . . 
   0 . . * . . . . . 
  -1 . . . . . . . . 
    -2-1 0 1 2 3 4 5 
           X



가장 짧은 거리는 아래 그림에서 *로 표시된 길이다.



   4 ******* . . . . 
   3 * M . * . . . . 
Y  2 * . M B M . M . 
   1 * M . M . M . . 
   0 ***** . . . . . 
  -1 . . . . . . . . 
    -2-1 0 1 2 3 4 5 

           X"
20928,걷는 건 귀찮아,Gold IV,"일직선 위에 놓인 $N$개의 지점 $p_i$에는 최대 $x_i$만큼 이동시켜주는 인력거꾼들이 있다. 즉, $p_i$에 있는 인력거꾼은 $p_i$, $p_i+1$, $p_i+2$, $...$, $p_i+x_i$ 중 한 지점까지 승객을 데려다준다. 


세상에서 걷는 게 제일 귀찮은 현솔이는 목적지인 $M$까지 걷지 않고 인력거만을 타면서 이동하고 싶다. 
첫 번째 인력거에 타고 있는
 현솔이가 목적지까지 가기 위한 인력거의 최소 환승 횟수를 알아 내보자.","첫째 줄에 $N$과 $M$이 공백으로 구분되어 주어진다. ($1 \le N \le 100\,000$, $1 \le M \le 1\,000\,000$)


둘째 줄에 각 지점의 위치 $p_1$, $p_2$, $...$ , $p_N$이 공백으로 구분되어 오름차순으로 주어진다. ($1 \le p_1 \lt p_2 \lt ... \lt p_N \le 1\,000\,000$, $p_1 \le M$)


셋째 줄에 각 인력거꾼의 최대 이동 거리 $x_1$, $x_2$, $...$ , $x_N$이 공백으로 구분되어 순서대로 주어진다. ($1 \le x_i \le 10\,000$)","현솔이가 걷지 않고 목적지까지 가기 위한 인력거의 최소 환승 횟수를 출력한다. 만약 도달할 수 없다면, 
-1
을 출력한다.","3 9
1 3 5
5 5 4

---

3 11
1 3 5
5 5 4","1

---

-1",
14469,소가 길을 건너간 이유 3,Silver IV,"이웃 농장의 소가 길을 마구잡이로 건너는 것에 진절머리가 난 존은 극단의 결정을 내린다. 농장 둘레에 매우 큰 울타리를 짓는 것이다. 이렇게 하면 근처 농장 출신의 소가 들어올 일이 거의 없다. 이 일로 주변 소들이 분개하였다. 친구네 집에 놀러 갈 수 없을 뿐만 아니라, 매년 참가하던 국제 젖 짜기 올림피아드에도 올해는 참가할 수 없게 되었기 때문이다.


이웃 농장의 소 중 존의 농장에 방문할 수 있는 소가 조금 있긴 하지만, 그들도 안심할 수 있는 건 아니다. 존의 농장에 들어가는 문은 하나밖에 없고, 그 문을 통과하려면 감시관의 길고 긴 검문을 받아야 한다. 여러 마리의 소가 한 번에 들어가려고 하면 줄이 그 만큼 길어진다.


N마리의 소가 이 농장에 방문하러 왔다. 소가 도착한 시간과 검문받는 데 걸리는 시간은 소마다 다르다. (물론 같을 수도 있다.) 두 소가 동시에 검문을 받을 수는 없다. 예를 들어, 한 소가 5초에 도착했고 7초 동안 검문을 받으면, 8초에 도착한 그 다음 소는 12초까지 줄을 서야 검문을 받을 수 있다.


모든 소가 농장에 입장하려면 얼마나 걸리는 지 구해보자.","첫 줄에 100 이하의 양의 정수 N이 주어진다. 다음 N줄에는 한 줄에 하나씩 소의 도착 시각과 검문 시간이 주어진다. 각각 1,000,000 이하의 양의 정수이다.",모든 소가 농장에 입장하는 데 걸리는 최소 시간을 출력한다.,"3
2 1
8 3
5 7",15,"첫 번째 소는 2초에 도착하고 3초에 농장을 입장한다. 그 다음에는 세 번째 소가 5초에 도착하여 12초에 농장을 입장한다. 마지막으로 두 번째 소가 8초에 오는데, 세 번째 소가 검문을 받고 있으므로 12초까지 기다린 뒤 15초에 농장을 입장한다."
20945,의자 게임,Platinum III,"드디어 HI-ARC의 첫 MT가 시작되었다. HI-ARC의 운영진들은 재밌는 의자 게임을 준비하였다. 방 안에는 $1$번, $2$번, $\dots$, $N$번 의자가 순서대로 놓여있다. 즉, 가장 오른쪽에 있는 $N$번 의자를 제외하면, $i$번 의자의 오른쪽에는 $i+1$번 의자가 있다. 각 의자에는 $N$명의 참가자가 앉아있으며, 모든 참가자는 $1$ 이상 $N$ 이하의 정수인 등번호를 부여받았다. 등번호는 같을 수도 있다.


게임은 우승자가 나오기 전까지 다음의 순서대로 규칙에 따라 진행된다.






각 참가자는 자신의 오른쪽에 있는 의자로 이동한다. 단, 가장 오른쪽 의자에 앉아있는 참가자는 $1$번 의자로 이동한다.


연속되게 앉아있는 $K$명의 참가자들이 다음 조건을 만족하면, 그 참가자들이 게임에서 공동 우승한다: 그 참가자들끼리 자리를 재배열해, 자신의 등번호와 의자의 번호를 똑같이 만들 수 있다. 우승자가 없다면, 다시 규칙 1번으로 돌아간다.




하지만 이럴 수가! 게임이 진행되던 도중, 운영진들은 이 게임이 영원히 끝나지 않을 수도 있다는 것을 깨달았다. 운영진들은 참가자를 슬쩍 추가하여 이 문제를 해결하려 한다. 규칙 2번에서 규칙 1번으로 돌아가기 전, 원한다면 아래의 방식대로 참가자를 한 명 추가할 수 있다.




현재 $X$개의 의자가 있다면, $X+1$번 의자를 $X$번 의자의 오른쪽에 추가하고, 거기에 새로운 참가자가 앉는다. 이 참가자의 등번호는 운영진이 원하는 양의 정수로 정할 수 있다.




운영진들은 게임의 흥을 깨지 않기 위해 최소한의 참가자만을 추가하고 싶다. 게임이 언젠가는 끝나게 하기 위해서, 운영진들은 최소 몇 명의 참가자를 추가해야 할까?","다음과 같이 입력이 주어진다.




$N\ K$


$a_1\ a_2\,\dots\ a_N$",게임이 유한한 시간 내에 끝나기 위해서 추가해야 하는 최소 인원수를 출력한다.,"3 3
3 1 2

---

4 3
1 4 4 4","0

---

2",
14226,이모티콘,Gold IV,"영선이는 매우 기쁘기 때문에, 효빈이에게 스마일 이모티콘을 S개 보내려고 한다.


영선이는 이미 화면에 이모티콘 1개를 입력했다. 이제, 다음과 같은 3가지 연산만 사용해서 이모티콘을 S개 만들어 보려고 한다.




화면에 있는 이모티콘을 모두 복사해서 클립보드에 저장한다.


클립보드에 있는 모든 이모티콘을 화면에 붙여넣기 한다.


화면에 있는 이모티콘 중 하나를 삭제한다.




모든 연산은 1초가 걸린다. 또, 클립보드에 이모티콘을 복사하면 이전에 클립보드에 있던 내용은 덮어쓰기가 된다. 클립보드가 비어있는 상태에는 붙여넣기를 할 수 없으며, 일부만 클립보드에 복사할 수는 없다. 또한, 클립보드에 있는 이모티콘 중 일부를 삭제할 수 없다. 화면에 이모티콘을 붙여넣기 하면, 클립보드에 있는 이모티콘의 개수가 화면에 추가된다.


영선이가 S개의 이모티콘을 화면에 만드는데 걸리는 시간의 최솟값을 구하는 프로그램을 작성하시오.",첫째 줄에 S (2 ≤ S ≤ 1000) 가 주어진다.,첫째 줄에 이모티콘을 S개 만들기 위해 필요한 시간의 최솟값을 출력한다.,"2

---

4

---

6

---

18","2

---

4

---

5

---

8",
18127,모형결정,Bronze III,"지윤이는 신기한 물질을 발견했다. 이 물질의 결정은 정다각형을 유지하며 온도가 1도 낮아질 때마다 각 변을 이루는 결정의 수가 1씩 증가한다. 최초의 결정은 섭씨 0도에서 1개의 결정으로 이루어진다. 이 결정을 최소 결정이라고 하자.


결정의 크기가 증가할 때의 규칙은 다음과 같다. 그림에서 기존 결정은 파란색으로, 각 온도에서 새로 생긴 최소 결정은 노란색으로 표시하였다.






정
A
각형 모양을 유지한다. 정
A
각형이란 정다각형의 변이 
A
개임을 의미한다.


1도 낮아질 때 각 변을 이루는 최소 결정의 수가 1씩 증가한다.


최대한 적은 개수의 최소 결정들이 기존 결정에 붙는다.




지윤이는 온도를 내려보지 않고도 해당 온도의 결정을 이루는 최소 결정의 개수를 알고 싶다.


지윤이를 도와 최소 결정의 개수를 출력해주는 프로그램을 작성해보자.","첫째 줄에 정수 
A
(3 ≤ 
A
 ≤ 50), 
B
(0 ≤ B
 
≤ 10,000,000)가 주어진다. 
A
는 결정의 모양이 
A
개의 변을 가진 정다각형임을, 
B
는 온도가 섭씨 –
B
도 임을 의미한다.","결정이 
A
개의 변을 가진 정다각형이고, 온도가 섭씨 –
B
도 일 때, 최소 결정의 개수를 출력한다.",3 4,15,
7345,다항식의 나머지 연산,Silver II,"계수가 0 또는 1로만 이루어지는 특수한 다항식들의 집합에 대해 생각해보자.


이 집합의 두 다항식을 더하는 방법은 다음과 같다.




우선, 두 다항식을 더한다.


결과 다항식의 각 계수를 2로 나눈 나머지를 각각의 계수에 대입한다.




이때, (0 + 0) mod 2 = 0, (0 + 1) mod 2 = 1, (1 + 0) mod 2 = 1, and (1 + 1) mod 2 = 0 이므로


결국 결과 다항식의 각 차수의 계수는 더하고자 했던 두 다항식의 계수에 대한 XOR 연산의 결과가 된다.


(x 
6
 + x
4
 + x
2
 + x + 1) + (x
7
 + x + 1) = x
7
 + x
6
 + x
4
 + x
2


이제 뺄셈을 정의하는데, 뺄셈의 경우에도 덧셈과 같이 (0 - 0) mod 2 = 0, (0 - 1) mod 2 = 1, (1 - 0) mod 2 = 1, and (1 - 1) mod 2 = 0 이므로

덧셈과 뺄셈은 이 다항식들의 집합에 대해 동일한 의미를 지닌다. (계수 간의 XOR 연산이 새 다항식의 계수가 됨)


예시는 다음과 같다.


(x 
6
 + x
4
 + x
2
 + x + 1) - (x
7
 + x + 1) = x
7
 + x
6
 + x
4
 + x
2


다음으로 곱셈을 정의하는데, 곱셈 또한 일반적인 다항식 간의 곱셈 연산을 한 뒤 각각의 계수를 2로 나눈 나머지를 취하면 된다.


(x 
6
 + x
4
 + x
2
 + x + 1) (x
7
+ x + 1) = x
13
 + x
11
 + x
9
 + x
8
 + x
6
 + x
5
 + x
4
 + x
3
 + 1


두 다항식 f(x)와 g(x)의 곱을 h(x)로 나눈 나머지는 f(x)와 g(x)를 위와 같은 방법으로 곱한 뒤, h(x)로 나눈 나머지가 된다.


(x 
6
 + x
4
 + x
2
 + x + 1) (x
7
 + x + 1) modulo (x
8
 + x
4
 + x
3
 + x + 1) = x
7
 + x
6
 + 1


어떤 다항식의 최고차항의 차수를 degree, 줄여서 d라 하면, f(x), g(x), h(x)의 계수가 0 또는 1이므로 각 다항식은 정수 d+1과 길이 d+1인 비트스트링의 쌍으로 유일하게 표기할 수 있다. 다항식의 차수는 1000보다 작다.


예를 들어 x 
7
 + x
6
 + 1은 다음과 같이 표기된다.


8 1 1 0 0 0 0 0 1


이때, 8은 총 비트의 개수이며, 최고차항의 차수(7) + 1이다.


이제 위에서 설명한 성질을 만족하는 세 다항식 f(x), g(x), h(x)가 설명한 형식대로 주어지면 f(x)g(x) modulo h(x)를 계산하면 된다.","입력은 여러 테스트 케이스로 이루어져 있다.


입력의 첫 줄에 테스트케이스의 수 T가 주어지며, 각 테스트 케이스마다 세 줄에 걸쳐 문제에서 설명한 형식대로 표기한 f(x), g(x), h(x)가 주어진다.",각 테스트 케이스마다 한 줄에 f(x)g(x)를 h(x)로 나눈 나머지를 문제에서 설명한 형식대로 출력한다.,"2
7 1 0 1 0 1 1 1
8 1 0 0 0 0 0 1 1
9 1 0 0 0 1 1 0 1 1
10 1 1 0 1 0 0 1 0 0 1
12 1 1 0 1 0 0 1 1 0 0 1 0
15 1 0 1 0 1 1 0 1 1 1 1 1 0 0 1","8 1 1 0 0 0 0 0 1
14 1 1 0 1 1 0 0 1 1 1 0 1 0 0",
23837,구사과 시티,Diamond II,"구사과 시티는 N개의 정점으로 이루어진 트리로 나타낼 수 있다. 트리의 정점은 0부터 N-1까지 번호가 매겨져 있고, 0 ≤ i < N-1 을 만족하는 정점 i+1은 정점 A
i
와 간선으로 연결되어 있다. 간선을 이동하고 한 정점에서 다른 정점으로 이동할 때는 1분이 필요하다.


구사과 시티의 시민들은 이동할 때 걸리는 시간을 줄이기 위해 도시에 텔레포트 장치를 설치하기로 했다. 텔레포트 장치는 동일하게 생긴 두 부스로 이루어져 있고, 각각은 정점에 있어야 한다. 한 부스로 들어가면 그 즉시 다른 부스로 나오게 된다. 두 부스를 같은 정점에 설치하는 것도 가능하다.


두 정점 사이의 거리는 한 정점에서 다른 정점으로 가기 위해 필요한 시간의 최솟값과 같다. N과 간선의 정보, 그리고 정수 X가 주어진다. D를 임의의 두 정점 사이의 거리 중 최댓값으로 정의했을 때, D가 X를 넘지 않는 텔레포트 장치 설치 방법의 수를 구해보자.","첫째 줄에 두 정수 N과 X가 주어진다. 둘째 줄에는 N-1개의 정수 A
i
가 주어진다.",첫째 줄에 D가 X를 넘지 않는 텔레포트 장치 설치 방법의 수를 출력한다.,"4 1
0 1 2

---

3 2
0 0

---

6 2
0 0 0 1 1

---

7 3
0 1 0 1 2 4

---

16 7
0 1 0 2 0 0 4 5 8 9 10 11 8 4 6","1

---

6

---

1

---

0

---

31",
14222,배열과 연산,Silver I,"영선이는 총 N개의 정수로 이루어져 있는 배열 A를 가지고 있다.


배열에 적용할 수 있는 연산은 다음과 같다.




A에 있는 수 중 하나를 골라서 K를 더한다.




위의 연산은 사용하고 싶은 만큼 사용할 수 있다.


배열 A가 주어졌을 때, 연산을 적용해서 1부터 N까지의 수가 모두 하나씩 있는 배열을 만들 수 있는지 없는지 구하는 프로그램을 작성하시오.","첫째 줄에 배열의 크기 N과 K가 주어진다. (1 ≤ N ≤ 50, 1 ≤ K ≤ 10)


둘째에는 배열 A가 주어진다. 배열 A에 들어있는 수는 50보다 작거나 같은 자연수이다.","연산을 적용해서 1부터 N까지의 수가 모두 하나씩 있는 배열을 만들 수 있으면 1을, 없으면 0을 출력한다.","4 3
1 2 4 3

---

2 5
2 2

---

8 1
1 1 1 1 1 1 1 1

---

5 2
5 3 3 2 1","1

---

0

---

1

---

0",
24399,알고리즘 수업 - 선택 알고리즘 2,Silver V,"오늘도 서준이는 선택 알고리즘 수업 조교를 하고 있다. 아빠가 수업한 내용을 학생들이 잘 이해했는지 문제를 통해서 확인해보자.


N
개의 서로 다른 양의 정수가 규칙 없이 저장된 배열 A가 있다. 평균 선형 시간 선택 알고리즘으로 배열 A에서 
Q 
번째 작은 원소를 찾는 경우 배열 A의 원소가 
K 
번 교환된 직후의 배열 A를 출력해보자.


크기가 
N
인 배열에 대한 평균 선형 시간 선택 알고리즘 의사 코드는 다음과 같다.



select(A[], p, r, q) { # A[p..r]에서 q번째 작은 원소를 찾는다.
    if (p = r) then return A[p];
    t <- partition(A, p, r);  # 분할
    k <- t - p + 1;           # 기준원소가 전체에서 k번째 작은 원소임
    if (q < k) then return select(A, p, t - 1, q);  # 왼쪽 그룹으로 범위를 좁힘
    else if (q = k) then return A[t];               # 기준원소가 찾는 원소임
    else return select(A, t + 1, r, q - k);         # 오른쪽 그룹으로 범위를 좁힘
}

partition(A[], p, r) {
    x <- A[r];    # 기준원소
    i <- p - 1;   # i는 x보다 작거나 같은 원소들의 끝 지점
    for j <- p to r - 1  # j는 아직 정해지지 않은 원소들의 시작 지점
        if (A[j] ≤ x) then A[++i] <-> A[j]; # i값 증가 후 A[i] <-> A[j] 교환
    if (i + 1 ≠ r) then A[i + 1] <-> A[r];  # i + 1과 r이 서로 다르면 A[i + 1]과 A[r]을 교환
    return i + 1;
}","첫째 줄에 배열 A의 크기 
N
(5 ≤ 
N
 ≤ 10,000), 찾을 원소 정보 
Q
(1 ≤ 
Q
 ≤ 
N
), 교환 횟수 
K
(1 ≤ 
K
 ≤ 10
8
)가 주어진다.


다음 줄에 서로 다른 배열 A의 원소 
A
1
, 
A
2
, ..., 
A
N
이 주어진다. (1 ≤ 
A
i
 ≤ 10
9
)","배열 A에 
K 
번 교환이 발생한 직후의 배열 A를 한 줄에 출력한다. 교환 횟수가 
K 
보다 작으면 -1을 출력한다.","5 3 1
2 5 1 4 3

---

5 3 2
2 5 1 4 3

---

5 3 10
2 5 1 4 3","2 5 1 4 3

---

2 1 5 4 3

---

-1",
17829,222-풀링,Silver III,"조기 졸업을 꿈꾸는 종욱이는 요즘 핫한 딥러닝을 공부하던 중, 이미지 처리에 흔히 쓰이는 합성곱 신경망(Convolutional Neural Network, CNN)의 풀링 연산에 영감을 받아 자신만의 풀링을 만들고 이를 222-풀링이라 부르기로 했다.


다음은 8×8 행렬이 주어졌다고 가정했을 때 222-풀링을 1회 적용하는 과정을 설명한 것이다






행렬을 2×2 정사각형으로 나눈다.








각 정사각형에서 2번째로 큰 수만 남긴다. 여기서 2번째로 큰 수란, 정사각형의 네 원소를 크기순으로 a
4 
≤
 
a
3 
≤ a
2 
≤
 
a
1
 라 했을 때, 원소 a
2
를 뜻한다.








2번 과정에 의해 행렬의 크기가 줄어들게 된다.






종욱이는 
N
×
N
 행렬에 222-풀링을 반복해서 적용하여 크기를 1×1로 만들었을 때 어떤 값이 남아있을지 궁금해한다.


랩실 활동에 치여 삶이 사라진 종욱이를 애도하며 종욱이의 궁금증을 대신 해결해주자.","첫째 줄에 
N
(2 ≤ 
N
 ≤ 1024)이 주어진다. 
N
은 항상 2의 거듭제곱 꼴이다. (
N
=2
K
, 1 ≤ 
K
 ≤ 10)


다음 
N
개의 줄마다 각 행의 원소 
N
개가 차례대로 주어진다. 행렬의 모든 성분은 -10,000 이상 10,000 이하의 정수이다.",마지막에 남은 수를 출력한다.,"4
-6 -8 7 -4
-5 -5 14 11
11 11 -1 -1
4 9 -2 -4

---

8
-1 2 14 7 4 -5 8 9
10 6 23 2 -1 -1 7 11
9 3 5 -2 4 4 6 6
7 15 0 8 21 20 6 6
19 8 12 -8 4 5 2 9
1 2 3 4 5 6 7 8
9 10 11 12 13 14 15 16
17 18 19 20 21 22 23 24","11

---

17",예제2는 본문에 이어 다음과 같은 과정으로 답을 구할 수 있다.
10859,뒤집어진 소수,Silver II,"어제 자다가 알람 시계를 떨어뜨렸는지, 08:15분이 51:80분이 되어 있었다. 그때 나는 디지털로 표시된 어떤 숫자는 180도 뒤집혔을 때도 숫자가 될 수 있다는 걸 깨달았다.




소수 18115211이 디지털로 표시된 그림




18115211이 180도 뒤집혀서 11251181이 되었다. (소수가 아님)




, 
, 
, 
 은 뒤집혀서도 
, 
, 
, 
 그대로이다.


 은 그냥 왼쪽으로 옮겨진다. 


 은 
가 되고, 
 는 
이 된다.


, 
, 
 은 더 이상 숫자가 아니다. (
, 
, 
)




내가 좋아하는 숫자는 소수이다. 당신이 할 일은 주어진 숫자가 소수인지, 뒤집혀서도 소수인지 확인하는 것이다.","첫 번째 줄에 N이 주어진다 (1 ≤ N ≤ 10
16
).


N의 첫 숫자는 0이 아니다.","첫 번째 줄에 N이 소수이고 뒤집혀서도 소수이면 ""yes""를 출력하고, 아니면 ""no""를 출력한다.","151

---

23

---

18115211","yes

---

no

---

no",
14233,악덕 사장,Silver I,"남규회사를 운영하는 사장 zych는 직원들을 부려먹는 걸로 유명하다. 오늘도 zych는 직원들을 부려먹기 위해 고민을 하고 있다.


회사에 들어온 일들은 n개가 있고 각 일들의 마감기한이 있다. 일을 못하면 계약금을 물어야하기 때문에 모든 일을 해야 한다. 하지만 너무 적은 시간을 들이면 퀄리티가 낮아지므로 직원들을 굴려서 최대한 많은 시간을 일을 하게 하려한다. 하지만 또 일마다 시간이 다르면 직원들이 혼동을 하기에, 모든 일을 딱 k시간만 일을 하게 하려한다.


일들의 마감기한이 주어졌을 때, 모든 일을 하면서 k가 최대가 되는 값을 출력하시오.","첫째 줄에는 일의 개수 n이 주어진다.(1≤n≤50,000)


둘째 줄에는 각 일별로 마감기한 Ai가 주어진다.(1≤Ai≤1,000,000,000) 마감기한이 같은 입력은 들어오지 않는다.",모든 일을 다 할 수 있는 일의 기한 최대 k를 출력하시오.,"5
1 2 3 4 5",1,
2169,로봇 조종하기,Gold II,"NASA에서는 화성 탐사를 위해 화성에 무선 조종 로봇을 보냈다. 실제 화성의 모습은 굉장히 복잡하지만, 로봇의 메모리가 얼마 안 되기 때문에 지형을 N×M 배열로 단순화 하여 생각하기로 한다.


지형의 고저차의 특성상, 로봇은 움직일 때 배열에서 왼쪽, 오른쪽, 아래쪽으로 이동할 수 있지만, 위쪽으로는 이동할 수 없다. 또한 한 번 탐사한 지역(배열에서 하나의 칸)은 탐사하지 않기로 한다.


각각의 지역은 탐사 가치가 있는데, 로봇을 배열의 왼쪽 위 (1, 1)에서 출발시켜 오른쪽 아래 (N, M)으로 보내려고 한다. 이때, 위의 조건을 만족하면서, 탐사한 지역들의 가치의 합이 최대가 되도록 하는 프로그램을 작성하시오.","첫째 줄에 N, M(1≤N, M≤1,000)이 주어진다. 다음 N개의 줄에는 M개의 수로 배열이 주어진다. 배열의 각 수는 절댓값이 100을 넘지 않는 정수이다. 이 값은 그 지역의 가치를 나타낸다.",첫째 줄에 최대 가치의 합을 출력한다.,"5 5
10 25 7 8 13
68 24 -78 63 32
12 -69 100 -29 -25
-16 -22 -57 -33 99
7 -76 -11 77 15",319,
10986,나머지 합,Gold III,"수 N개 A
1
, A
2
, ..., A
N
이 주어진다. 이때, 연속된 부분 구간의 합이 M으로 나누어 떨어지는 구간의 개수를 구하는 프로그램을 작성하시오.


즉, A
i
 + ... + A
j
 (i ≤ j) 의 합이 M으로 나누어 떨어지는 (i, j) 쌍의 개수를 구해야 한다.","첫째 줄에 N과 M이 주어진다. (1 ≤ N ≤ 10
6
, 2 ≤ M ≤ 10
3
)


둘째 줄에 N개의 수 A
1
, A
2
, ..., A
N
이 주어진다. (0 ≤ A
i
 ≤ 10
9
)",첫째 줄에 연속된 부분 구간의 합이 M으로 나누어 떨어지는 구간의 개수를 출력한다.,"5 3
1 2 3 1 2",7,
8913,문자열 뽑기,Gold III,"a와 b로만 이루어진 문자열 s이 있다. 그룹은 같은 글자로 이루어진 가장 긴 연속 부분 문자열이다. 길이가 2 이상인 s의 모든 그룹 g는 제거할 수(뽑을 수) 있고, 남은 왼쪽 부분과 오른쪽 부분을 연결해서 새 문자열을 만들 수 있다. 이러한 과정은 문자열이 빈 문자열이 되거나, 길이가 2 이상인 그룹이 없을 때 까지 계속한다.


예를 들어, s = babbbaaabb일 때, s에는 그룹이 다섯 개 있다. s는 다음과 같은 단계를 거쳐서 빈 문자열로 바꿀 수 있다. (밑 줄이 그어져 있는 그룹이 뽑히는 그룹)


ba
bbb
aaabb → b
aaaa
bb → 
bbb
 → 빈 문자열


하지만, 아래와 같은 단계를 거친다면, 빈 문자열로 바꿀 수 없다.


babbbaaa
bb
 → ba
bbb
aaa → b
aaaa
 → b


문자열이 주어졌을 때, 적절한 과정을 거쳐 빈 문자로 바꿀 수 있는지 없는지를 구하는 프로그램을 작성하시오.","첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 a와 b로 이루어진 문자열로 이루어져 있다. 문자열의 길이는 1보다 크거나 같고, 25보다 작거나 같다.","각 테스트 케이스에 대해서, 입력으로 주어진 문자열을 빈 문자열로 바꿀 수 있으면 1을, 없으면 0을 출력한다.","3
babbbaaabb
aabbaabb
abab","1
1
0",
11584,저 집합은 해로운 집합이다,Gold II,"집합론을 공부하던 승현이는 다음과 같은 집합을 알게 됐다.


\[C_0 = \left[0,1\right] \\ C_n = \left\{ a+\sum_{i=1}^{n} {\frac{a_i}{3^i}} \mid 0 \le a \le \frac{1}{3^n}, a_i \in \left\{0, 2\right\} \right\} \text{ for } n \in \mathbb{N} \\ C = \bigcap_{n=0}^{\infty}{C_n}\]


\(C\)라는 집합이 잘 이해가 되지 않던 승현이는 이해를 하기 위해 몇 가지 작업을 계획했다. 첫 번째 작업은 어떤 유리수 한 개를 임의로 골랐을 때 그 수가 집합 안에 들어가는지 안 들어가는지 확인하는 작업이다. 만약 집합 안에 들어가지 않는다면 두 번째 작업을 이어서 하게 되는데, 이 작업은 그 유리수를 처음으로 포함하지 않는, 즉 가장 작은 \(n\)을 갖는 집합을 찾는 것이다.


몇 번 손으로 작업하는 승현이는 이 작업이 매우 귀찮아졌다. 그래서 컴퓨터를 사용하기로 했는데 코딩을 하는 것도 귀찮아졌는지 갑자기 이 일을 후배인 당신에게 시켰다. 얼떨결에 거절하지 못하고 이 일을 받게 된 당신은 승현이를 골탕 먹여줄 심보로 불완전한 판정 프로그램을 만들기로 했다.


너무 답이 이상하게 나오면 속지 않을 것을 걱정한 당신은 적당히 그럴듯하게 답을 출력하기로 했다. 이를 위해 \(C_0\)부터 \(C_{10}\)까지에 대해서만 수의 포함 여부를 확인하고 만약 모든 집합이 수를 포함한다면 포함된다고 판정하는 프로그램을 만들 것이다. 승현이를 골려주기 위해 위 조건을 만족하는 불완전한 프로그램을 작성하자!!","입력의 첫 줄에는 테스트 케이스의 수 T가 주어진다. 각 테스트 케이스마다 유리수를 나타내는 정수 a와 b(0 ≤ a ≤ 100,000, 1 ≤ b ≤ 100,000)가 빈칸을 사이에 두고 주어진다. 이때 a는 분자, b는 분모를 나타낸다.",한 테스트 케이스 당 한 줄에 걸쳐 주어진 유리수가 \(C_0\)부터 \(C_{10}\)사이에 포함되지 않으면 처음으로 포함되지 않는 집합의 아랫첨자 \(n\)을 출력하고 포함하면 -1을 출력한다.,"4
0 1
1 2
1 6
5 18","-1
1
2
3","첫 번째 입력의 경우 \(a_i = 0, a = 0\) 일 때 모든 집합에 대해 포함된다.


두 번째 입력의 경우 \(C_0 = \left[0,1\right], C_1 = \left[0,\frac{1}{3}\right] \cup \left[\frac{2}{3},1\right]\) 이므로 \(\frac{1}{2}\)는 \(C_1\)에서 처음으로 포함되지 않는다.


세 번째 입력의 경우 \(C_0\), \(C_1\)은 위와 같고, \(C_2 = \left[0,\frac{1}{9}\right] \cup \left[\frac{2}{9},\frac{1}{3}\right]\cup \left[\frac{2}{3},\frac{7}{9}\right] \cup \left[\frac{8}{9},1\right]\) 이므로 \(C_2\)에서 처음으로 포함되지 않는다."
12891,DNA 비밀번호,Silver II,"평소에 문자열을 가지고 노는 것을 좋아하는 민호는 DNA 문자열을 알게 되었다. DNA 문자열은 모든 문자열에 등장하는 문자가 {‘A’, ‘C’, ‘G’, ‘T’} 인 문자열을 말한다. 예를 들어 “ACKA”는 DNA 문자열이 아니지만 “ACCA”는 DNA 문자열이다. 이런 신비한 문자열에 완전히 매료된 민호는 임의의 DNA 문자열을 만들고 만들어진 DNA 문자열의 부분문자열을 비밀번호로 사용하기로 마음먹었다.


하지만 민호는 이러한 방법에는 큰 문제가 있다는 것을 발견했다. 임의의 DNA 문자열의 부분문자열을 뽑았을 때 “AAAA”와 같이 보안에 취약한 비밀번호가 만들어 질 수 있기 때문이다. 그래서 민호는 부분문자열에서 등장하는 문자의 개수가 특정 개수 이상이여야 비밀번호로 사용할 수 있다는 규칙을 만들었다.


임의의 DNA문자열이 “AAACCTGCCAA” 이고 민호가 뽑을 부분문자열의 길이를 4라고 하자. 그리고 부분문자열에 ‘A’ 는 1개 이상, ‘C’는 1개 이상, ‘G’는 1개 이상, ‘T’는 0개 이상이 등장해야 비밀번호로 사용할 수 있다고 하자. 이때 “ACCT” 는 ‘G’ 가 1 개 이상 등장해야 한다는 조건을 만족하지 못해 비밀번호로 사용하지 못한다. 하지만 “GCCA” 은 모든 조건을 만족하기 때문에 비밀번호로 사용할 수 있다.


민호가 만든 임의의 DNA 문자열과 비밀번호로 사용할 부분분자열의 길이, 그리고 {‘A’, ‘C’, ‘G’, ‘T’} 가 각각 몇번 이상 등장해야 비밀번호로 사용할 수 있는지 순서대로 주어졌을 때 민호가 만들 수 있는 비밀번호의 종류의 수를 구하는 프로그램을 작성하자. 단 부분문자열이 등장하는 위치가 다르다면 부분문자열이 같다고 하더라도 다른 문자열로 취급한다.","첫 번째 줄에 민호가 임의로 만든 DNA 문자열 길이 |S|와 비밀번호로 사용할 부분문자열의 길이 |P| 가 주어진다. (1 ≤ |P| ≤ |S| ≤ 1,000,000)


두번 째 줄에는 민호가 임의로 만든 DNA 문자열이 주어진다.


세번 째 줄에는 부분문자열에 포함되어야 할 {‘A’, ‘C’, ‘G’, ‘T’} 의 최소 개수가 공백을 구분으로 주어진다. 각각의 수는 |S| 보다 작거나 같은 음이 아닌 정수이며 총 합은 |S| 보다 작거나 같음이 보장된다.",첫 번째 줄에 민호가 만들 수 있는 비밀번호의 종류의 수를 출력해라.,"9 8
CCTGGATTG
2 0 1 1

---

4 2
GATA
1 0 0 1","0

---

2",
25629,홀짝 수열,Bronze III,"길이가 $N$인 수열의 $i(1 \le i \le N)$번째 원소를 정수 $a_i(1\le a_i \le 100)$라고 하자. 동훈이는 이 수열을 잘 정렬해서 홀짝 수열로 만들고 싶다. 어떤 수열이 홀짝 수열이 되려면 다음 조건을 만족해야 한다.




수열의 홀수번째 원소는 모두 홀수여야 하고, 순서대로 나열했을 때 감소하지 않아야 한다. $$a_1 \le a_3 \le a_5 \le a_7 \le ...$$


수열의 짝수번째 원소는 모두 짝수여야 하고, 순서대로 나열했을 때 감소하지 않아야 한다. $$a_2 \le a_4 \le a_6 \le a_8 \le ...$$




다음과 같은 수열은 홀짝 수열이다. $[1, 2, 1], [3], [5, 4]$ 그러나 다음과 같은 수열은 홀짝 수열이 아니다. $[3, 2, 1], [2, 2], [5, 4, 7, 2]$


$[3, 2, 1]$의 홀수번째 원소들을 순서대로 나열하면 $[3, 1]$인데, 감소하기 때문에 홀짝 수열이 아니다.


$[2, 2]$는 첫 번째 원소가 홀수가 아니므로 홀짝 수열이 아니다.


$[5,4,7,2]$의 짝수번째 원소들을 순서대로 나열하면 $[4, 2]$인데, 감소하기 때문에 홀짝 수열이 아니다.


길이 $N$의 수열 $a_1,a_2,…a_N$이 주어졌을 때, 이 수열을 잘 정렬한다면 홀짝 수열로 만드는 것이 가능할까?","첫째 줄에 수열의 길이 $N(1\le N \le 100)$이 주어진다.


둘째 줄에 $a_1, a_2, ..., a_N$이 주어진다. 수열의 $i$번째 원소는 정수 $a_i(1\le a_i \le 100)$이다.","주어진 수열을 잘 정렬해서 홀짝 수열로 만들 수 있다면 
1
을, 어떻게 정렬하더라도 홀짝 수열로 만들 수 없다면 
0
을 출력한다.","3
2 1 1

---

3
4 2 3

---

5
4 1 6 3 5","1

---

0

---

1",
11581,구호물자,Silver I,"서기 2050년 엄청나게 강력한 폭풍이 인천을 강타했다. 강력한 폭풍의 영향으로 모든 사람은 대피소로 대피하였으며, 많은 도로가 유실되었다. 그나마 남아있는 도로도 모든 표지판과 가로등이 작동을 멈춰 제대로 된 길을 찾기란 불가능에 가까웠다.


이런 심각한 상황에 민지는 대피소에 구명 물자를 보내려고 한다. 서기 2050년 인천의 모든 길은 교차로와 도로만으로 이루어져 있다. 한 교차로와 다른 교차로는 일방통행 도로로 연결되어 있으며, 한 교차로와 여러 교차로가 연결될 수 있다. 그리고 도로에 한번 진입하면 교차로에 도착할 때까지 도로를 벗어날 수 없다.


민지는 구호물자로 가득 찬 트럭을 출발시키려고 했지만, 운행을 거부한 트럭운전사들 때문에 난관에 봉착했다. 강력한 폭풍의 영향으로 내비게이션은 정확하지 않고, 도로를 구분할 수 있는 표지판이 망가졌기 때문에 트럭운전사들은 교차로에서 어떤 도로를 선택해야 할지 모른다. 이러한 상황에서 특정 도로를 임의로 선택하면 이미 지나쳤던 교차로를 또다시 방문하는 일이 발생할 수 있고, 만약 그런 상황이 발생하면 트럭의 기름이 부족해 대피소에 도착하지 못할 수 있다.


대피소에 반드시 구호물자를 보내야 한다고 생각하는 민지는 현재 위치인 1번 교차로에서 대피소가 있는 N번 교차로까지 어떤 도로를 선택하며 가더라도 지나친 교차로를 다시 방문하지 않는다는 것을 증명해 트럭 운전사들을 설득하려 한다.




위 그림은 대피소가 3번에 있다고 했을 때 가능한 두 가지 모양이다. 왼쪽 그림에서는 어떠한 도로를 선택하더라도 지나친 교차로를 다시 방문하지 않고 대피소가 있는 3번에 무사히 도착할 수 있다. 하지만 오른쪽 그림에서는 방문했던 교차로를 다시 방문할 가능성이 있다.


민지를 도와 어떠한 길을 선택하더라도 같은 교차로를 다시 방문하는 경우가 있는지 없는지를 판단하는 프로그램을 작성하자.","첫 번째 줄에 교차로의 수 N(1 ≤ N ≤ 100)이 주어진다. 그다음에 1번 교차로부터 N-1번 교차로의 상태가 각각 두 줄에 걸쳐 차례대로 주어진다. (1 ≤ i ≤ N-1)번째 교차로와 연결된 교차로의 수 M
i
(0 ≤ M
i
 ≤ N)가 주어지고 그다음 줄에는 i번째에서 갈 수 있는 교차로의 번호 C
i
(1 ≤ C
i
 ≤ N)가 주어진다. N번 교차로는 대피소가 있는 곳이기 때문에 연결 상태가 주어지지 않는다. 구호물자가 출발하는 장소는 항상 1번이며 대피소가 있는 곳 역시 항상 N번이다.","1번 교차로에서 N번 교차로까지 가는 과정 중 지나쳤던 교차로를 다시 방문하는 경우가 생길 수 있으면 CYCLE, 그렇지 않다면 NO CYCLE을 출력한다.","3
2
2 3
1
3

---

3
2
2 3
2
1 3","NO CYCLE

---

CYCLE",
23320,홍익 절대평가,Bronze II,"2021년, 홍익대학교는 절대평가를 시행한다. 착한 도현이는 A학점을 받는 사람이 최대한 많았으면 한다.


시험을 응시한 학생의 수 $N$, 상대평가 시 A학점의 비율 $X\%$와 절대평가 시 A학점을 받기 위한 최소 점수 $Y$점이 주어질 때, 상대평가 시 A학점을 받는 인원의 수와 절대평가 시 A학점을 받는 인원의 수를 구하는 프로그램을 작성해보자.","첫째 줄에 시험을 응시한 학생의 수 정수 $N$ ($10 \leq N \leq 100$, $N$은 $10$의 배수) 이 주어진다.


둘째 줄에 길이가 $N$인 정수 수열 $A$ ($1 \leq A_i \leq 100$)가 공백을 기준으로 주어진다. $i$번째로 주어지는 수 $A_i$는 $i$번째 학생의 점수이다. 모든 학생의 점수는 다르다.


셋째 줄에 상대평가 시 A학점의 비율 $X$ ($10 \leq X \leq 100$, $X$는 $10$의 배수)와 절대평가 시 A학점을 받기 위한 최소 점수 $Y$ ($1 \leq Y \leq 100$)가 정수로 주어진다.",첫째 줄에 상대평가 시 A학점을 받는 인원의 수와 절대평가 시 A학점을 받는 인원의 수를 공백으로 구분해 출력한다.,"10
1 2 3 4 5 6 7 8 9 10
50 3

---

10
1 2 3 4 5 6 7 8 9 10
50 6","5 8

---

5 5",
7772,구조 이성질체,Diamond IV,"창영이는 이번 학기에 유기 화학을 수강한다. 첫 시간에는 가장 간단한 유기 분자인 알칸에 대해서 배웠다.


알칸은 수소(H)와 탄소(C) 원자로만 이루어진 분자이다. 각각의 탄소 원자는 4개의 결합(C-H, C-C 결합) 을 가지고 있고, 각각의 수소 원자는 탄소와 결합되어져 있다. (H-C 결합)


알칸 분자는 단일 결합이며 사이클이 존재하지 않는다. 탄소 원자 n개로 이루어진 분자는 항상 수소 원자 2n + 2개를 가지고 있고, 분자식으로는 C
n
H
2n+2
로 나타낸다.


탄소 원자가 연결된 구조는 탄소 골격이라고 한다. 구조 이성질체는 분자식은 같지만, 탄소 골격이 다른 것을 말한다. 탄소 원자의 개수가 세 개 이상인 알칸은 여러 가지 방법으로 나타낼 수 있다. 가장 간단한 알칸의 탄소 골격은 가지 없이 일직선으로 연결된 구조이다. 아래 그림은 C6H14의 모든 구조 이성질체이다.




유기 화학의 첫 숙제는 탄소 원자가 n개인 알칸의 구조 이성질체의 개수를 구하는 것이다.


알칸의 탄소 원자의 개수가 주어졌을 때, 구조 이성질체의 개수를 구하는 프로그램을 작성하시오.",첫째 줄에 알칸의 탄소 원자의 개수 n이 주어진다. (1 ≤ n ≤ 50),"첫째 줄에 C
n
H
2n+2
의 구조 이성질체의 개수를 출력한다. 정답은 항상 64비트 정수 타입 범위이다.","6

---

12","5

---

355",
25548,신기한 숫자 2,Platinum III,"두 양의 정수 $A$, $B$가 주어질 때, 다음과 같은 조건을 만족하는 양의 정수 $C$의 개수를 $f(A,B)$라 하자.


$GCD(A,B) = GCD(A,C)$, $LCM(A,B) = LCM(B,C)$


$\sum_{i=1}^N \sum_{j=1}^N f(i,j)$의 값을 구하시오.


$GCD(A,B)$는 $A$와 $B$의 최대공약수를, $LCM(A,B)$는 $A$와 $B$의 최소공배수를 의미한다.",양의 정수 $N$이 주어진다. $(1 \leq N \leq 10^9)$,"$\sum_{i=1}^N \sum_{j=1}^N f(i,j)$의 값을 출력한다. 문제의 입력 범위 안에서 이 값은 $2^{63}$ 미만임이 보장된다.",4,13,
25173,용감한 아리의 동굴 대탈출,Gold I,"알쿡 나라의 아리 기사는 드디어 깊은 동굴 속에 사는 전설의 보스 몬스터를 잡으러 왔다. 이후 설명에서 보스 몬스터는 편의상 보스라고 칭한다. 알쿡 나라는 무한히 큰 2차원 격자판으로 이루어져 있으며 보스가 살고 있는 동굴은 
N
 x 
M
 크기로 알쿡 나라 어딘가에 존재한다. 동굴 주위는 벽으로 막혀있으며, 동굴 곳곳에는 석순이 자라있다.


아리가 동굴에 입장하면 아리는 동굴 안의 격자판 중 한 칸에, 보스는 아리와 상하좌우 인접한 칸 중 한 칸에 위치한 상태로 전투가 시작된다. 전투 중, 아리와 보스는 각자의 현재 진행 방향으로 한 칸 이동할 수 있으며 진행 방향은 상하좌우 네 방향 중 하나이다. 전투가 시작될 때 보스의 진행 방향은 보스가 아리를 바라보고 있는 방향이며, 아리의 첫 진행 방향도 보스의 진행 방향과 동일하다. 아리와 보스 모두 동굴 벽이나 석순이 자란 칸으로 이동할 수 없으며, 둘이 동시에 한 칸에 있을 수는 없다.


전투는 
아리의 공격 - 아리의 이동 - 보스의 공격 - 보스의 이동
이 끝나기 전까지 반복된다. 어떤 과정도 다른 과정과 동시에 진행할 수 없으며, 반드시 자신의 공격이 끝나고 이동하거나, 상대의 이동이 끝나야 공격이 가능하다. 상대의 공격으로 데미지를 입을 경우 자신의 체력이 입은 데미지만큼 감소하며, 전투 중 아리와 보스 둘 중 체력이 먼저 0 보다 작거나 같게 되는 쪽이 패배하며 전투는 그 즉시 끝나게 된다. 전투 과정은 다음과 같다.




아리의 공격 차례일 때 아리는 
D
만큼의 데미지로 보스를 한 번 공격할 수 있다.


아리의 이동 차례일 때 아리는 현재 진행 방향으로 한 칸 이동할 수 있다.
	


아리가 현재 진행 방향으로 이동할 수 없는 경우, 이동할 수 있는 진행 방향을 찾을 때까지 제자리에서 오른쪽으로 90도씩 회전하고 회전할 때마다 체력을 1 소모한다. 이동할 수 있는 진행 방향을 찾았을 때, 해당 방향으로 한 칸 이동한다.


4번을 회전하고도 진행 방향을 찾지 못한 경우 현재 위치한 칸에서 아리의 이동 차례를 마친다.






보스의 공격 차례일 때 보스는 아래에서 설명하는 방법으로 석순을 하나 찾아 해당 위치에 부하 몬스터 한 마리를 소환한다. 보스는 동굴의 어떤 칸에 위치하든 동굴 안의 모든 칸은 물론이고, 동굴 밖의 모든 칸도 눈으로 확인할 수 있는 능력이 있다. 이 능력 때문에 보스는 직접 움직이지 않고 석순을 찾을 수 있으며, 석순을 발견하는 순간 찾는 과정을 멈추고 부하 몬스터를 소환한다.
	


아래와 같이, 보스는 현재 위치한 칸을 중심으로 시계 방향으로 탐색을 진행한다. 석순을 하나 발견하거나 동굴 안의 모든 칸을 확인할 때까지 정사각형의 크기를 늘려가며 탐색을 진행한다.














보스의 진행 방향이 ↑ 일 때


보스의 진행 방향이 → 일 때


보스의 진행 방향이 ↓ 일 때


보스의 진행 방향이 ← 일 때






















위의 방법으로 탐색을 진행할 때, 석순을 하나 발견하거나 동굴의 모든 칸을 확인하고도 석순을 발견하지 못한다면 보스는 그대로 자신의 공격 차례를 마친다.
	


위의 방법으로 석순을 발견했다면 발견한 석순이 위치한 칸에 보스의 공격력인 
E
만큼의 체력을 가지는 부하 몬스터를 한 마리 소환한다. 부하 몬스터는 아리에게 최단 거리로 이동하여 아리를 공격하고 사라지며, 부하 몬스터가 사라져야만 보스의 공격 차례가 끝나고 보스의 다음 이동이 가능하다.


부하 몬스터는 상하좌우로 한 칸씩 이동 가능하며, 한 칸 이동할 때마다 자신의 체력을 1 소모한다. 부하 몬스터는 동굴 벽 혹은 보스나 석순이 위치한 칸으로 이동할 수 없다. 부하 몬스터가 아리가 있는 칸에 도착했을 때 남은 체력만큼 아리에게 데미지를 입히고 사라지며, 만약 아리에게 가는 도중 체력이 0이 되었거나 아리에게 도착할 수 없었다면 부하 몬스터는 데미지를 입히지 못하고 사라진다.






보스의 이동차례일 때 보스는 아리가 마지막으로 이동하기 전 위치한 칸으로 이동하고, 아리가 마지막으로 이동하고 난 후의 진행 방향과 같은 방향을 가진다. 만약, 아리의 마지막 이동 차례에서 아리가 이동할 수 없었다면 보스도 현재 위치한 칸에서 이동 차례를 마친다.




여기까지의 설명은 
“아리의 위대한 모험!”
 이라는 게임에 대한 설명이었다! 아리를 플레이하는 우리는 아리가 전투에서 이길 수 있을지 판단해야 한다. 동굴의 상태를 미리 알고 있다고 할 때, 아리가 전투에서 이길 수 있을지 예측해보자.","첫 번째 줄에 동굴의 행의 크기를 의미하는 
N
과 열의 크기를 의미하는 
M
이 주어진다.


두 번째 줄부터 
N
개의 줄에 대해 
i
번째 줄에는 동굴의 (
i
 - 1)행의 상태를 나타내는 
M
개의 정수가 주어진다. 0보다 크거나 같고 3보다 작거나 같은 네 가지 정수로 주어지며, 1은 석순이 자란 칸, 2는 아리의 시작 위치, 3은 보스의 시작 위치를 나타내며 0은 아무것도 없는 칸을 의미한다. 아리의 시작 위치와 보스의 시작 위치는 동굴에서 딱 한 칸씩만 주어지며 보스와 아리가 상하좌우로 인접하지 않은 상태인 입력은 주어지지 않는다.


(N
 + 2)번째 줄에 아리의 체력, 공격력을 나타내는 두 정수 
A
, 
D
 와 보스의 체력, 공격력을 나타내는 두 정수 
B
, 
E
 가 한 줄에 주어진다.","첫 번째 줄에 전투에서 아리가 이길 수 있다면 ""
VICTORY!""
를 출력하고, 아리가 이길 수 없다면 ""
CAVELIFE...""
을 출력한다.","5 6
0 0 0 0 0 0
0 1 0 0 0 0
0 0 0 2 0 1
0 0 0 3 0 0
0 0 1 0 0 0
20 6 21 9

---

5 6
0 0 0 0 0 0
0 1 0 0 0 0
0 2 3 0 0 1
0 0 0 0 0 0
0 0 1 0 0 0
20 6 21 9","VICTORY!

---

CAVELIFE...",
20656,지구 종말,Ruby II,"윤창기는 서울대학교 화학부 종신교수이다.


오늘 윤창기 교수는 문제 지문에 쓸 만한 컨텐츠를 만들기 위해 지구를 파괴했다.


살아남은 $N$ 명의 생존자들은 화성으로 탈출하기 위해 우주 정거장에 모였다. 각 생존자는 $1$ 이상 $N$ 이하의 서로 다른 정수 번호로 구분된다.


우주 정거장에는 화성과 지구를 오가는 우주 왕복선이 있다. 왕복선은 윤창기 교수만이 조종할 수 있으며, 조종사 외에 추가로 한 명이 더 탈 수 있다. 


윤창기 교수는 길이 $M$ 의 리스트를 가지고 있다. 이 리스트에는 각각 3명의 서로 다른 생존자가 적혀 있다. 윤창기 교수가 행성을 비운 사이, 이 리스트에 적혀 있는 세 생존자가 하나의 행성에 모이게 된다면, 이들은 정치 얘기를 하다가 핵 전쟁을 일으킬 것이고, 지구와 화성은 그 즉시 폭파될 것이다.


과연 모든 생존자가 무사히 화성으로 탈출할 수 있을까?","이 문제는 여러 개의 테스트 케이스가 주어진다. 첫 번째 줄에 테스트 케이스의 개수 $T$ 가 주어지고, 이후 $T$ 줄에 걸쳐 다음과 같은 정보가 주어진다. 


첫 번째 줄에 두 정수 $N, M$ 이 주어진다.


이후 $M$ 개의 줄에 서로 다른 생존자 셋의 번호 $a, b, c$ 가 주어진다.","각 테스트 케이스에 대해, 모든 생존자가 탈출할 수 있으면 TAK, 아니면 NIE를 한 줄로 출력한다.","4
4 3
1 2 3
1 3 4
1 2 4
5 4
1 2 3
1 3 4
1 4 5
1 2 5
6 10
1 2 3
1 2 4
1 2 5
1 2 6
1 3 6
1 4 6
1 5 6
1 3 4
1 3 5
1 4 5
6 9
1 2 3
1 2 4
1 2 5
1 2 6
1 3 6
1 4 6
1 5 6
1 3 4
1 4 5","TAK
TAK
NIE
TAK",
22856,트리 순회,Gold IV,"노드가 $N$개인 이진 트리가 있다. 트리를 중위 순회와 유사하게 순회하려고 한다. 이를 
유사 중위 순회
라고 하자.


순회의 시작은 트리의 루트이고 순회의 끝은 중위 순회할 때 마지막 노드이다. 이때 루트 노드는 항상 1번 노드이다.


유사 중위 순회는 루트 노드에서 시작하며, 다음과 같이 진행된다.




현재 위치한 노드의 왼쪽 자식 노드가 존재하고 아직 방문하지 않았다면, 왼쪽 자식 노드로 이동한다.


그렇지 않고 현재 위치한 노드의 오른쪽 자식 노드가 존재하고 아직 방문하지 않았다면, 오른쪽 자식 노드로 이동한다.


그렇지 않고 현재 노드가 유사 중위 순회의 끝이라면, 유사 중위 순회를 종료한다.


그렇지 않고 부모 노드가 존재한다면, 부모 노드로 이동한다.


유사 중위 순회를 종료할 때까지 1 ~ 4를 반복한다.






위 그림에 있는 트리에서 중위 순회를 한다면 $4 \rightarrow 2 \rightarrow 5 \rightarrow 1 \rightarrow 6 \rightarrow 3 \rightarrow 7$ 순으로 순회를 한다.


따라서, 
유사 중위 순회의 끝
은 노드 7이 된다.




유사 중위 순회
는 위 그림과 같이 루트인 노드 $1$에서 시작하여 노드 $7$에서 끝나고 $1 \rightarrow 2 \rightarrow 4 \rightarrow 2 \rightarrow 5 \rightarrow 2 \rightarrow 1 \rightarrow 3 \rightarrow 6 \rightarrow 3 \rightarrow 7$ 이와 같은 순서로 순회를 진행한다. 
유사 중위 순회
를 진행하면서 총 10번 이동하였다.


여기서 이동이라는 것은 하나의 노드에서 다른 노드로 한번 움직이는 것을 의미한다. 예를 들면, 노드 1에서 노드 2로 가는 것을 한번 이동하였다고 한다.


유사 중위 순회
를 하면서 이동한 횟수를 구하려고 한다.","첫 번째 줄에 트리를 구성하는 노드의 개수 $N$이 주어진다.


두 번째 줄부터 $N + 1$ 번째 줄까지 현재 노드 $a$, 현재 노드의 왼쪽 자식 노드 $b$, 현재 노드의 오른쪽 자식 노드 $c$가 공백으로 구분되어 주어진다. 만약 자식 노드의 번호가 -1인 경우 자식 노드가 없다는 것을 의미한다.",유사 중위 순회를 하면서 이동한 총 횟수를 출력한다.,"7
1 2 3
2 4 5
3 6 7
4 -1 -1
5 -1 -1
6 -1 -1
7 -1 -1

---

1
1 -1 -1","10

---

0",
5397,키로거,Silver II,"창영이는 강산이의 비밀번호를 훔치기 위해서 강산이가 사용하는 컴퓨터에 키로거를 설치했다. 며칠을 기다린 끝에 창영이는 강산이가 비밀번호 창에 입력하는 글자를 얻어냈다.


키로거는 사용자가 키보드를 누른 명령을 모두 기록한다. 따라서, 강산이가 비밀번호를 입력할 때, 화살표나 백스페이스를 입력해도 정확한 비밀번호를 알아낼 수 있다. 


강산이가 비밀번호 창에서 입력한 키가 주어졌을 때, 강산이의 비밀번호를 알아내는 프로그램을 작성하시오. 강산이는 키보드로 입력한 키는 알파벳 대문자, 소문자, 숫자, 백스페이스, 화살표이다.","첫째 줄에 테스트 케이스의 개수가 주어진다. 각 테스트 케이스는 한줄로 이루어져 있고, 강산이가 입력한 순서대로 길이가 L인 문자열이 주어진다. (1 ≤ L ≤ 1,000,000) 강산이가 백스페이스를 입력했다면, '-'가 주어진다. 이때 커서의 바로 앞에 글자가 존재한다면, 그 글자를 지운다. 화살표의 입력은 '<'와 '>'로 주어진다. 이때는 커서의 위치를 움직일 수 있다면, 왼쪽 또는 오른쪽으로 1만큼 움직인다. 나머지 문자는 비밀번호의 일부이다. 물론, 나중에 백스페이스를 통해서 지울 수는 있다. 만약 커서의 위치가 줄의 마지막이 아니라면, 커서 및 커서 오른쪽에 있는 모든 문자는 오른쪽으로 한 칸 이동한다.","각 테스트 케이스에 대해서, 강산이의 비밀번호를 출력한다. 비밀번호의 길이는 항상 0보다 크다.","2
<<BP<A>>Cd-
ThIsIsS3Cr3t","BAPC
ThIsIsS3Cr3t",
25918,북극곰은 괄호를 찢어,Silver I,"극지 연구소에서 연구 중인 협이는 새로운 북극곰의 특성을 발견했다. 그것은 바로 북극곰이 $O$와 $X$를 보면 $()$와 $)($로 찢어버린다는 것이다.


협이는 이러한 북극곰의 특성을 이용하여 길이 $N$의 괄호 문자열 $S$를 만들고자 한다. 북극곰은 낮에 활동을 하기 때문에 낮에 돌아다니는 것은 위험하다. 때문에 협이는 매일 밤마다 활동할 수 있다. 밤에 협이는 문자열이 있으면 그 위에 $O$ 또는 $X$를 원하는 만큼 놓을 수 있다. 그러면 낮에 북극곰이 와서 문자들을 모두 찢어 놓는다.


예를 들어 이미 문자열 $()()$가 있다고 생각해보자. 밤에 문자를 $(O)X(O)$ 다음과 같이 놓아둔다면 하루가 지나 $(()))((())$ 와 같은 문자열이 된다.


이때 원하는 문자열을 만들려면 최소 며칠이 걸리는지 계산해보자.","입력은 아래와 같이 주어진다.




$N$


$S$","원하는 문자열을 만들기 위해 걸리는 최소 일수를 구하라.


원하는 문자열을 만들 수 없다면 
-1
을 출력한다.","6
()()()

---

10
(()))((())

---

3
(()","1

---

2

---

-1",
3933,라그랑주의 네 제곱수 정리,Gold V,"양의 정수는 많아야 4개의 제곱수로 표현할 수 있다고 한다. 이 이론을 
라그랑주의 네 제곱수 정리
라고 한다. 이 정리는 조제프루이 라그랑주가 1770년에 증명했다.


우리는 이 이론을 증명하거나 새로운 이론을 발견할 필요는 없고, n이 주어졌을 때 4개 이하의 양의 제곱수의 합으로 n을 만들 수 있는 경우의 수를 구하려고 한다. 경우의 수를 구할 때 제곱수의 순서가 바뀌는 경우는 같은 경우로 본다. 따라서 3
2
 + 4
2
 과 4
2
 + 3
2
는 같은 경우이다.


N이 25일 때 4개 이하의 제곱수의 합으로 표현 할 수 있는 경우는 1
2
 + 2
2
 + 2
2
 + 4
2
, 3
2
 + 4
2
, 5
2
 이렇게 3가지이다.","입력은 최대 255줄이다. 각 줄에는 2
15
보다 작은 양의 정수가 하나씩 주어진다. 마지막 줄에는 0이 하나 있고, 입력 데이터가 아니다.",각 테스트 케이스에 대해서 입력으로 주어진 n을 많아야 4개의 제곱수로 나타내는 경우의 수를 출력한다.,"1
25
2003
211
20007
0","1
3
48
7
738",
1202,보석 도둑,Gold II,"세계적인 도둑 상덕이는 보석점을 털기로 결심했다.


상덕이가 털 보석점에는 보석이 총 N개 있다. 각 보석은 무게 M
i
와 가격 V
i
를 가지고 있다. 상덕이는 가방을 K개 가지고 있고, 각 가방에 담을 수 있는 최대 무게는 C
i
이다. 가방에는 최대 한 개의 보석만 넣을 수 있다.


상덕이가 훔칠 수 있는 보석의 최대 가격을 구하는 프로그램을 작성하시오.","첫째 줄에 N과 K가 주어진다. (1 ≤ N, K ≤ 300,000)


다음 N개 줄에는 각 보석의 정보 M
i
와 V
i
가 주어진다. (0 ≤ M
i
, V
i
 ≤ 1,000,000)


다음 K개 줄에는 가방에 담을 수 있는 최대 무게 C
i
가 주어진다. (1 ≤ C
i
 ≤ 100,000,000)


모든 숫자는 양의 정수이다.",첫째 줄에 상덕이가 훔칠 수 있는 보석 가격의 합의 최댓값을 출력한다.,"2 1
5 10
100 100
11

---

3 2
1 65
5 23
2 99
10
2","10

---

164","두 번째 예제의 경우 첫 번째 보석을 두 번째 가방에, 세 번째 보석을 첫 번째 가방에 넣으면 된다."
3641,호프집 선택,Platinum III,"20세기 중반에 사회학자들은 맥주에 관련된 학생들의 행동에 대한 연구를 시작했다. 연구의 가장 큰 성과는 학생들의 수업이 끝나고 난 이후에 호프집을 선택하는 복잡한 과정을 매우 정확하게 묘사하는 방법을 개발한 것이다.


학생들은 호프집을 투표를 통해서 결정한다. 사회학자들은 일부의 주도하는 학생들이 다른 학생들에게 눈치를 주는 점에 주목했다. 


호프집을 선택하는 과정은 다음과 같이 나타낼 수 있다.




주도하는 학생들은 각자 선호하는 호프집을 가지고 있다. 이 학생들은 항상 그 호프집에 표를 던진다. 주도적인 학생 여러 명이 같은 호프집에 표를 던질 수도 있다.


그 다음, 남은 학생들은 모두 주도적인 학생이 아니다. 이 학생들은 주도적인 학생들의 눈치를 보면서 확률적으로 투표를 하며. 그들이 어떤 특정 호프집에 투표를 할 확률은, 그 호프집이 그 때까지 받은 표의 수를 그 때 까지 투표한 사람의 수로 나눈 값이다.


모든 사람이 투표를 하게 되면, 가장 높은 표를 얻은 호프집이 선택된다. 만약, 가장 높은 표를 받은 호프집이 여러 개인 경우에는, 임의로 선택한다. (이때, 각 호프집을 선택할 확률은 모두 같다)




예를 들어, 학생이 일곱 명, 호프집이 세 개가 있고, 그 중 다섯 명이 주도적인 학생인 경우를 생각해보자. 세 학생이 1번 호프집에 표를 던지고, 나머지 학생이 각각 2번과 3번 호프집에 표를 던졌다고 하자. 이제 각 호프집이 받은 표의 수는 (3, 1, 1)이 된다.


이제 주도적이지 않은 학생 두 명이 투표를 해야 한다. 각 학생은 차례대로 투표를 한다. 먼저, 첫 번째 학생이 1번 호프집을 선택할 확률은 3/5, 2번과 3번을 선택할 확률은 1/5이다. 이 학생이 3번 호프집을 선택하면, 각 호프집이 받은 표의 수는 (3, 1, 2)가 된다.


두 번째 학생이 1번 호프집을 선택할 확률은 1/2, 2번 호프집은 1/6, 3번 호프집은 1/3이 된다. 이 학생은 3번 호프집을 선택했다고 하면, 각 호프집이 받은 표의 수는 (3, 1, 3)이 된다. 1번 호프집과 3번 호프집의 표가 같기 때문에, 두 호프집은 1/2의 확률로 선택을 받게 된다.


학생의 수와, 호프집의 수, 그리고 모든 주도적인 학생들이 선택한 호프집이 주어진다. 이때, 각 호프집을 갈 확률을 구하는 프로그램을 작성하시오.","입력은 여러 개의 테스트 케이스로 이루어져 있다.


각 테스트 케이스의 첫째 줄에는 맥주집의 수 n (n ≤ 5)과 학생의 수 k가 주어진다. (k ≤ 50) 둘째 줄에는 주도적인 학생의 투표가 끝난 후의 결과 a
1
, a
2
, ..., a
n
이 주어진다. 항상 \( k \ge \sum_{i=1}^{n}{a_i}\)를 만족한다.","각 테스트 케이스에 대해서, 각 맥주집이 선택받을 확률을 출력한다. 'pub i: percentage %'와 같이 출력하며, i는 맥주집의 번호, percentage는 그 맥주집을 선택할 확률을 반올림해서 소수점 둘째 자리까지 나타낸 값이다.","3 7
3 1 1","pub 1: 93.33 %
pub 2: 3.33 %
pub 3: 3.33 %",
16488,피카츄가 낸 어려운 문제,Silver IV,"맨날 학교 칠판에 이등변삼각형을 그리고 노는 피카츄가 어느 날, 칠판에 변 AB와 변 AC의 길이가 모두 
N
인 이등변 삼각형을 그린 다음, 친구들에게 아래와 같은 문제를 냈다.




이등변삼각형 ABC에서 변 BC 위에 점 P
1
, P
2
, ··· , P
K
을 잡는다. (B ≠ P
i
 ≠ C (i = 1, 2, ··· , 
K
))


i = 1, 2, ··· , 
K
에 대하여 함수 F(i)를 (선분 AP
i
의 길이)²+(선분 BP
i
의 길이)×(선분 CP
i
의 길이)로 정의한다.


이때, F(1)+F(2)+···+F(
K
)의 값은 얼마인지 구하시오.




피카츄의 친구들은 문제 조차도 이해를 못하고 있다! 우리가 대신해서 피카츄가 낸 문제를 해결해 보자.","첫째 줄에 
N
과 
K
의 값이 사이에 공백을 한 개 두고 차례대로 주어진다. 단, 
N
과 
K
는 100,000 이하의 양의 정수이다.","첫째 줄에 문제에서 요구하는 정답을 
x
라고 할 때, 
x
보다 크지 않은 최대의 정수를 출력한다.",4 7,112,
2676,라스칼 삼각형,Silver II,"라스칼의 삼각형은 파스칼의 삼각형과 비슷하다.


라스칼의 삼각형에서 가장 윗 줄은 0번 줄이다. i번째 줄에는 i+1개의 숫자가 들어있고, 차례대로 0번부터 i번이다. R(i,j)는 i번 줄의 j번째 숫자이다.


R(n,m) = 0 (n<0 or m<0 or m>n)


각 줄의 첫 번째와 마지막 숫자는 1이다.


R(n,0) = R(n,n) = 1


나머지 값을 채우는 방법은 (서쪽값 * 동쪽값 + 1) / 북쪽값 이다.




이것을 수식으로 표현해보면 R(n+1,m+1) = (R(n,m) * R(n,m+1) + 1) / R(n-1,m) 이다.


라스칼의 삼각형에서 R(n,m)을 구하는 프로그램을 작성하시오.","첫째 줄에 테스트 케이스의 개수 T(1 <= T <= 1,000)이 주어진다. 각 테스트 케이스는 2개의 숫자 n과 m으로 이루어져 있다. (0 <= m <= n <= 50,000)","각 테스트 케이스에 대해서 한 줄에 하나씩 R(n,m)을 출력한다.","5
4 0
4 2
45678 12345
12345 9876
34567 11398","1
5
411495886
24383845
264080263",
8462,배열의 힘,Platinum II,"자연수 \(n\)개로 이루어진 배열 \(a_1,a_2,a_3,\dots ,a_n\)이 있다.


\(l\)부터 \(r\)까지 부분 배열은 \(a_l,a_{l+1},\dots , a_r\) 이다.


\(K_s\)는 부분 배열 안에 있는 자연수 \(s\)의 개수이다.


부분 배열의 힘이란 모든 자연수 \(s\)에 대해서, \(K_s \cdot K_s \cdot s\)를 합한 값이다.


배열과 부분 배열의 범위가 주어졌을 때, 각 부분 배열의 힘을 구하는 프로그램을 작성하시오.","첫째 줄에 배열의 크기 \(n\)과 부분 배열의 개수 \(t\)가 주어진다. (1 ≤ \(n\), \(t\) ≤ 10
5
) 둘째 줄에는 \(n\)개의 자연수 \(a_i\) (1 ≤ \(a_i\) ≤ 10
6
) 가 주어진다.


다음 \(t\)개 줄에는 부분 배열의 범위 \(l_i\)와 \(r_i\)가 주어진다. (1 ≤ \(l_i\) ≤ \(r_i\) ≤ \(n\))",입력으로 주어지는 각 부분 배열의 힘을 출력한다.,"8 3
4 3 1 1 1 3 1 2
2 7
1 6
3 8","28
25
21",
29161,트리와 케이,Diamond IV,"$N$개의 정점으로 이루어진 트리(무방향 사이클이 없는 연결 그래프)가 있다. 정점은 $1$부터 $N$까지 번호가 매겨져 있고, 간선에는 가중치가 붙어 있다. 아래의 쿼리를 수행하는 프로그램을 작성하시오.




$x$ $d$: 정점 $x$로부터의 거리가 
정확히
 $d$인 정점의 번호를 모두 xor한 값을 출력한다.","첫째 줄에 $N$과 $M$이 공백을 사이에 두고 주어진다. $(1 \leq N, M \leq 200\,000)$


둘째 줄부터 $(N-1)$개의 줄에 걸쳐 $i$번째 간선이 연결하는 서로 다른 두 정점의 번호 $u_i$, $v_i$와 간선의 가중치 $w_i$가 공백으로 구분되어 주어진다. $(1 \leq u_i, v_i \leq N;$ $u_i \neq v_i;$ $1 \leq w_i \leq 1\,000\,000\,000)$


입력된 그래프가 트리임이 보장된다.


다음 $M$개의 줄에는 쿼리 정점 번호 $x_i$와 거리 $d_i$가 한 줄에 하나씩 공백으로 구분되어 주어진다. $(1 \leq x_i \leq N;$ $0 \leq d_i \leq 10^{15})$",각각의 쿼리의 결과를 순서대로 한 줄에 하나씩 출력한다.,"6 4
6 2 2
1 4 2
2 3 1
2 4 4
4 5 2
2 6
3 5
4 2
4 4

---

19 4
8 7 1
9 7 1
7 6 1
11 10 1
12 10 1
10 6 1
6 1 1
2 1 1
1 3 1
3 4 1
3 5 1
1 13 1
13 14 1
14 15 1
13 16 1
16 17 1
16 18 1
16 19 1
6 4
1 3
10 3
14 3","4
4
4
2

---

31
25
13
23",
24269,랜드마크 건설,Gold I,"BOJ 연방은 2022년을 맞아 신도시를 지으려고 한다. BOJ 연방의 건설가는 동서 방향과 남북 방향으로 길게 뻗어 격자 모양으로 교차하는 도로를 $8 \times 10^{8}$ 개씩 세웠으며, 인접한 두 교차로 사이의 거리는 $1$이다. 북쪽에서 $x$ 번째 도로와 동쪽에서 $y$ 번째 도로의 교차로는 $(x, y)$라고 부른다. 도로를 따라서는 동서 혹은 남북 방향으로만 이동할 수 있기 때문에, $(x, y)$에서 $(z, w)$까지의 거리는 $|x-z|+|y-w|$로 계산된다.


이제 랜드마크를 지어서 이 신도시의 완성을 기념하려고 한다. 연방의 초청을 받은 세 명의 예술가는 교차로를 하나씩 정해서 랜드마크를 건설하기로 했다. 각 랜드마크의 매력도 중요하지만, 랜드마크끼리의 조화도 빼놓을 수 없다. 세 랜드마크가 조화를 이루려면, 다음 조건을 모두 만족해야 한다.




첫 번째 랜드마크가 있는 교차로와 두 번째 랜드마크가 있는 교차로 사이의 거리는 $a$이다.


두 번째 랜드마크가 있는 교차로와 세 번째 랜드마크가 있는 교차로 사이의 거리는 $b$이다.


세 번째 랜드마크가 있는 교차로와 첫 번째 랜드마크가 있는 교차로 사이의 거리는 $c$이다.




세 랜드마크가 조화를 이룰 수 있도록 각 랜드마크를 짓는 교차로의 위치를 정해주자.","입력은 $T$개의 테스트 케이스로 이루어져 있다.


첫 번째 줄에 전체 테스트 케이스의 개수를 나타내는 정수 $T$가 주어진다.


이후 $T$ 개의 줄에 랜드마크 사이의 거리를 나타내는 세 개의 정수 $a$, $b$, $c$가 공백으로 구분되어 한 줄에 주어진다.","$T$ 개의 줄에 걸쳐 한 줄에 하나씩 문제의 답을 출력해야 한다.


세 랜드마크가 조화를 이룰 수 있다면, 여섯 개의 정수 $x_1$, $y_1$, $x_2$, $y_2$, $x_3$, $y_3$를 공백으로 구분하여 출력한다. 이는 첫 번째, 두 번째, 세 번째 랜드마크를 각각 $(x_1, y_1)$; $(x_2, y_2)$; $(x_3, y_3)$에 건설한다는 의미이다. 답이 여러 가지가 가능하다면 그 중 하나를 출력하라.


세 랜드마크가 조화를 이룰 수 없다면, $-1$을 출력한다.","2
1 2 3
1 1 10","1 3 1 4 2 5
-1",
3351,삼각 분할,Platinum I,"계산기하 분야에서 삼각분할은, 다음과 같은 조건을 만족하는 삼각형의 집합을 뜻한다.




삼각형의 각 꼭짓점은 다각형에 있는 꼭짓점 중 하나이다.


삼각형끼리는 겹쳐서 안되며, 삼각형들의 합집합은 다각형과 동일하다.




볼록 다각형이라 함은. 다각형 내부의 내각이 모두 180도 미만인, 변이 3개 이상인 도형을 뜻한다.


볼록 다각형이 주어졌을 때, 우리는 이 볼록 다각형을 두개의 볼록 다각형으로 분할하는 직선을 다각형의 절단선이라고 정의한다.


삼각분할된 볼록다각형이 주어지며, 각각의 삼각분할된 삼각형들은 내부가 주어진 색상 C
i
로 칠해져 있다. 다각형 내부의 임의의 색상이 같은 점 쌍이, 다른 조각으로 분할되는 일이 없도록 최대한 많은 절단선을 그었을 때, 몇개의 절단선을 그을 수 있는가?","첫 번째 줄에 다각형의 정점 수 n이 주어진다. (3 ≤ n ≤ 100,000)


이후 n-2개의 줄에 분할된 삼각형의 정보가 네 정수 a b c d 형태로 주어진다. 이는 주어진 삼각형이 다각형의 정점 a, b, c를 세 꼭짓점으로 하며, 내부가 d라는 색상으로 칠해져 있음을 뜻한다. (1 ≤ a, b, c, d ≤ n)


입력으로 주어진 다각형은 문제에서 주어진 조건을 만족한다.",다각형을 분할하는 최대의 절단선의 개수를 출력한다.,"5
1 2 3 2
4 5 1 1
3 1 4 2

---

6
1 4 2 1
2 4 5 2
6 2 5 3
3 6 5 1","1

---

0",
10729,업적의 노예 1,Platinum V,"경근이는 요즘 isRPG라는 웹게임을 열심히 하고 있다. 제목에 RPG가 들어가 있으니 알 수 있겠지만, 이 게임에는 캐릭터가 사용할 수 있는 많은 장비 아이템들이 있다. 모든 장비는 주어진 방법을 따라 재료를 모아 만들고, 만들어진 장비의 옵션은 정해진 범위 내에서 무작위하게 결정된다. 만약 만들어진 장비가 마음에 들지 않는다면 장비를 해체하여 사용한 재료를 일부분 돌려받을 수 있다.


isRPG에는 요즈음의 많은 게임이 그러하듯 업적이라는 시스템이 있어서 어떤 항목에 대해 일정 수치를 달성하게 되면 업적을 달성할 수 있다. 경근이가 현재 관심 있어 하는 항목은 ""특정 개수 이상의 장비 제작하기""와 ""특정 개수 이상의 장비 분해하기""이다.


현재 isRPG에서 가장 쉽게 제작할 수 있는 아이템의 최고봉은 나무 단검이다. 나무 단검의 재료는 나무 쪼가리 한 종류뿐이며, 이는 상점에서 쉽게 구매할 수 있기 때문이다. 업적을 달성하는 것과 제작하는 아이템의 질은 아무런 상관이 없으므로 경근이는 나무 단검을 많이많이 깎으려고 한다!


나무 쪼가리 \(N\)개를 소모하면 나무 단검 하나를 제작할 수 있다. 나무 단검 하나를 분해하면 나무 쪼가리를 적으면 \(0\)개, 많으면 \(K\)개까지 돌려받을 수 있다. 이때 나무 쪼가리를 \(x\) (\(0 \leq x \leq K\))개 돌려받을 확률은, \(x\)의 값과 상관 없이, 모든 \(x\)에 대해 \(1/(K+1)\)이다.


보물을 가진 용들을 많이많이 죽여서 많은 전리품을 얻은 경근이는 상점에서 나무 쪼가리를 \(M\)개 구입했다. 현재 경근이는 나무 단검을 하나도 가지고 있지 않다. 경근이는 이제부터 나무 쪼가리로 나무 단검을 하나도 만들 수 없을 때까지 제작하고, 가지고 있는 나무 단검을 모두 분해하는 작업을 반복하려고 한다. 경근이는 수많은 경험을 통해, 모든 작업이 끝난 후에 나무 쪼가리가 인벤토리 창에 남아 있는 것은 매우 불쾌한 일이라는 것을 잘 알고 있다. 그러므로 경근이는 모든 작업이 끝난 후 나무 쪼가리가 0개 남을 확률이 얼마인지 알고 싶어 한다. 이런 생각을 하고 나니 더 나아가 나무쪼가리가 \(i\) (\(0 \leq i < N\))개 남을 확률도 알고 싶어졌다. 경근이를 도와주자!","첫 번째 줄에 나무 단검 하나를 만드는 데 필요한 나무 쪼가리의 개수 \(N\), 나무 단검 하나를 분해했을 때 얻을 수 있는 나무 쪼가리의 최대 개수 \(K\) (\( 1 \leq K < N \leq 10^3\)), 현재 경근이가 가지고 있는 나무 쪼가리의 개수 \(M\)이 공백을 사이로 두고 주어진다.


이 문제는 세 개의 부분 문제로 이루어져 있다.


1번 문제
의 입력은 \(0 \leq M \leq 10^{6}\)을 만족하며 해결하면 10점을 얻을 수 있다.


2번 문제
의 입력은 \(0 \leq M \leq 10^{12}\)을 만족하며 해결하면 40점을 얻을 수 있다.


3번 문제
의 입력은 \(M = -1\)을 만족하며 해결하면 50점을 얻을 수 있다. 이 부분 문제는 앞의 문제와는 다르게 \(M = -1\)인데, 이는 \(M\)이 무한대로 수렴할 때의 확률의 극한값을 정답으로 구해야 함을 의미한다. 이 극한값이 존재하며 유리수라는 사실은 증명되어 있다.","\(i\)번째 줄에는 나무 쪼가리가 \(i-1\)개 남을 확률을 출력한다. 나무 쪼가리는 \(N-1\)개 이하만큼 남게 될 것이므로, 출력은 \(N\)줄이어야 한다.


좀더 정확하게 판별하기 위해, 확률을 기약분수로 \( {p}\over{q} \)로 나타냈을 때, \(p-qr \equiv 0 \pmod{1,000,000,007} \)을 만족하는 \(0\) 이상 \(1,000,000,007\) 미만의 정수 \(r\)을 출력해야 한다. 이 정수 \(r\)이 존재하며, 이 범위 내에서 유일하다는 사실은 증명되어 있다.",4 2 4,"333333336
333333336
333333336
0","순서대로 \( \frac{1}{3} \),\( \frac{1}{3} \),\( \frac{1}{3} \),\( 0 \)을 의미한다."
25426,일차함수들,Silver IV,"$f(x) = ax + b$형태의 일차함수가 $N$개 있다. $i$번째 함수는 $f_i(x) = {a_i}x + {b_i}$로 표현된다.


이 함수들 각각의 $x$에 $1$부터 $N$까지의 서로 다른 정수 $N$개를 하나씩 대입하여 만들 수 있는 $f(x)$들의 합의 최댓값을 구해보자.


구체적으로는, 길이 $N$의 순열 $x_1, x_2, ... x_N$을 적절히 정해 $\sum_{i=1}^N {a_i}{x_i}+{b_i}$의 값을 최대화하여라.","첫째 줄에 일차함수의 개수 $N$이 주어진다. $(1≤N≤100,000)$


둘째 줄부터 $N$줄에 걸쳐 $i$번째 일차함수를 나타내는 두 정수 $a_i, b_i$가 공백으로 구분되어 입력된다.  $(0≤a_i, b_i≤ 10^9)$",첫째 줄에 문제의 답을 출력한다.,"5
2 4
5 1
3 2
1 10
0 0",62,
12923,별 모으기,Platinum V,"Alice는 최근에 나온 새로운 모바일 게임에 푹 빠져 있다. 이 게임은 총 N개의 스테이지로 구성되어 있고, 각 스테이지마다 2개씩의 별을 모을 수 있다. 그러나, 별을 모으는 것은 점점 어려워지기 때문에, 모은 별을 이용해 장비를 충분히 강화해야 어려운 스테이지들에 도전할 수 있다.


보다 공식적으로 정리하자면, 별을 모으는 방법은 다음과 같다.




아직 하나의 별도 얻지 못한 스테이지 i를 a
i
개 이상의 별을 모은 상태에서 도전한다면, 해당 스테이지에서 1개의 별을 얻을 수 있다.


아직 하나의 별도 얻지 못한 스테이지 i를 b
i
개 이상의 별을 모은 상태에서 도전한다면, 해당 스테이지에서 2개의 별을 얻을 수 있다.


이미 1개의 별을 얻은 스테이지 i를 b
i
개 이상의 별을 모은 상태에서 도전한다면, 해당 스테이지에서 1개의 별을 얻을 수 있다.




Alice는 최소 횟수만 플레이해서 이 게임의 모든 별을 모으고 싶어한다. Alice가 그것을 성공할 수 있는지, 만약 성공할 수 있다면 몇 번이나 스테이지를 클리어해야 하는지 출력하시오.","첫 번째 줄에는 스테이지의 개수 N (1 ≤ N ≤ 1000)이 입력으로 주어진다.


다음 N개의 줄에는 각 스테이지의 정보를 나타내는 두 자연수 a
i
와 b
i
가 주어진다. (0 ≤ a
i 
≤ b
i 
≤ 2001)","만약 Alice가 모든 스테이지를 클리어할 수 있다면, 스테이지를 클리어하는 총 횟수를 출력한다.


모든 스테이지를 클리어하는 것이 불가능하다면, “Too Bad”를 출력한다.","2
0 1
0 2

---

3
2 2
0 0
4 4

---

1
1 1","3

---

3

---

Too Bad","예제 1에서는 스테이지 2 => 스테이지 1 => 스테이지 2 순서로 클리어하면 모든 별을 얻는다.


예제 2에서는 스테이지 2 => 스테이지 1 => 스테이지 3 순서로 클리어하면 모든 별을 얻는다.


예제 3에서는 스테이지 1에서 처음부터 한 개의 별도 얻을 수 없으므로, 불가능하다."
10757,큰 수 A+B,Bronze V,"두 정수 A와 B를 입력받은 다음, A+B를 출력하는 프로그램을 작성하시오.","첫째 줄에 A와 B가 주어진다. (0 < A,B < 10
10000
)",첫째 줄에 A+B를 출력한다.,9223372036854775807 9223372036854775808,18446744073709551615,
24398,알고리즘 수업 - 선택 알고리즘 1,Silver V,"오늘도 서준이는 선택 알고리즘 수업 조교를 하고 있다. 아빠가 수업한 내용을 학생들이 잘 이해했는지 문제를 통해서 확인해보자.


N
개의 서로 다른 양의 정수가 규칙 없이 저장된 배열 A가 있다. 평균 선형 시간 선택 알고리즘으로 배열 A에서 
Q 
번째 작은 원소를 찾는 경우 
K 
번째 교환되는 수를 구해서 우리 서준이를 도와주자.


크기가 
N
인 배열에 대한 평균 선형 시간 선택 알고리즘 의사 코드는 다음과 같다.



select(A[], p, r, q) { # A[p..r]에서 q번째 작은 원소를 찾는다.
    if (p = r) then return A[p];
    t <- partition(A, p, r);  # 분할
    k <- t - p + 1;           # 기준원소가 전체에서 k번째 작은 원소임
    if (q < k) then return select(A, p, t - 1, q);  # 왼쪽 그룹으로 범위를 좁힘
    else if (q = k) then return A[t];               # 기준원소가 찾는 원소임
    else return select(A, t + 1, r, q - k);         # 오른쪽 그룹으로 범위를 좁힘
}

partition(A[], p, r) {
    x <- A[r];    # 기준원소
    i <- p - 1;   # i는 x보다 작거나 같은 원소들의 끝 지점
    for j <- p to r - 1  # j는 아직 정해지지 않은 원소들의 시작 지점
        if (A[j] ≤ x) then A[++i] <-> A[j]; # i값 증가 후 A[i] <-> A[j] 교환
    if (i + 1 ≠ r) then A[i + 1] <-> A[r];  # i + 1과 r이 서로 다르면 A[i + 1]과 A[r]을 교환
    return i + 1;
}","첫째 줄에 배열 A의 크기 
N
(5 ≤ 
N
 ≤ 10,000), 찾을 원소 정보 
Q
(1 ≤ 
Q
 ≤ 
N
), 교환 횟수 
K
(1 ≤ 
K
 ≤ 10
8
)가 주어진다.


다음 줄에 서로 다른 배열 A의 원소 
A
1
, 
A
2
, ..., 
A
N
이 주어진다. (1 ≤ 
A
i
 ≤ 10
9
)","K 
번째 교환되는 두 개의 수를 작은 수부터 한 줄에 출력한다. 교환 횟수가 
K 
보다 작으면 -1을 출력한다.","5 3 1
2 5 1 4 3

---

5 3 2
2 5 1 4 3

---

5 3 10
2 5 1 4 3","2 2

---

1 5

---

-1",
16504,종이접기,Bronze III,"종이접기와 수학을 좋아하는 주성이는 종이접기와 수학을 한꺼번에 할 수 있는 놀이를 찾아냈다. 바로 
N×N
 크기를 가지는 색종이의 각 칸에 수를 적어놓고, 색종이를 반으로 접을 때마다 겹치는 부분의 수들을 더하는 것이다. 그리고 이 작업을 색종이를 더는 접을 수 없을 때까지 반복했을 때, 가장 마지막에 남는 수를 구하는 놀이이다.


아래의 예시는 위에서 설명한 놀이의 과정을 2×2 크기의 색종이를 사용하여 상세하게 나타낸 그림이다.






색종이를 
왼쪽
에서 
오른쪽
으로 정확히 반을 접는다.


겹치는 두 칸에 있는 수를 서로 더한다. 위 그림에서는 (1, 1)과 (1, 2)의 두 칸이 겹치고, (2, 1)과 (2, 2)의 두 칸도 겹치는 부분이다.


더한 값을 색종이 위에 다시 적는다.








색종이를 
아래쪽
에서 
위쪽
으로 정확히 반을 접는다.


겹치는 두 칸에 있는 수를 서로 더한다. 위 그림에서는 (1, 1)과 (2, 1)의 두 칸이 겹치는 부분이다.


더한 값을 색종이 위에 다시 적는다.




색종이를 반으로 접으면서 두꺼워지는 것을 고려하지 않고, 색종이를 더는 접을 수 없을 때까지 위 과정을 반복했을 때 가장 마지막에 남는 수를 구하여라.","첫 번째 줄에는 색종이의 가로, 세로 길이를 의미하는 정수 
N
 (
N
 = 2
m
, 1 ≤ 
m
 ≤ 10)이 주어진다.


두 번째 줄부터 마지막 줄까지는 
N×N
 크기의 색종이 정보가 주어지며, 색종이의 각 칸에는 정수 
K
 (1 ≤ 
K
 ≤ 100,000)가 주어진다.","색종이를 반으로 접으면서 겹치는 부분의 수들을 더하는 과정을 반복했을 때, 가장 마지막에 남는 수를 출력한다.","4
2 6 5 4
1 5 7 6
9 8 8 7
1 4 7 8",88,
1542,체스 연습,Platinum I,"세준이와 다솜이는 체스를 취미로 즐긴다. 하지만, 이제 국가대표가 되어야겠다는 목표로 오늘부터 연습을 하려고 한다. 오늘은 100×100크기의 체스판에서 퀸만 가지고 공격 기술을 연습하려고 한다.


체스판 위에는 퀸이 N개 올려져 있다. 이 연습은 세준이 먼저, 그다음에 다솜이, 그리고 다시 세준이와 같이 턴을 번갈아 가면서 진행된다.


하나의 턴에 하나의 퀸을 고른 후, 옮긴다. 만약 퀸이 (x,y)에 있었다면, 퀸은 (x-k,y), (x,y-k), (x-k,y-k)중에 하나로 옮길 수 있다. (k>0) 그리고, 퀸은 다른 퀸이 있는 칸을 통과 할 수도 있고, 한 칸에 여러 퀸이 있을 수도 있다.


이 연습은 (0,0)에 퀸을 하나라도 먼저 놓는 사람이 이긴다. 세준이와 다솜이가 항상 최적의 방법으로 연습한다고 가정할 때, 승자를 출력하는 프로그램을 작성하시오.","5개의 게임이 입력으로 들어오며, 각각의 게임은 다음과 같이 구성되어 있다. 첫째 줄에는 체스판 위에 있는 퀸의 개수 N이 주어진다. 이 값은 50보다 작거나 같다. 둘째 줄부터 N개의 줄에는 퀸의 위치가 X Y의 순서로 들어온다. 퀸이 (0, 0)에 있는 경우는 없다.","각 게임의 승자가 세준이면 S, 다솜이면 D를 출력한다.","2
3 3
4 5
1
1 2
4
5 8
7 3
3 7
5 8
2
1 3
2 3
3
3 2
4 2
3 1","S
D
D
S
D",
3104,쿠키,Diamond IV,"해빈이와 준규는 쿠키를 좋아하는 쌍둥이 형제이다. 두 사람의 친구 진욱이는 해빈이와 준규에게 쿠키를 만들어주는 것을 세상에서 가장 좋아한다. 하지만, 진욱이는 두 사람이 쿠키를 너무 빨리 먹는다면서 불평한다. 오늘은 두 사람에게 쿠키를 천천히 먹는 방법을 게임을 통해 가르치려고 한다.


진욱이가 구운 쿠키의 수는 N개이고, 각각 1번부터 N번까지 번호가 매겨져 있다. 쿠키는 원형으로 배치되어 있고, i번 쿠키는 i-1번과 i+1번 쿠키 사이에 있다. 1번과 N번 쿠키는 서로 이웃이다.


쿠키는 총 26가지 맛이 있다. 진욱이는 각 맛을 알파벳 소문자 'a'부터 'z'까지로 나타낸다. 같은 알파벳을 가지는 맛은 동일하다.


해빈이와 준규는 쿠기를 5분에 하나씩 먹을 수 있다. 진욱이는 숫자 하나를 크게 외치면, 두 사람은 그 쿠키와 이웃한 쿠키를 먹게 된다. 이 게임은 남은 쿠키의 개수가 1개 또는 2개일때까지 계속되며, 게임이 끝난 후 남은 쿠키는 진욱이가 먹는다.




게임은 길이가 (N-1) div 2인 수열로 나타낼 수 있다. 수열의 원소는 진욱이가 외친 숫자이다. 예를 들어, 위의 그림에서 수열은 (4, 8, 6)이 된다. 수열을 이루고 있는 숫자가 다른 경우에 두 게임은 다르다고 한다.


게임을 몇 번 진행한 후에 진욱이는 해빈이와 준규가 게임 도중에 싸운다는 사실을 알아냈다. 이웃한 쿠키가 서로 다른 맛을 가진 경우에는 두 사람이 싸우게 된다.


진욱이는 두 사람을 싸우지 않게 하면서 게임을 진행하려고 한다.


쿠키 N개의 맛이 주어졌을 때, 두 사람을 싸우지 않게 하면서 게임을 진행하는 방법의 수를 구하는 프로그램을 작성하시오. 방법의 수가 매우 클 수 있기 때문에, 10,007로 나눈 나머지를 출력한다.",첫째 줄에 쿠키의 수 N(3 ≤ N ≤ 100)이 주어진다. 둘째 줄에는 쿠키의 맛이 순서대로 주어진다.,해빈이와 준규가 싸우지 않게 하면서 게임을 진행하는 방법의 수를 10007로 나눈 나머지를 출력한다.,"8
cibaboca

---

5
aabab

---

11
fffffffffff","4

---

5

---

388",
17636,가로등,Diamond II,"이노폴리스에서는 자율 주행 택시가 운행하고 있다. 이 도시의 도로망은 n + 1개의 택시를 탈 수 있는 정류 장과 이들을 잇는 n개의 도로로 이루어져 있다. 도로 하나마다 가로등이 있다. i 번 가로등이 켜져 있다면, 정류장 i와 정류장 i + 1를 잇는 도로를 밝힌다. 만약 꺼져 있다면, 이 도로는 어둡다.


보안 문제로, 자율 주행 택시는 가로등이 켜진 도로만 달릴 수 있다. 다른 말로 하면, 택시가 정류장 a에서 정류장 b로 가려면 (a < b), 정류장 a과 정류장 a + 1를 잇는 도로, 정류장 a + 1과 정류장 a + 2를 잇는 도로, . . . , 정류장 b − 1과 정류장 b를 잇는 도로의 가로등이 켜져야 한다.


고장이 나거나, 수리를 하면 가로등이 켜지거나 꺼질 수 있다.


시점 0에서는 가로등의 초기 상황이 주어진다. 1, 2, . . . , q 시간이 지나면 다음 두 상황 중 하나가 벌어질 수 있다.




“
toggle i
” — i 번 가로등이 반전된다. 즉, 이 가로등이 켜져 있었다면 꺼지고, 꺼져 있었다면 켜진다.


“
query a b
” — 자율 주행 택시를 운영하는 곳의 대표가 다음을 궁금해한다. 시점 0에서 시작해서 현재에 이르기 까지 자율 주행 택시가 정류장 a에서 정류장 b까지 운행할 수 있었던 총 시간은 얼마일까?




자율 주행 택시를 운영하는 곳이 이 질의를 답하는 것을 도와주자","첫 번째 줄에는 두 정수 n, q가 주어진다. (1 ≤ n, q ≤ 300 000) — 이는 가로등의 수와 이벤트의 개수이다.


두번째 줄에는 최초의 가로등 상태를 알려주는 문자열 s가 주어진다. (|s| = n), 만약 가로등 i가 켜져 있으면 s
i
는 ‘1’이고, 가로등 i가 꺼져 있으면 s
i
는 ‘0’이다.


다음 q 줄 각각은 이벤트를 설명한다. 이 중 i 번째 줄은 i 시간이 지났을 때 이벤트를 설명한다.




“
toggle i
” (1 ≤ i ≤ n) — 가로등 i이 반전된다.


“
query a b
” (1 ≤ a < b ≤ n + 1) — 정류장 a에서 정류장 b까지 자율 주행 택시가 운행할 수 있었던 총 시간 수를 계산한다.




이벤트 중 최소 하나는 
query
이다.","각각의 
query
 이벤트마다 하나의 정수를 출력하고, 이 수는 질의에 대한 답이다.","5 7
11011
query 1 2
query 1 2
query 1 6
query 3 4
toggle 3
query 3 4
query 1 6","1
2
0
0
1
2","예제 입력의 결과는 다음과 같다.








시간


가로등 상태


이벤트


응답










1


11011


 


 






 


 


query 1 2


1






2


11011


 


 






 


 


query 1 2


1 and 2






3


11011


 


 






 


 


query 1 6


None






4


11011


 


 






 


 


query 3 4


None






5


11011


 


 






 


 


toggle 3


 






6


11111


 


 






 


 


query 3 4


6






7


11111


 


 






 


 


query 1 6


6 and 7"
28276,Yawned-Zoned,Platinum IV,"정원이는 학교에서 수업을 하다가 신기한 경험을 하였다. 한 학생이 졸려서 하품을 하자 주변에 있는 학생들이 따라서 하품을 하기 시작한 것이다. 정원이가 수업하는 강의실은 $R$줄에 걸쳐 가로로 $C$개의 좌석이 격자 모양으로 배치되어 일부 칸에 학생들이 앉아있다. 한 학생이 하품을 하면 그 학생의 한 칸 앞, 한 칸 왼쪽, 한 칸 오른쪽, 한 칸 뒤쪽 자리에 앉아있는 학생이 새로 하품을 하게 된다. 이미 하품을 한 학생은 다시 하품을 하지 않는다.


학생 한 명이 하품을 하더라도 시간이 지나면 많은 학생들이 하품을 한다. 너무 많은 학생이 한 번에 하품을 하면 수업에 크게 방해되기 때문에 정원이는 세로로 칸막이를 설치하려고 한다. 칸막이는 좌석의 $i$($1 \leq i < C$)번째 열과 $i+1$번째 열 사이에 설치할 수 있으며 칸막이는 매우 길기 때문에 맨 앞부터 맨 뒤까지 모두 막도록 설치해야 한다.


두 학생 사이에 칸막이가 설치되어 있다면 한 학생이 하품을 하더라도 다른 학생으로 하품이 전파되지 않는다. 이 점을 이용하여 정원이는 칸막이를 $W$개 설치하여 학생 한 명의 하품했을 때 추가로 하품을 하는 학생의 수의 최댓값이 최소화되도록 하고 싶다. 정원이를 도와 칸막이를 설치하는 프로그램을 작성하여라.","첫 번째 줄에 강의실의 세로 크기 $R$, 가로 크기 $C$, 칸막이의 수 $W$가 주어진다.


두 번째 줄부터 $R$개의 줄에는 강의실의 정보를 나타내는 길이 $C$의 숫자열이 주어진다. $i$번째 숫자열의 $j$번째 값은 앞에서부터 $i$번째, 왼쪽으로부터 $j$번째 좌석에 학생이 있으면 
1
이고 없으면 
0
이다.",정원이가 칸막이 $W$개를 적절히 배치했을 때 한 번에 하품을 하는 학생 수의 최댓값을 출력한다.,"2 5 0
11011
01101

---

3 6 2
110011
011110
110011","4

---

5",
15975,화살표 그리기,Silver III,"직선위에 $N$개의 점들이 주어지고 각 점은 $N$개의 색깔 중 하나를 가진다. 편의상, 색깔은 1부터 $N$까지의 수로 표시 하고, 점들의 좌표는 모두 다르다.


각 점 $p$에 대해서, $p$에서 시작하는 직선 화살표를 이용해서 다른 점 $q$에 연결하려고 한다. 여기서, 점 $q$는 $p$와 같은 색깔의 점들 중 $p$와 거리가 가장 가까운 점이어야 한다. 만약 가장 가까운 점이 두 개 이상이면 아무거나 하나를 선택한다.


각 점 $p$에서 시작하여 위 조건을 만족하는 $q$로 가는 하나의 화살표 $\vec{\ell_{p}}$를 그린다. 특별히 점 $p$에 대해서 수평선 상에 같은 색깔의 다른 점이 없다면 $\left|\vec{\ell_{p}}\right|=0$. 여기서 $\left|\vec{\ell_{p}}\right|$는 화살표 $\vec{\ell_{p}}$의 길이를 나타낸다.


예를 들어, 점들을 순서쌍 (좌표, 색깔) 로 표시할 때, $p_1$ = (0, 1), $p_2$ = (1, 2), $p_3$ = (3, 1), $p_4$ = (4, 1)라고 하자. 점 $p_1$의 화살표 $\left|\vec{\ell_{p_1}}\right|$은 $p_1\rightarrow p_3$ 로 연결된다. 점 $p_3$과 $p_4$의 화살표 $\left|\vec{\ell_{p_3}}\right|$과 $\left|\vec{\ell_{p_4}}\right|$는 각각 $p_3\rightarrow p_4$와 $p_4\rightarrow p_3$로 연결된다. 점 $p_2$의 경우는 같은 색깔의 다른 점이 존재하지 않는다. 따라서 모든 화살표들의 길이 합은 $\left|\vec{\ell_{p_1}}\right|+\left|\vec{\ell_{p_2}}\right|+\left|\vec{\ell_{p_3}}\right|+\left|\vec{\ell_{p_4}}\right|=3+0+1+1=5$이다.


점들의 좌표와 색깔이 주어질 때, 모든 점에서 시작하는 화살표들의 길이 합, 다시 말해서, $\displaystyle\sum_{p}\left|\vec{\ell_{p}}\right|$을 출력하는 프로그램을 작성하시오.",표준 입력으로 다음 정보가 주어진다. 첫 번째 줄에는 점들의 개수를 나타내는 정수 $N$이 주어진다. 다음 $N$개의 줄 각각에는 점의 좌표와 색깔을 나타내는 두 정수 $x$와 $y$가 주어진다.,표준 출력으로 모든 점에서 시작하는 화살표들의 길이 합을 출력한다.,"4
0 1
1 2
3 1
4 1

---

4
1 1
0 2
4 3
3 4

---

9
10 2
11 3
20 2
22 1
25 1
0 1
4 2
5 2
7 2","5

---

0

---

45",
1897,토달기,Gold V,"희현이는 원장선생님 말씀에 토를 다는 것을 몹시 좋아한다. 토를 단다는 것은 원장선생님께서 어떤 단어를 말씀하시면 그 단어의 맨 앞이나 중간, 혹은 맨 뒤에 한 글자를 끼워 넣어서 새로운 단어를 만드는 것으로, 버릇없는 행동과는 아무런 관계가 없는 순수한 단어 놀이이다.


희현이는 사전에 등재된 단어만을 사용한다. 사전은 d개의 단어로 구성되어 있으며, 각 단어는 80자 이내의 알파벳 소문자로만 이루어져 있다. 희현이는 원장선생님께서 어떤 단어를 말씀하셨을 때, 한 글자씩 토를 달아 사전에 등재된 단어를 계속 만들어 갈 경우, 가장 긴 단어를 만들려면 어떻게 해야 하는지가 궁금해졌다. 이를 해결하는 프로그램을 작성하라.","첫 줄에 사전에 등재된 단어의 수 d와, 원장님이 처음 말씀하신 단어가 주어진다. (1 ≤ d ≤ 1,000) 원장님이 처음 말씀하신 단어의 길이는 세 글자이며, 사전에 있는 단어를 말씀하셨다. 다음 d개의 줄에는 사전에 등재된 단어가 한 줄에 하나씩 주어진다.","첫 줄에 토달기 규칙을 지키며 단어를 만들어 갈 때, 만들 수 있는 단어 중 가장 긴 것을 출력한다. 답이 여럿일 경우 어느 것이나 상관없다.","9 cal
cal
calf
calfs
call
calls
choral
chorale
coal
coral",chorale,"cal, coal, coral, choral, chorale 순으로 단어를 만들어 나가면 된다."
1206,사람의 수,Gold V,"송유진은 길거리에서 사람들에게 설문조사를 하고 있다. 설문조사에는 N개의 문항이 있고, 설문에 응한 사람은 각 문항을 0보다 크거나 같고, 10보다 작거나 같은 정수로 대답해야 한다.


설문조사를 모두 마친 후 유진이는 각 문항의 평균 점수 소수점 셋째 자리에서 자른 값을 보고서 종이에 적고 사무실로 돌아왔다. 예를 들어, 어떤 문항에 각 사람이 점수를 4, 6, 10점으로 대답했다면, 평균 점수는 6.666이다. 이제 설문조사 결과를 보고해야 하는데, 문제가 하나 생겼다. 평균 점수만 알고 있기 때문에, 설문조사에 참여한 사람의 수를 알 수 없다는 점이다.


각 문항의 평균 점수가 주어진다. 이때 설문조사에 참여한 사람의 수를 구해보자.","첫째 줄에 N이 주어진다. 둘째 줄부터 N개의 줄에 각 문항의 평균 점수가 주어진다. N은 50보다 작거나 같은 자연수이고, 평균 점수는 0보다 크거나 같고, 10보다 작거나 같은 소수이다. 항상 소수점 셋째자리 까지 주어진다.","첫째 줄에 설문조사에 참여한 사람의 수를 출력한다. 만약, 가능한 정답이 여러가지라면, 가장 작은 값을 출력한다.","3
0.500
0.250
0.125

---

1
0.000

---

2
0.500
0.300

---

2
0.500
0.301","8

---

1

---

10

---

106",
7682,틱택토,Gold V,"틱택토 게임은 두 명의 사람이 번갈아가며 말을 놓는 게임이다. 게임판은 3×3 격자판이며, 처음에는 비어 있다. 두 사람은 각각 X 또는 O 말을 번갈아가며 놓는데, 반드시 첫 번째 사람이 X를 놓고 두 번째 사람이 O를 놓는다. 어느 때든지 한 사람의 말이 가로, 세로, 대각선 방향으로 3칸을 잇는 데 성공하면 게임은 즉시 끝난다. 게임판이 가득 차도 게임은 끝난다.


게임판의 상태가 주어지면, 그 상태가 틱택토 게임에서 발생할 수 있는 최종 상태인지를 판별하시오.","입력은 여러 개의 테스트 케이스로 이루어져 있다. 각 줄은 9개의 문자를 포함하며, 'X', 'O', '.' 중 하나이다. '.'은 빈칸을 의미하며, 9개의 문자는 게임판에서 제일 윗 줄 왼쪽부터의 순서이다. 입력의 마지막에는 문자열 ""end""가 주어진다.","각 테스트 케이스마다 한 줄에 정답을 출력한다. 가능할 경우 ""valid"", 불가능할 경우 ""invalid""를 출력한다.","XXXOO.XXX
XOXOXOXOX
OXOXOXOXO
XXOOOXXOX
XO.OX...X
.XXX.XOOO
X.OO..X..
OOXXXOOXO
end","invalid
valid
invalid
valid
valid
invalid
invalid
invalid",
14610,좋은 대회,Gold IV,"대회를 열기 위해서는 굉장히 많은 요소들을 고려해야한다. 그리고 현정이는 어떤 의미로나 좋지 못한 대회를 만드는 것으로 유명하다. 문제 부분에 관해서도, 좋은 대회라고 생각되는 기준을 한 번도 만족해본 적이 없다. 현정이가 만들고 싶은 좋은 대회란 다음 세가지 조건을 모두 만족하는 대회를 말한다.




모든 참가자가 한 문제 이상을 풀어야 한다.


모든 문제는 한 명 이상의 참가자에게 풀려야 한다.


모든 문제를 푼 참가자는 없어야 한다.




이런저런 경험을 겪으며 현정이는 이번에야말로 좋은 대회를 만들어내기 위해 모든 것을 바쳤다. 하지만 너무 많은 것을 바쳤는지 대회가 끝나기 전에 쓰러져버렸다. 눈을 뜬 현정이는 가장 먼저 대회 결과를 보고 이번 대회가 좋은 대회였는지를 알고싶어했다.


서둘러 대회 홈페이지에 접속한 현정이는 대회 결과를 나타내는 스코어보드를 찾아냈다. 하지만 현정이의 노트북은 모니터의 오른쪽 상단이 삼각형 모양으로 깨져있어 전체 스코어보드의 모습을 보지 못했다.




스코어보드는 더 많은 문제를 맞춘 참가자가 더 순위가 높고, 1등이 가장 위에 위치해 순위대로 정렬되어있는 형태다. 현정이의 모니터는 ◥ 모양으로 깨져있기 때문에 볼 수 있는 스코어보드의 형태는 아래 규칙을 모두 만족한다.




i 등 참가자의 x 번 문제 결과를 볼 수 있다면 (i+1) ~ N등 참가자의 x번 문제 결과 역시 볼 수 있다.


i 등 참가자의 x 번 문제 결과를 볼 수 없다면, 1 ~ (i-1) 등 참가자의 x번 문제 결과 역시 볼 수 없다.


i 등 참가자의 x 번 문제 결과를 볼 수 있다면, 1 ~ x 번 문제 결과 역시 볼 수 있다. 


i 등 참가자의 x 번 문제 결과를 볼 수 없다면, x ~ M 번 문제 결과 역시 볼 수 없다. 




현정이가 알 수 있는 것은 각 참가자들이 몇 문제를 풀었는지와 어떤 문제를 풀었는지에 대한 부분적인 정보이다. 현정이는 머릿속에서 행복회로를 가동하기 시작했다. 모니터가 깨져 볼 수 없는 부분을 자신이 원하는대로 채워 이 대회가 좋은대회였을 것이라고 믿는 것이다. 물론 각 참가자들이 맞춘 문제수와 볼 수 있는 결과들이 변경될 수는 없다. 깨어진 모니터에 보이는 스코어보드 정보가 주어졌을 때, 이 대회가 좋은 대회가 될 수 있는지를 알아보자.","첫 줄에 이번 대회의 참가자의 수 N(1 ≤ N ≤ 100)과 문제의 수 M(1 ≤ M ≤ 10)이 주어진다. 다음 N 개의 줄에는 1등부터 N 등까지, i 등 참가자의 맞춘 문제 수 K
i
 (0 ≤ K
i
 ≤ M)와 해당 참가자의 1 ~ M번 문제에 대한 결과가 M 개가 주어진다. 결과는 맞았다면 1, 틀렸다면 0, 찢어져 결과를 알 수 없다면 -1로 주어진다.","좋은대회가 될 수 있다면 “YES”, 아니라면  “NO”를 출력한다.","4 5
4 1 1 -1 -1 -1
3 1 0 -1 -1 -1
2 1 0 1 0 -1
1 1 0 0 0 -1

---

5 7
4 1 1 1 -1 -1 -1 -1
3 1 1 1 0 -1 -1 -1
3 1 0 1 0 -1 -1 -1
2 1 0 0 0 1 -1 -1
1 0 0 1 0 0 -1 -1","YES

---

NO","아래는 1번 예제가 좋은 대회가 될 수 있는 다양한 결과 중 하나이다.



1 1 0 1 1
1 0 1 0 1
1 0 1 0 0
1 0 0 0 0"
3004,체스판 조각,Bronze III,"상근이는 3003번에서 동혁이가 발견한 체스판을 톱으로 자르려고 한다.


상근이는 체스판을 최대 N번 자를 수 있으며, 변에 평행하게만 자를 수 있다. 또, 자를 때는 체스판의 그 변의 한쪽 끝에서 다른쪽 끝까지 잘라야 한다. 자른 후에는 조각을 이동할 수 없다.


이때, 최대 몇 조각을 낼 수 있는지 구하는 프로그램을 작성하시오.",첫째 줄에 N이 주어진다. (1 ≤ N ≤ 100),첫째 줄에 상근이가 얻을 수 있는 조각의 최댓값을 출력한다.,"1

---

3","2

---

6",
20159,동작 그만. 밑장 빼기냐?,Gold IV,"싸늘하다. 정훈이는 다음과 같은 도박을 하고 있다.


N
개의 카드와 2명의 플레이어가 있다. 플레이어가 자신과 상대방에게 번갈아 가며 카드의 윗장부터 한 장씩 분배한다. 단, 카드는 분배한 사람부터 받는다. 카드를 모두 분배했을 때 카드에 적힌 수의 합이 더 큰 사람이 이긴다. 두 명이 공평하게 카드를 나눠 갖기 위해 카드의 개수는 짝수로 주어진다.


카드를 섞고 있는 정훈이는 타짜다. 수없이 많이 카드를 섞어본 경험으로 섞고 난 후 카드의 값들을 다 알고 있다. 정훈이에게 카드를 분배할 수 있는 기회가 왔다. 확실한 승리를 위해 카드를 분배할 때 카드의 윗장이 아닌 밑장을 빼는 밑장 빼기를 하기로 마음을 먹었다. 상대는 눈치가 빠르기로 유명한 선수이므로 밑장 빼기는 최대 한번 할 것이다.


정훈이가 최대 한번 밑장 빼기를 할 때 얻을 수 있는 최대 카드의 합을 구하여라.","카드의 개수 
N
 (2 ≤ 
N
 ≤ 100,000)이 주어진다. 단, 
N
은 짝수이다.


둘째 줄에 카드의 윗장부터 밑장까지 카드의 값 
X
 (1 ≤ 
X
 ≤ 10,000)이 정수로 주어진다.",정훈이가 얻을 수 있는 최대 카드 값의 합을 출력한다.,"6
3 2 5 2 1 3",11,
7523,Gauß,Bronze II,"카를 프리드리히 가우스는 독일의 수학자이다.


가우스가 초등학교에 다닐 때, 선생님 J.G. Büttner는 1부터 100까지 수의 합을 계산하게 시켰다. 가우스는 몇 초만에 정확한 답 5050을 계산했다.


n과 m 이 주어졌을 때, n보다 크거나 같고, m보다 작거나 같은 모든 정수의 합을 구하는 프로그램을 작성하시오. 즉, 다음을 계산하라.


\[\sum_{i=n}^{m} {i} = n+(n+1)+(n+2)+ \dots + (m-1) + m\]","첫째 줄에 테스트 케이스의 개수가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있으며, n과 m이 주어진다. (-10
9
 ≤ n ≤ m ≤ 10
9
)","각 테스트 케이스마다 ""Scenario #i:""를 출력한 다음, n부터 m까지 모든 정수의 합을 출력한다. 각 테스트 케이스 사이에는 빈 줄을 하나 출력한다.","3
1 100
-11 10
-89173 938749341","Scenario #1:
5050

Scenario #2:
-11

Scenario #3:
440625159107385260",
25620,슬라임 키우기,Gold I,"N
마리의 슬라임이 있다. 
i
번째 슬라임의 크기는 
a
i
이다.


생물학자인 레프는 슬라임의 크기를 키워주는 비약을 총 
Q
번, 순서대로 사용해 슬라임의 크기를 키울 것이다. 이중 
i
번째로 사용할 비약은 현재 크기가 
x
i
 이하인 슬라임의 크기를 순식간에 
y
i
배 불려내는 효과를 가지고 있다.


Q
번의 비약을 차례대로 사용한 후, 슬라임들의 크기를 
오름차순으로 정렬하여
 나타내보자.","첫째 줄에 양의 정수 
N
과 
Q
가 공백으로 구분되어 주어진다. (1 ≤ 
N
, 
Q
 ≤ 200 000)


둘째 줄에 
N
개의 정수 
a
1
, 
a
2
, ⋯, 
a
N
가 공백으로 구분되어 주어진다. (0 ≤ 
a
i
 ≤ 10
9
)


셋째 줄부터 
Q
개의 줄에 걸쳐 
x
i
와 
y
i
가 주어진다. 구체적으로 모든 1 ≤ 
i
 ≤ 
N
에 대해, (
i
 + 2)번째 줄에는 
x
i
와 
y
i
가 공백으로 구분되어 주어진다. (0 ≤ 
x
i
, 
y
i
 ≤ 10
9
)","첫째 줄에 모든 비약을 차례대로 사용한 후 슬라임들의 크기를 
오름차순으로 정렬하여
, 공백으로 구분하여 출력한다.","2 2
0 1000000000
1 1000000000
1000000000 1000000000

---

6 5
1 2 3 4 5 6
3 2
4 5
10 2
23 1
8 0","0 1000000000000000000

---

10 12 12 20 20 20",
4006,경로 찾기,Platinum I,"TooDee는 직교좌표 시스템인 2차원 그리드-형태의 지역 이름이다. 이 지역에는 귀여운 Dee들이 살고 있다. Dee들은 벌처럼 생긴 작은 2-차원 모양의 생동물로서 아주 영리하다. TooDee에는 벌집들이 있는데, 이 벌집은 보통의 벌집과는 달리 직사각형 형태로 벌집의 각 변이 TooDee의 직교좌표의 축에 평행하다.


Dee들은 매우 특별히 진화된 동물이므로 일정한 경로로 날아간다. 이 경로는 직교좌표 축과 평행한 (수평 혹은 수직의) 선분들로 구성되며, 이 선분들의 양 끝 점의 좌표값은 모두 정수라 가정한다. 직교좌표 시스템 표기를 사용할 때, TooDee 지역에서 모든 Dee들이 날아가는 규칙은 다음과 같다. (TooDee 지역에서 언급되는 모든 점의 위치 값은 정수이다.)


현재 점 (X
S
,Y
S
)에 있다면, 인접한 4점 (즉, (X
S
+1,Y
S
), (X
S
-1,Y
S
), (X
S
,Y
S
+1), (X
S
,Y
S
-1))중 하나로 날아갈 수 있다.


벌집에는 들어갈 수 없다.


벌집의 변이나 꼭짓점 위에 있을 때만 날아가는 방향을 바꿀 수 있다.


처음에는 상하좌우 네 방향 중 임의의 하나의 방향을 선택하여 출발할 수 있다.


오늘 밤은 Deeficer(TooDee의 복지부 관리)의 딸 생일이므로 Deeficer는 사무실로부터 가능한 빨리 집으로 가고자 한다. Deeficer는 1초에 길이 1의 속도로 날아간다고 가정한다. 위의 규칙을 만족하면서 사무실로부터 가장 빨리 집으로 도착하는데 걸리는 시간(초)를 구하라.","입력의 첫 번째 줄에 테스트 시나리오의 수 T ( 1 ≤ T ≤ 20 ) 가 주어진다. 다음에 T개의 시나리오가 주어진다. 각 시나리오 앞에는 공백 줄이 있다.


각 시나리오의 첫 번째 줄에는 Deeficer의 사무실 위치와 집의 위치를 포함한다. 이들 각 위치는 X 좌표 값과 Y 좌표 값의 두 정수로 주어진다. 각 시나리오의 두 번째 줄에 벌집의 수 N이 주어진다. 다음의 N개의 각 줄에 벌집 하나의 정보가 주어진다. 이 정보는 벌집 직사각형의 대각선으로 마주보는 두 꼭짓점의 좌표들로 주어진다. 모든 두 벌집은 서로 겹치지 않으며, 두 벌집의 변이 붙어 있지도 않고, 두 벌집의 꼭짓점들이 만나지도 않는다. 사무실과 집의 위치는 서로 다르고, 벌집의 면적은 1 이상이다.


모든 좌표 값은 10
-9
보다 크거나 같고, 10
9
보다 작거나 같으며, 0 ≤ N ≤ 1000이다.","각 시나리오에 대하여, Deeficer가 사무실로부터 집까지 가장 빨리 가는 경로에 의하여 걸리는 시간(초)를 한 줄에 출력한다. 날아가는 규칙을 지키면서 집으로 도달할 수 없으면 ""No Path""를 출력한다.","2

1 7 7 8
2
2 5 3 8
4 10 6 7

2 1 5 4
1
3 1 4 3","9
No Path",
11123,양 한마리... 양 두마리...,Silver II,"얼마전에 나는 불면증에 시달렸지... 천장이 뚫어져라 뜬 눈으로 밤을 지새우곤 했었지.  그러던 어느 날 내 친구 광민이에게 나의 불면증에 대해 말했더니 이렇게 말하더군. ""양이라도 세봐!""  정말 도움이 안되는 친구라고 생각했었지. 그런데 막상 또 다시 잠을 청해보려고 침대에 눕고 보니 양을 세고 있더군... 그런데 양을 세다보니 이걸로 프로그램을 하나 짜볼 수 있겠단 생각이 들더군 후후후... 그렇게 나는 침대에서 일어나 컴퓨터 앞으로 향했지.


양을 # 으로 나타내고 . 으로 풀을 표현하는 거야. 서로 다른 # 두 개 이상이 붙어있다면 한 무리의 양들이 있는거지. 그래... 좋았어..! 이걸로 초원에서 풀을 뜯고 있는 양들을 그리드로 표현해 보는거야!


그렇게 나는 양들을 그리드로 표현하고 나니까 갑자기 졸렵기 시작했어. 하지만 난 너무 궁금했지. 내가 표현한 그 그리드 위에 몇 개의 양무리가 있었는지! 그래서 나는 동이 트기 전까지 이 프로그램을 작성하고 장렬히 전사했지. 다음날 내가 잠에서 깨어났을 때 내 모니터에는 몇 개의 양무리가 있었는지 출력되어 있었지.","첫 번째 줄은 테스트 케이스의 수를 나타나는 T를 입력받는다.


이후 각 테스트 케이스의 첫 번째 줄에서는 H,W 를 입력받는다. H는 그리드의 높이이고, W는 그리드의 너비이다. 이후 그리드의 높이 H 에 걸쳐서 W개의 문자로 이루어진 문자열 하나를 입력받는다. 




0 < T ≤ 100


0 < H, W ≤ 100","각 테스트 케이스마다, 양의 몇 개의 무리로 이루어져 있었는지를 한 줄에 출력하면 된다.","2
4 4
#.#.
.#.#
#.##
.#.#
3 5
###.#
..#..
#.###","6
3",
1116,순열 2,Platinum II,"0부터 N-1까지 모든 정수를 한 번씩 포함하고 있는 순열 A[0], A[1], ..., A[N-1]이 있다. 순열 A를 이용해서 A와 길이가 같은 자식 배열 B을 아래와 같은 방법으로 구할 수 있다.




B[0] = 0


B[i] = A[B[i-1]] (1 ≤ i ≤ N-1)




위의 과정을 통해서 만든 순열 A의 자식 배열 B가 순열인 경우에 순열 A를 완벽한 순열이라고 한다.


아래 표는 길이가 3인 모든 순열과 그 순열의 자식 배열을 나타낸다. {1, 2, 0}과 {2, 0, 1}은 자식 배열도 순열이기 때문에, 두 순열은 완벽한 순열이다.








A


B










0, 1, 2


0, 0, 0






0, 2, 1


0, 0, 0






1, 0, 2


0, 1, 0






1, 2, 0


0, 1, 2






2, 0, 1


0, 2, 1






2, 1, 0


0, 2, 0








길이가 N인 순열 P가 주어진다. 이때, P와 차이가 가장 작은 완벽한 순열 Q를 구하는 프로그램을 작성하시오. 두 순열 P와 Q의 차이는 P[i]와 Q[i]의 값이 다른 i의 개수이다.",첫째 줄에 순열 P의 크기 N (1 ≤ N ≤ 50)이 주어진다. 둘째 줄에는 순열 P가 주어진다.,첫째 줄에 입력으로 주어진 순열 P와 차이가 가장 작은 완벽한 순열 Q를 출력한다. 가능한 순열 Q가 여러 가지인 경우에는 자식 순열이 사전순으로 가장 앞서는 것을 출력한다.,"6
4 0 5 2 1 3

---

3
2 0 1

---

8
2 7 3 0 6 4 5 1

---

13
11 8 10 1 5 4 0 7 3 9 12 6 2

---

6
0 1 4 2 3 5

---

8
0 2 6 5 7 3 1 4","2 0 5 4 1 3

---

2 0 1

---

1 7 3 0 6 2 5 4

---

1 8 10 2 5 7 0 9 3 11 12 6 4

---

1 2 4 5 3 0

---

1 2 6 5 7 4 3 0",
10768,특별한 날,Bronze IV,"2월 18일은 올해 CCC에 있어서 특별한 날이다.


사용자로부터 정수인 월과 일을 입력받아 날짜가 2월 18일인지 전인지 후인지를 출력하는 프로그램이다.


만약 날짜가 2월 18일 전이면, ""Before""을 출력한다. 만약 날짜가 2월 18일 후면, ""After""을 출력한다. 만약 2월 18일이라면 ""Special"" 을 출력한다.","입력은 두 개의 정수가 각 줄에 걸쳐 입력된다. 이 정수들은 2015년의 날짜에 포함된다.


첫 번째 줄은 1에서 12사이의 월을 입력한다.


두 번째 줄은 1에서 31사이의 그 달에 들어있는 날짜를 입력한다 .","마지막 줄에 ""Before"", ""After""나 ""Special""을 출력한다.","1
7

---

8
31

---

2
18","Before

---

After

---

Special",
10423,전기가 부족해,Gold III,"세계에서 GDP가 가장 높은 서강 나라는 소프트웨어와 하드웨어 기술이 모두 최고라서 IT강국이라 불리고, 2015년부터 세상에서 가장 살기 좋은 나라 1등으로 꼽히고 있다. 


살기 좋은 나라 1등으로 꼽힌 이후 외국인 방문객들이 많아졌고, 그에 따라 전기 소비율이 증가하여 전기가 많이 부족한 상황이 되었다. 따라서 서강 나라의 대통령은 최근 개발이 완료된 YNY발전소 프로젝트를 진행 하기로 하였다. 발전소를 만들 때 중요한 것은 발전소 건물과 도시로 전기를 공급해 줄 케이블이다. 발전소는 이미 특정 도시에 건설되어 있고, 따라서 추가적으로 드는 비용은 케이블을 설치할 때 드는 비용이 전부이다. 이 프로젝트의 문제는 케이블을 설치할 때 드는 비용이 굉장히 크므로 이를 최소화해서 설치하여 모든 도시에 전기를 공급하는 것이다. 여러분은 N개의 도시가 있고 M개의 두 도시를 연결하는 케이블의 정보와 K개의 YNY발전소가 설치된 도시가 주어지면 케이블 설치 비용을 최소로 사용하여 모든 도시에 전기가 공급할 수 있도록 해결해야 한다. 중요한 점은 어느 한 도시가 두 개의 발전소에서 전기를 공급받으면 낭비가 되므로 케이블이 연결되어있는 도시에는 발전소가 반드시 하나만 존재해야 한다. 아래 Figure 1를 보자. 9개의 도시와 3 개의 YNY발전소(A,B,I)가 있고, 각각의 도시들을 연결할 때 드는 비용이 주어진다.




Figure 1




Figure 2


이 예제에서 모든 도시에 전기를 공급하기 위하여 설치할 케이블의 최소 비용은 22이고, Figure 2의 굵은 간선이 연결한 케이블이다. B 도시는 연결된 도시가 하나도 없지만, 발전소가 설치된 도시는 전기가 공급될 수 있기 때문에 상관없다.","첫째 줄에는 도시의 개수 N(1 ≤ N ≤ 1,000)과 설치 가능한 케이블의 수 M(1 ≤ M ≤ 100,000)개, 발전소의 개수 K(1 ≤ K ≤ N)개가 주어진다. 둘째 줄에는 발전소가 설치된 도시의 번호가 주어진다. 셋째 줄부터 M개의 두 도시를 연결하는 케이블의 정보가 u, v, w로 주어진다. 이는 u도시와 v도시를 연결하는 케이블을 설치할 때 w의 비용이 드는 것을 의미한다. w는 10,000보다 작거나 같은 양의 정수이다.",모든 도시에 전기를 공급할 수 있도록 케이블을 설치하는 데 드는 최소비용을 출력한다.,"9 14 3
1 2 9
1 3 3
1 4 8
2 4 10
3 4 11
3 5 6
4 5 4
4 6 10
5 6 5
5 7 4
6 7 7
6 8 4
7 8 5
7 9 2
8 9 5

---

4 5 1
1
1 2 5
1 3 5
1 4 5
2 3 10
3 4 10

---

10 9 5
1 4 6 9 10
1 2 3
2 3 8
3 4 5
4 5 1
5 6 2
6 7 6
7 8 3
8 9 4
9 10 1","22

---

15

---

16",
12981,공 포장하기,Silver IV,"빨간 공 R개, 초록 공 G개, 파란 공 B개를 가지고 있다.


오늘은 이 공을 박스로 포장하려고 한다. 박스에는 공이 1개, 2개, 또는 3개 들어갈 수 있다.


박스에 들어가는 공의 색은 모두 다르거나, 모두 같아야 한다.


필요한 박스 개수의 최솟값을 구하는 프로그램을 작성하시오.","첫째 줄에 R, G, B가 주어진다. (1 ≤ R, G, B ≤ 100)",첫째 줄에 필요한 박스 개수의 최솟값을 출력한다.,"4 2 4

---

1 7 1

---

2 3 5

---

78 53 64

---

100 100 100","4

---

3

---

4

---

66

---

100","첫 번째 예제는 RGB, RG, RR, BBB로 포장하면 된다.


두 번째 예제는 RGB, GGG, GGG로 포장한다."
23084,IUPC와 비밀번호,Gold III,"치훈이는 인하대학교 빡코딩 대회, IUPC (Inha University Ppakcoding Contest)에 문제를 출제하고 있다.


대회에 낼 문제들은 극비사항이기 때문에, 치훈이는 문제가 저장된 컴퓨터에 비밀번호를 설정해 놓았다. 치훈이가 비밀번호를 만드는 방식은 다음과 같다.




알파벳 소문자로만 이루어진 문자열 \(S\)를 준비한다.


문자열의 각 문자들의 위치를 랜덤하게 섞는다.


섞인 문자열의 앞과 뒤에 임의의 문자열을 각각 추가한다. 추가하는 문자열의 길이는 0일 수도 있다.


마지막으로 임의의 위치에 있는 문자 1개를 골라 
다른
 문자로 바꾼다.




그런데 어느 날, 치훈이는 문자열 문제를 풀다가 실수로 컴퓨터 비밀번호와 다른 문자열들을 섞어 버려서 어떤 문자열이 비밀번호였는지 알 수 없게 되어 버렸다.


지금 치훈이에게 \(N\)개의 비밀번호 후보 문자열이 있다. IUPC의 성공적인 개최를 위해 각 비밀번호 후보 문자열이 비밀번호일 가능성이 있는지 알아내 주자!","첫째 줄에 \(S\)가 주어진다.


두번째 줄에 비밀번호 후보 문자열의 개수 \(N\)이 주어진다.


다음 \(N\)개의 줄에 걸쳐, \(i\)번째 비밀번호 후보 문자열 \(T_i\)이 각각 주어진다.","\(N\)개의 줄에 걸쳐, 각 \(T_i\)가 비밀번호일 가능성이 있는지 여부를 출력한다.


가능하면 ""
YES
"", 불가능하면 ""
NO
""를 출력한다.","abc
4
defabcghi
bda
cba
ac","YES
YES
NO
NO",
2984,고속도로,Platinum II,"상근이는 점점 부자가 되었고 트럭 운송 회사를 차렸다. 이 회사에는 트럭이 총 N대 있고, 모든 배달은 ""공부 고속도로""를 통해 이루어진다.


공부 고속도로에는 나들목(인터체인지, IC)이 1,000,000개 있다. 그리고, 각 나들목은 1번부터 순서대로 번호가 매겨져 있다. 나들목에서는 고속도로로 들어오거나 나갈 수 있다.


고속도로에 들어갈 때는 들어온 나들목의 번호가 적혀있는 티켓을 하나 받게 된다. 이 티켓은 고속도로에서 나갈 때 요금소(톨게이트)에 제시해야하고, 들어온 나들목과 나가는 나들목 번호의 차이만큼 요금을 내야 한다. 예를 들어, 티켓에 적혀있는 나들목의 번호가 30이고 12번 나들목으로 나간다면, 요금은 18원이 된다.


고속도로 이용 요금은 점점 회사가 감당할 수 없는 수준까지 치솟았고, 상근이는 획기적인 방법을 생각해냈다. 바로, 고속도로 중간에서 두 운전사가 만나서 티켓을 교환하는 것이다. 이 방법은 서로 경로가 겹치지 않더라도 교환할 수 있으며, 티켓은 여러 번 교환할 수 있다.


하지만, 의심을 피하기 위해서 티켓에 적혀있는 나들목의 번호와 같은 나들목으로 나갈 수는 없다. 


운전사끼리 티켓을 적절히 교환했을 때, 내야하는 고속도로 이용 요금의 최솟값을 구하는 프로그램을 작성하시오.","첫째 줄에 트럭의 수 N이 주어진다. (1 ≤ N ≤ 100,000)


다음 N개 줄에는 각 트럭이 들어온 나들목의 번호와 나가야 하는 나들목의 번호가 공백으로 구분해서 주어진다. 나들목의 번호는 1보다 크거나 같고, 1,000,000보다 작거나 같은 자연수이다.


두 트럭이 고속도로로 들어올 때 사용하는 나들목의 번호나 나갈 때 사용하는 나들목의 번호가 같은 경우는 없다.","상근이네 트럭 운송 회사가 내야하는 고속도로 이용 요금의 최솟값을 출력한다. 이 값은 32비트 정수 범위를 넘어갈 수 있기 때문에, 64비트 정수(C/C++: long long)을 사용해야 한다.","3
3 65
45 10
60 25

---

3
5 5
6 7
8 8","32

---

5",
3117,YouTube,Gold I,"Sogang ACM-ICPC Team은 전통적으로 1학기에 신입생들에게 C언어를 가르쳐준다. 올해는 상근이가 C언어를 가르쳐 주기로 했다.


어느 날, 링크드 리스트를 설명하는 날이었다. 상근이는 앞에서, 구조체와 malloc을 이용해 링크드 리스트를 구현하는 방법을 설명하고 있었다.


2시간에 걸친 설명을 듣던 중, 지루해진 N명의 학생들은 남은 M분 동안 상근이 몰래 
YouTube
를 보기로 했다.


YouTube에는 K개의 동영상이 있고, 1번부터 K번까지 번호가 매겨져 있다. 동영상을 볼 때, 우측에는 추천 동영상이 떠있다.


모든 학생은 메인 페이지에서 동영상 하나를 시청한다. 동영상을 시청하고 1분이 지나면, 추천 동영상 중 가장 위에 있는 동영상을 시청한다. (모든 동영상은 정확히 1분만 시청한다)


각 학생이 처음에 시청한 동영상 번호와, 각 동영상의 추천 동영상 중 가장 위에 있는 동영상의 번호가 주어졌을 때, M분에 각 학생이 시청한 동영상 번호를 출력하는 프로그램을 작성하시오.","첫째 줄에 N, K, M이 주어진다. (1 ≤ N,K ≤ 100,000) (1 ≤  M ≤  1,000,000,000) N은 학생의 수, K는 동영상의 개수, M은 남은 수업 시간이다.


둘째 줄에는 1보다 크거나 같고, K보다 작거나 같은 수가 N개 주어진다. 이 수는 각 학생이 제일 처음 시청하는 동영상 번호이다.


셋째 줄에는 1보다 크거나 같고, K보다 작거나 같은 수 K개가 주어진다. 이 숫자는 각 동영상의 추천 동영상 중, 가장 위에 있는 동영상의 번호이다.",첫째 줄에 각 학생이 M분에 시청하는 동영상 번호를 공백으로 구분해서 출력한다.,"4 5 2
1 2 4 3
5 5 1 2 3

---

2 6 5
1 6
2 3 4 1 4 5","5 5 2 1

---

1 2",
27088,앤디 공격하기,Platinum III,"이 문제에서 두 지점 사이의 거리는 택시 거리로 계산된다. 두 점 $(x_1, y_1)$과 $(x_2, y_2)$ 사이의 택시 거리는 $(|x_1 - x_2| + |y_1 - y_2|)$이다.


앤디를 싫어하는 싸이컴 부원 $N$명이 앤디를 공격하려고 한다. 각 부원이 앤디를 공격할 때, 다음과 같은 성질을 가진다.




각 부원이 앤디를 공격하려면 앤디가 보여야 한다. 시야 방향은 $+x, -x, +y, -y$ 중 하나이고 시야각은 좌우 45도이다. 앤디와 부원이 같은 위치에 있는 경우, 또 시야각에 걸치는 경우에도 볼 수 있다고 가정한다.


앤디를 공격하는 공격력은 부원과 앤디 사이의 거리와 같다.




앤디를 물리치려면 $N$명의 공격력의 합이 앤디의 체력 $k$ 이상이 되어야 한다.


예를 들어, $k=23$이고 아래와 같이 위치하는 경우를 생각하자. 아래 예시는 예제 1과 같다.


















위와 같은 위치에서 앤디를 공격할 수 있는 사람은 1과 2 뿐이므로 앤디가 받는 공격량은 17이다. 여기서 3번을 왼쪽으로 5만큼 움직였을 때, 앤디가 받는 공격이 25가 되므로 앤디를 물리칠 수 있고, 이 경우가 최적이다.


$k$와 앤디를 포함한 싸이컴 부원 $N+1$명의 위치 및 시야 방향이 주어질 때, 앤디를 물리치기 위해 필요한 $N$명의 이동 거리의 합의 최솟값을 출력하라. 단, 여러 명이 같은 위치에 존재해도 문제가 없으며, 공간에는 제약이 없어 얼마든지 원하는 방향으로 이동할 수 있다고 가정한다.","첫 줄에 두 정수 $N$과 $k$가 주어진다.


둘째 줄에 앤디의 좌표 $X_0$와 $Y_0$가 주어진다.


셋째 줄부터 $N+2$번째 줄까지 $N$명의 좌표 정보와 시야 정보가 주어진다. 구체적으로 $i+2$번째 줄에는 $i$번째 부원의 좌표 $X_i$와 $Y_i$, 그리고 보는 방향 $S_i$가 주어진다. $S_i$는 0, 1, 2, 3 중 하나이며, 각각 $+x$, $-x$, $+y$, $-y$ 방향을 의미한다.",앤디를 물리치기 위해 필요한 $N$명의 이동 거리의 합의 최솟값을 출력한다.,"3 23
5 5
5 11 3
12 9 1
6 1 0",5,문제 이미지의 방향은 아래와 같다.
17954,투튜브,Gold II,"투튜브의 유명 BJ인 민서는 팬들로부터 많은 사랑을 받고 있다. 팬들은 자신들의 팬심을 표현하기 위해 민서에게 많은 선물을 보내준다. 그 중 민서가 가장 좋아하는 선물은 사과이다. 이 사실을 알게 된 민서의 열혈 팬 성주는 민서에게 특별 포장 되어있는 사과세트를 보내주었다.


며칠이 지나 사과세트를 받은 민서는 포장 방식을 보고 적잖이 당황하였다. 총 2N개의 사과가 들어있었는데, 2개의 기다란 튜브에 N개씩 들어있었다. 각 튜브는 맨 앞과 끝이 뚫려 있어 총 4개의 구멍으로만 사과를 꺼낼 수 있다. 2N개의 사과는 각기 다른 크기를 가지고 있는데, 그 크기는 1부터 2N까지로 중복 없는 크기를 가지고 있다. 민서는 사과를 꺼낼 때, 구멍 쪽에 위치한 4개 이하의 사과 중 크기가 가장 작은 사과를 꺼낸다. 이 과정을 2N번 반복하여 모든 사과를 튜브에서 꺼내게 된다.


하지만 성주가 선물해준 사과는 너무 신선하여 민서가 포장을 뜯는 즉시 조금씩 부패하기 시작한다. 양의 정수 T초의 시간이 지나게 되면, 튜브 안에 들어있는 사과들은 “크기 x T”만큼의 부패도를 가지게 되고, 부패도는 누적된다.


성주도 사과가 부패한다는 사실을 당연히 알기 때문에, 민서에게 보내기 전 최대한 사과들이 부패하지 않도록 배치하려고 한다. 즉, 총 부패도가 최소가 되게 하려고 한다. 여러분이 성주의 팬심이 민서에게 전해지도록 도와주자.","첫째 줄에 양의 정수 N이 주어진다. (1 ≤ N ≤ 10,000)","첫째 줄에 최소의 부패도를 출력한다.


둘째 줄과 셋째 줄에 최소의 부패도를 가지는 사과의 배치를 출력한다. 만약 최소의 부패도를 가지는 사과의 배치가 여러가지 존재할 경우, 그 중 아무거나 출력한다.",2,"35
1 2
3 4",
12986,화려한 마을2,Platinum II,"민호가 관리하는 천나라에는 N개의 집이 있다. 민호는 집을 쉽게 관리하기 위해 각각의 집을 1번, 2번, … N번으로 부르기로 했다.


어느 날 미적 감각에 눈을 뜬 민호는 천나라에 존재하는 모든 집에 페인트 칠을 했다. 하지만 페인트마다 밝기가 다 다르기 때문에 자짓 잘못하다가는 미관을 해칠 수 있다고 생각을 해 집의 번호가 증가한다면 어두워 지지 않는 방향으로 페인트를 칠하였다.


이렇게 모두 페인트를 칠한 뒤 민호는 특정 구간에 있는 집들에 존재하는 페인트의 밝기들 중 가장 많은 것의 개수가 궁금해졌다.


이를 알아보는 프로그램을 만들어 보자.","첫 번째 줄에 N, Q (1 ≤ N ≤ 100,000, 1 ≤ Q ≤ 100,000)이 공백을 구분으로 주어진다.


각각 천나라에 존재하는 집의 수와 민호가 궁금해 하는 특정 구간의 수이다.


두 번째 줄에는 1번 집부터 N번 집까지 차례대로 칠해진 페인트의 밝기(-100,000 ≤ P ≤ 100,000) 가 주어진다.


세 번째 줄부터 Q개의 줄에 걸쳐 특정 구간이 주어진다. 이는 X, Y (1 ≤ X ≤ Y ≤ N) 으로 이루어 져 있으며 궁금해 하는 특정 구간이 X번 집부터 Y번 집까지라는것을 의미한다.",Q개의 줄에 걸쳐 각 구간에 가장 많이 등장하는 페인트 밝기의 개수를 출력한다.,"10 3
-1 -1 1 1 1 1 3 10 10 10
2 3
1 10
5 10","1
4
3",
23080,스키테일 암호,Bronze III,"고대 그리스의 옛 나라인 스파르타의 군대에서는 비밀메시지를 전하는 방법으로 스키테일 암호를 사용했다.


스키테일 암호는 스키테일(Scytale)이라고 하는 정해진 굵기의 원통형 막대에 종이로 된 리본을 위에서 아래로 감은 다음 옆으로 메시지를 적는 방식으로 메세지를 암호화한다. 리본을 풀어 길게 늘어선 글을 읽으면 무슨 뜻인지 전혀 알 수 없지만, 암호화할 때와 같은 굵기의 막대에 감으면 내용을 알 수 있게 된다.


다음은 굵기 3의 막대를 사용하여 ""
iupc
"" 라는 문자열을 암호화하는 예시이다.




굵기가 \(X\)인 막대에 리본을 감고 세로로 글자 \(X\)개를 적으면 막대를 한바퀴 돌아오게 된다. 이 막대는 굵기가 3이므로, 세로로 3글자를 적으면 막대를 한바퀴 돌아올 것이다.


암호화하는 문자열을 리본의 가장 왼쪽 끝 부분을 포함하는 가로 
한 줄만
 사용하여 쓰고, 남은 공간은 아무 문자로나 채운다.




마지막으로 막대에서 리본을 풀면 암호화가 완료된다.




스키테일 암호로 암호화한 문자열과 막대의 굵기가 주어진다. 암호를 해독해 보자!",첫 번째 줄에 막대의 굵기 \(K\)가 주어진다. 두 번째 줄에 알파벳 소문자만으로 구성된 암호문 \(S\)가 주어진다.,첫 번째 줄에 암호문을 해독한 결과를 출력한다.,"3
iabucdpefcg",iupc,
10714,케이크 자르기 2,Gold II,"JOI 군과 IOI 양은 쌍둥이 남매이다. JOI 군은 최근 과자 만들기에 푹 빠졌기 때문에, JOI 군은 오늘도 케이크를 만들어서 먹으려고 했지만, 막 구워진 참에 냄새를 맡고 온 IOI 양이 왔기 때문에 두 명이 케이크를 나누어 먹기로 했다.


케이크는 둥그런 모양을 하고 있다. 어느 점에서부터 직선으로 칼집을 넣어 케이크를 N 개의 조각으로 나눈 뒤, 각 조각마다 1부터 N 까지 반시계방향으로 번호를 매긴다. 즉, 1 ≦ i ≦ N에 대해, i 번째 조각은 i - 1 번째와 i + 1 번째 조각과 인접해있다. (단, 0번째는 N 번째, N + 1 번째는 1번째로 간주한다). i 번째 조각의 크기는 A
i
 이지만, 칼질이 서툴러 A
i
가 모두 다른 값을 가지게 되었다.




그림 1 : 케이크의 예 (N = 5, A
1
 = 2, A
2
 = 8, A
3
 = 1, A
4
 = 10, A
5
 = 9)


이 N개를 JOI 군과 IOI 양이 나누기로 하였다. 나누는 방법은 다음과 같다.




먼저, JOI 군이 N 개의 조각 중 원하는 것 하나를 가져간다.


그 뒤, IOI 양으로부터 시작해 IOI 양과 JOI 군은 번갈아가며 남은 조각을 하나씩 가져간다. 단, 인접한 조각 중 하나 이상의 조각이 이미 선택된 경우에만 가져갈 수 있다. 가져갈 수 있는 조각이 여러 개 있을 때엔, IOI 양은 그 중 가장 큰 조각을 가져가고, JOI 군은 원하는 조각을 가져갈 수 있다.




JOI 군은 자신이 가져온 조각들 크기의 합을 최대화하고 싶다.


케이크의 조각 수 N 과, N 개의 조각의 크기에 대한 정보가 주어질 때, JOI 군이 가져올 수 있는 조각들의 합계의 최대치를 구하는 프로그램을 작성하시오.","표준입력으로부터 이하의 입력이 주어진다.




첫 번째 줄에는 케이크가 N 개의 조각으로 나뉘어 있음을 나타내는 정수 N이 주어진다.


이어지는 N 열 중 i 열 (1 ≦ i ≦ N) 에는 i 번째 조각의 크기를 나타내는 정수 A
i
가 적혀있다.",JOI 군이 가져올 수 있는 조각들의 합계의 최대치를 한 줄로 출력하시오.,"5
2
8
1
10
9

---

8
1
10
4
5
6
2
9
3

---

15
182243672
10074562
977552215
122668426
685444213
3784162
463324752
560071245
134465220
21447865
654556327
183481051
20041805
405079805
564327789","18

---

26

---

3600242976",
23765,다각형의 넓이,Platinum III,2차원 평면 상에 서로 다른 $N$개의 점이 주어진다. 제노는 이 점들 중 $K$개 이하의 점들을 골라 단순다각형을 만들려고 한다. 제노가 만들 수 있는 단순다각형의 최대 넓이를 구하시오.,"첫째 줄에는 $N,\ K$가 공백을 사이에 두고 주어진다. ($K \le N \le 400,\ 3 \le K \le \min (12,N)$)


둘째 줄부터 $N+1$번째 줄까지 각 점의 $x,\ y$ 좌표가 공백을 사이에 두고 주어진다. 


좌표값은 절댓값이 $10^5$을 넘지 않는 정수이다.","첫째 줄에 최대 넓이를 소수점 아래 둘째 자리에서 반올림하여 첫째 자리까지 출력한다.


주어진 입력으로 넓이가 0 초과인 단순다각형을 만들 수 있음이 보장된다.","8 3
10 -1
5 4
-4 2
-8 -2
1 -5
-5 4
-2 1
3 3

---

20 5
80000 20000
26435 29423
79100 20900
50000 50000
46245 47499
56145 -316
46512 -7169
58092 32650
50000 -10000
72169 49362
23220 -8321
23973 -9148
25313 25419
76567 9094
28024 -9877
54035 24956
41587 -6615
20000 20000
37842 42884
31457 18570","52.5

---

2259785373.0",
7561,크래머의 공식,Gold IV,"세 변수 \(x_1\), \(x_2\), \(x_3\)로 이루어진 일차 방정식 세 개가 있다. \(a_{ij}\)와 \(b_i\)가 주어졌을 때, 다음과 같이 표현할 수 있다.


\(\begin{vmatrix} a_{ 11 }x_{ 1 }+a_{ 12 }x_{ 2 }+a_{ 13 }x_{ 3 }=b_{ 1 } \\ a_{ 21 }x_{ 1 }+a_{ 22 }x_{ 2 }+a_{ 23 }x_{ 3 }=b_{ 2 } \\ a_{ 31 }x_{ 1 }+a_{ 32 }x_{ 2 }+a_{ 33 }x_{ 3 }=b_{ 3 } \end{vmatrix}\)


행렬과 벡터를 이용하면 다음과 같이 나타낼 수 있다.


\(A\cdot x=b\), where \(A=\begin{pmatrix} a_{11} & a_{12} & a_{13} \\ a_{21} & a_{22} & a_{23} \\ a_{31} & a_{32} & a_{33} \end{pmatrix}\), \(b=\begin{pmatrix} b_1 \\ b_2 \\ b_3 \end{pmatrix}\), x=\(\begin{pmatrix} x_1 \\ x_2 \\ x_3 \end{pmatrix}\)


크래머의 공식을 이용하면 방정식의 해는 행렬식(determinant)를 이용해 다음과 같이 구할 수 있다.


\(x_i = \frac {det~A_i}{det~A}\)


\(A_i\) 는 행렬 \(A\)의 \(i\)번째 열을 벡터 \(b\)로 대체한 것이다. 예를 들어, \(3 \times 3\) 행렬의 행렬식은 아래와 같이 구할 수 있다.


\(det\begin{pmatrix} a_{11} & a_{12} & a_{13} \\ a_{21} & a_{22} & a_{23} \\ a_{31} & a_{32} & a_{33} \end{pmatrix} = a_{11}(a_{22}a_{33} - a_{23}a_{32}) - a_{12}(a_{21}a_{33} - a_{23}a_{31}) + a_{13}(a_{21}a_{32}-a_{22}a_{31})\)


크래머의 공식은 \(det~A \ne 0\)인 경우에만 해를 구할 수 있다. \(det~A \ne 0\)인 경우에 방정식의 해는 유일하고, 그렇지 않은 경우에는 해가 없거나 무수히 많은 해를 가진다.


방정식이 많은 경우에는 행렬식을 구하는데 시간이 너무 많이 걸린다. 따라서, 이런 경우에는 다른 방법을 사용하는 것이 더 효율적이다.


세 변수로 이루어진 일차 방정식 세 개가 주어진다. 크래머의 공식을 이용해서 해를 구하는 프로그램을 작성하시오.","입력은 여러 개의 테스트 케이스로 이루어져 있다.


각 테스트 케이스는 세 줄로 이루어져 있고, 아래와 같은 순서로 주어진다.


\(\begin{matrix} a_{11} & a_{12} & a_{13} & b_1 \\ a_{21} & a_{22}  & a_{23} & b_{2}  \\ a_{31}  & a_{32} & a_{33} & b_{3}  \end{matrix}\)


모든 숫자는 -1000보다 크거나 같고, 1000보다 작거나 같은 정수이며, 공백 한 칸으로 구분되어져 있다.","각 테스트 케이스마다 두 줄을 출력한다.


첫째 줄에는 행렬 \(A_1\), \(A_2\), \(A_3\), \(A\)의 행렬식을 출력한다. 


방정식의 해가 존재하지 않는 경우에는 둘째 줄에 ""No unique solution""을 출력하고, 해가 존재하는 경우에는 ""Unique solution: ""와 \(x_1\), \(x_2\), \(x_3\) 값을 소수점 셋째자리까지 출력한다.


방정식의 해 \(x_i\)가 -0.0005 < \(x_i\) < 0.0005 인 경우에는 ""-0.000"" 대신에 ""0.000""을 출력한다.


각 테스트 케이스 사이에는 빈 줄을 하나 출력한다.","3
4 0 0 1
0 2 0 2
0 0 1 4
1 2 3 1
1 1 1 2
2 2 2 3
1 0 0 1
0 1 0 0
0 0 -1 0","2 8 32 8
Unique solution: 0.250 1.000 4.000

1 -2 1 0
No unique solution

-1 0 0 -1
Unique solution: 1.000 0.000 0.000",
23753,연결 요소와 쿼리,Diamond I,"$K \times N$ 격자 그래프 $A$가 주어진다. 격자 그래프는 노드가 직사각형 모양으로 배치되어 있는 그래프이며, 각 노드는 위, 아래, 왼쪽, 그리고 오른쪽 노드와 연결되어 있다.


위에서 $x$번째 줄 왼쪽에서 $y$번째 칸의 노드를 $A_{xy}$로 나타내자. 이 때, 다음 쿼리를 수행하는 프로그램을 작성하시오.




1 x
1
 y
1
 x
2
 y
2
: $x_1 \le x \le x_2$, $y_1 \le y \le y_2$인 $A_{xy}$만으로 이루어진 크기 $1$ 이상의 연결 요소 중, 구성 노드의 값의 합이 가장 큰 연결 요소를 찾아 그 합을 출력한다.


2 x y v
: $A_{xy}$의 값을 $v$로 설정한다.","첫 번째 줄에 격자 그래프의 크기를 나타내는 정수 $K$, $N$이 주어진다. ($K \in \left\{1,2,3\right\}$, $1 \le N \le 100\,000$)


두 번째 줄부터 $K$개의 줄에 걸쳐 격자 그래프의 노드의 값들이 주어진다. ($-10^9 \le A_{ij} \le 10^9$)


다음 줄에는 쿼리의 개수 $Q$가 주어진다. ($1 \le Q \le 100\,000$)


다음 줄부터 $Q$개의 쿼리가 문제에서 언급한 형식으로 한 줄에 하나씩 주어진다.




$1$번 쿼리에서 $1 \le x_1 \le x_2 \le K$, $1 \le y_1 \le y_2 \le N$이다.


$2$번 쿼리에서 $1 \le x \le K$, $1 \le y \le N$, $-10^9 \le v \le 10^9$이다.




입력으로 들어오는 모든 수는 정수다.",각각의 쿼리마다 정답을 한 줄에 하나씩 출력한다.,"3 8
-1 5 6 3 -1 7 -6 9
6 8 -9 2 -4 5 1 8
3 4 1 5 -7 -3 2 7
4
1 1 2 3 7
2 1 5 -100
1 1 2 3 7
1 2 2 2 4","48
45
8",
29730,임스의 데일리 인증 스터디,Silver III,"취업 준비생 임스는 취업 준비를 하면서 그날그날 무슨 공부를 하였는지 기록하기 위해 
데일리 인증
이라는 스터디를 시작했다. 임스는 매일 무슨 공부를 하였는지 적으면서 몇 개의 규칙을 정했다.




매일 꾸준히 백준 문제를 푼다.


백준 문제를 하루 $1$문제 이상 풀었고, 그 외의 다른 공부는 $0$개 이상 진행하였다. 다른 공부들은 영어 대소문자, 숫자, 공백으로만 이루어진 최대 길이 $100$의 문자열이다.


인증 기록으로는 백준 문제 링크를 제일 마지막에 작성하고, 그 외 학습 기록은 문자열 길이가 짧은 순으로 정렬해서 작성한다. 만약 문자열의 길이가 같다면, 사전 순으로 정렬한다.


문자는 아스키코드 기준으로 비교한다.


백준 문제 링크는 
boj.kr/문제 번호
 형식이다. 문제 번호가 작은 순서대로 정렬해서 작성한다. 문제 번호는 $1$ 이상 $30\,000$ 이하이다.




임스가 하루 동안 공부한 기록들이 정렬되지 않은 채로 주어졌을 때, 주어진 규칙에 맞게 정렬 후 출력한다.","첫 번째 줄에는 임스가 하루동안 공부한 기록의 개수 $N$이 주어진다. $(1 \le N \le 1\,000)$


다음 $N$개의 줄에 임스가 하루동안 공부한 기록들이 한 줄에 하나씩 주어진다.


학습 기록은 공백으로 시작하거나 끝나지 않는다. 
같은 공부 기록이 여러 번 주어질 수도 있다.",임스가 공부한 기록들을 주어진 규칙에 맞게 정렬 후 한 줄에 하나씩 출력한다.,"3
boj.kr/1307
study gc
read book","study gc
read book
boj.kr/1307",
14003,가장 긴 증가하는 부분 수열 5,Platinum V,"수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열을 구하는 프로그램을 작성하시오.


예를 들어, 수열 A = {10, 20, 10, 30, 20, 50} 인 경우에 가장 긴 증가하는 부분 수열은 A = {
10
, 
20
, 10, 
30
, 20, 
50
} 이고, 길이는 4이다.","첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000,000)이 주어진다.


둘째 줄에는 수열 A를 이루고 있는 A
i
가 주어진다. (-1,000,000,000 ≤ A
i
 ≤ 1,000,000,000)","첫째 줄에 수열 A의 가장 긴 증가하는 부분 수열의 길이를 출력한다.


둘째 줄에는 정답이 될 수 있는 가장 긴 증가하는 부분 수열을 출력한다.","6
10 20 10 30 20 50","4
10 20 30 50",
25510,Lord of the Characteristic Polynomials (2),Ruby V,"$n \times n$ 행렬 $A$의 행렬식(determinant) $\det A$는 아래와 같이 정의한다. 아래 식에서 $a_{ij}$는 $A$의 $i$행 $j$열에 위치한 원소를 나타낸다. 또한 $S_{n}$는 $\{1, \cdots, n\}$의 순열들의 집합으로, 각 $\sigma \in S_{n}$에 대해 $\{1, \cdots, n\} = \{\sigma(1), \cdots, \sigma(n)\}$을 만족한다.


$$ \det A = \sum_{\sigma \in S_{n}} \mathrm{sgn}(\sigma) \cdot \left(\prod_{i = 1}^{n} a_{i \sigma(i)}\right) $$


$A$의 characteristic polynomial $\phi_{A}(x)$는 $x$에 대한 $n$차 다항식으로, $\phi_{A}(x) = \det(x I - A) = c_{n}x^{n} + c_{n-1}x^{n-1} + \cdots + c_{0}$로 정의한다.


이번에는 행렬 $A$의 원소가 다소 특이하다. $1$보다 큰 제곱수로 나누어떨어지지 않는 정수 $D \neq 1$가 주어진다. 이 때 $A$의 모든 원소는 두 정수 $a + b\sqrt{D}$ 꼴로 나타낼 수 있는 수로, 아래와 같이 정의된 집합 $\mathbb{Z}\sqrt{D}$의 원소이다.


$$ \mathbb{Z}[\sqrt{D}] = \{a + b\sqrt{D} \mid a, b \in \mathbb{Z} \} $$


각 원소가 $\mathbb{Z}[\sqrt{D}]$에 속하는 행렬 $A$가 주어진다. 이 때 $\phi_{A}(x)$의 계수 $c_{0}, \cdots, c_{n}$ 또한 $\mathbb{Z}[\sqrt{D}]$의 원소임을 증명할 수 있다. 또한, $c_{i} = p_{i} + q_{i}\sqrt{D}$를 만족하는 정수 $p_{i}, q_{i}$ 또한 유일하게 존재한다. 주어진 정수 $M$에 대해, 각 $p_{i}$와 $q_{i}$를 $M$으로 나눈 나머지를 구하는 프로그램을 작성하시오.","입력의 첫 줄에 행렬의 크기를 나타내는 정수 $n$과 나눗셈에 사용되는 정수 $M$, 정수 $D$가 주어진다.


둘째 줄부터 $n$개의 줄에 걸쳐 행렬 $A$의 원소가 주어진다. 각 줄에는 $2n$개의 정수가 주어지며, 이 중 $i$번째 줄의 $2j-1$번째 수를 $x$, $2j$번째 수를 $y$라고 하면 $a_{ij} = x + y\sqrt{D}$를 만족한다.","총 $n+1$개의 줄에 걸쳐, $i$번째 줄에는 $p_{i}$와 $q_{i}$를 $M$으로 나눈 나머지를 공백으로 구분지어 출력한다.


정수 $a$를 $M$으로 나눈 나머지란, $a - b$가 $M$의 배수가 되는 가장 작은 음 아닌 정수 $b$를 의미한다.","3 107 -5
3 1 4 1 5 9
2 6 5 3 5 8
9 7 9 3 2 3","26 69
2 31
97 100
1 0","각 $x \in \mathbb{Z}[\sqrt{D}]$에 대해, $x = a + b\sqrt{D}$ 를 만족하는 정수 $a, b$는 유일하게 존재한다.


$(a + b\sqrt{D}) + (c + d\sqrt{D}) = (a + c) + (b + d)\sqrt{D}$


$(a + b\sqrt{D})(c + d\sqrt{D}) = (ac + bdD) + (ad + bc)\sqrt{D}$"
9411,실수 계산,Gold IV,"상근이는 구조체를 이용해서 실수를 저장하려고 한다. 구조체에는 30개의 숫자를 저장할 수 있는 정수 배열 (digits), 소수점의 위치를 나타내는 정수 (decpt), 부호(+/-)를 나타내는 sign이 있다. 예를 들어, -218.302869584는 아래와 같이 저장할 수 있다.




0.0000123456789는 아래와 같이 저장할 수 있다.




실수가 주어졌을 때, 상근이가 만든 방법을 이용해 합을 구하는 프로그램을 작성하시오.","첫째 줄에 테스트 케이스의 개수가 주어진다. 각 테스트 케이스는 여러 개의 실수로 이루어져 있으며, 각 테스트 케이스의 마지막에는 0이 주어진다. 입력으로 주어지는 실수는 최대 30개의 숫자로 이루어져 있고, 각 테스트 케이스는 최대 100개의 실수로 이루어져 있다.","각 테스트 케이스마다 입력으로 주어진 실수의 합을 출력한다. 각 실수를 출력할 때, 0이 아닌 마지막 자리까지 출력한다. 절대로 반올림을 하면 안 된다.","4
4.12345678900000000005
-0.00000000012
0
-1300.1
1300.123456789
0.0000000012345678912345
0
1500.61345975
-202.004285
-8.60917475
0
-218.302869584
200.0000123456789
0","4.12345678888000000005
0.0234567902345678912345
1290
-18.3028572383211",
17093,Total Circle,Bronze I,"좌표평면상의 점의 배열 P = P
1
, P
2
, ⋯, P
N
와 Q = Q
1
, Q
2
, ⋯, Q
M
이 있다. Q 배열 상의 한 점을 중심으로, P 배열 상의 모든 점을 포함하는 최소 넓이의 원의 반지름 중 최댓값을 구하시오.","첫 줄에 N과 M이 주어진다. (1 ≤ N, M ≤ 1000)


N개의 줄에 걸쳐 x와 y가 주어지며, 이는 P
i
 = (x,y)라는 뜻이다. (-10
6
 ≤ x,y ≤ 10
6
)


M개의 줄에 걸쳐 x와 y가 주어지며, 이는 Q
i
 = (x,y)라는 뜻이다. (-10
6
 ≤ x,y ≤ 10
6
)","Q 배열 상의 한 점을 중심으로, P 배열 상 모든 점을 포함하는 최소 넓이의 원의 반지름 중 최댓값의 제곱을 출력한다.","1 1
0 0
1000000 1000000

---

4 4
2 6
3 1
1 7
8 9
4 3
5 2
9 6
6 4","2000000000000

---

65",
13203,읽어내기,Platinum I,"고대 유적을 발굴하던 성원이는 커다란 비석을 찾아내었고, 학계에 보고하기 위해 그 비석에 적힌 글을 해독하고 있다. 하지만 이 비석은 오랜 세월을 거치며 글자들이 지워져 잘 보이지 않게 되었다.


이 비석이 만들어질 당시의 사람들은 비석에 왕의 이름을 써 놓는 것을 좋아했다. 비석의 글자들 중 일부 (연속하지 않아도 된다)를 골라 순서대로 조합하여 왕의 이름이 되는 경우의 수가 많을수록 더 좋아했다고 한다. 또 이 당시 사람들은 말을 길게 하는 것을 좋아하지 않아 왕의 이름은 항상 5글자 이내였다고 한다.


방사선 연대 측정을 통해 이 비석이 묻힐 당시의 왕의 이름을 알게 된 성원이는 이 비석에 왕의 이름을 읽어낼 수 있는 경우의 수가 몇 가지인지 알고 싶게 되었다. 그런데 비석의 글씨는 잘 보이지 않으므로 연구가 진행됨에 따라 비석의 일부의 해석이 달라질 수 있고, 그 때마다 이름을 읽어내는 경우의 수를 알고 싶어한다. 성원이를 도와 경우의 수를 계산하는 프로그램을 작성해 주자.","첫 번째 줄에 테스트 케이스의 수 
T
 가 주어진다.


각 테스트 케이스의 첫 번째 줄에는 비석의 글자 수 
N
(1 ≤ 
N
 ≤ 200, 000)과 왕의 이름의 길이 
M
(1 ≤ 
M
 ≤ 5), 그리고 비석의 해석이 바뀌는 횟수 
Q
(0 ≤ 
Q
 ≤ 100, 000)가 주어진다. 둘째 줄에는 비석에 적힌 글의 첫 번째 해석이 하나의 문자열로 주어진다. 이는 영어 알파벳 대문자로만 구성되어 있다. 셋째 줄에는 왕의 이름이 하나의 문자열로 주어지며, 마찬가지로 영어 알파벳 대문자로만 구성되어 있다. 넷째 줄부터 
Q
개의 줄에는 한 줄마다 두 개의 정수 
A
i
 , 
B
i
 와 문자열 
S
i
 가 주어진다. (1 ≤ 
A
i
 ≤ 
B
i
 ≤ N, len(
S
i
) = 
B
i
 − 
A
i
 + 1) 이는 비석의 
A
i
 번째 문자부터 
B
i
 번째 문자까지의 해석이 
S
i
 로 바뀐다는 뜻이다. 
S
i
 의 길이 총합은 2, 000, 000 이하이다.","각 테스트 케이스마다, 
Q
 + 1개의 줄에 한 줄에 하나의 정수를 출력한다. 
i
번째 줄에는 비석의 
i
번째 해석에서 왕의 이름을 읽을 수 있는 경우의 수를 출력한다. 답이 커질 수 있으므로 1, 000, 000, 007로 나눈 나머지를 출력한다.","1
20 5 1
MIDASMIDASMIDASMIDAS
MIDAS
2 19 MMMIIIIDDDDAAAASSS","56
1024",
20958,아린과 슬롯머신,Platinum V,"아린은 강원랜드로 휴가를 떠났다(아린은 감염병 예방을 위한 정부의 방역지침을 준수한다). 강원랜드에서 가장 인기 있는 게임은 슬롯머신이다. 슬롯머신을 구경하던 아린은 놀라 자빠질 수밖에 없었다. 잭팟이 터질 경우 거액의 당첨금을 받을 수 있다는 정보를 입수하였기 때문이다. 아린은 잭팟을 터트려 집도 사고 차도 사고 맛있는 것도 많이 먹기로 결심하였다.


아린은 칸의 개수가 N개인 슬롯머신을 가지고 있다. 슬롯머신의 레버를 당길 때마다 각 칸에는 임의의 양의 정수가 표시된다. 이때 모든 칸에 7이 표시되면 잭팟이 터졌다고 하며, 잭팟이 터지면 거액의 당첨금이 지급된다.


하지만 슬롯머신을 작동시키기 위해서는 돈이 필요하다. 검소하기로 유명한 아린은 슬롯머신 따위에 돈을 낭비하지 않는다. 슬롯머신을 작동시키는 대신, 아린은 슬롯머신의 각 칸에 대하여 다음과 같은 연산을 무한히 수행할 수 있다. 구간 [i, i + M)과 7이 아닌 소수 p를 선택한다. 그리고 구간에 속하는 수 중 p로 나누어떨어지는 모든 수를 p로 나눈다. 즉, S
i
, S
i+1
, ..., S
i+M-1
 중 p로 나누어떨어지는 모든 수를 p로 나눈다. (1 ≤ i ≤ N - M + 1, p ≠ 7)


슬롯머신의 상태가 주어졌을 때, 잭팟을 터트리기 위하여, 즉 모든 수를 7로 바꾸는 데 필요한 최소 연산 횟수를 구하는 프로그램을 작성하시오.","첫 번째 줄에 슬롯머신의 칸의 개수 N과 구간의 길이 M이 주어진다.


두 번째 줄에 슬롯머신의 각 칸에 표시된 N개의 정수 S
1
, S
2
, ..., S
N
이 주어진다.


모든 입력은 공백으로 구분되어 주어진다.",첫 번째 줄에 잭팟을 터트리기 위하여 필요한 최소 연산 횟수를 출력한다. 모든 수를 7로 바꿀 수 없다면 -1을 출력한다.,"5 3
14 21 70 105 35

---

7 3
7 8 9 10 11 12 13","3

---

-1",입력의 양이 방대하므로 빠른 입력을 사용할 것을 권장한다.
15956,숏코딩,Platinum I,"코드 페스티벌 온라인 예선에 참가하고 있던 라이언은 이제 남은 시간이 
00:00:00
밖에 없다는 것을 깨닫게 되었다. 라이언은 이미 머릿속에서 풀이를 구상하고 코딩도 완료했기 때문에, 이를 그대로 타이핑하기만 하면 된다.




지금 라이언은 변수들과 정수들끼리 같은지 다른지 비교하는 간단한 조건문 (conditional expression) 
S
를 작성하고자 한다. 자세히 설명하자면,




라이언이 작성하는 
변수
의 이름은 영문 알파벳으로만 구성된 문자열이다. 예를 들어, 
kakao
, 
COde
, 
festival
은 변수의 이름이 될 수 있지만, 
C0de
, 
2018
, 
hello_world
는 변수의 이름이 될 수 없다. 변수는 정수 값을 저장하고 있으며, 변수의 
값
은 해당 변수가 저장하고 있는 정수 값을 의미한다.


라이언이 작성하는 
정수
는 무조건 -10
9
 이상 10
9
 이하이다. 0을 제외한 정수는 숫자 
0
으로 시작하지 않으며, 0을 표기하는 유일한 방법은 
0
이다. 예를 들어, 라이언은 
0
, 
123456
, 
-987654321
 과 같은 정수는 작성할 수 있지만, 
-0
, 
0123
, 
00000
, 
-009876
, 
999999999999999
와 같은 정수는 작성할 수 없다.


단항식
은 
변수
 또는 
정수
이다.


라이언은 아래 두 개의 
비교 연산자
를 사용하여 
논리식
을 만든다.
	


같음 연산자
 
==
: 
<a>==<b>
와 같이 사용하며, 두 단항식 
<a>
와 
<b>
의 값을 계산하여, 같으면 
true
를, 다르면 
false
를 반환한다.


다름 연산자
 
!=
: 
<a>!=<b>
와 같이 사용하며, 두 단항식 
<a>
와 
<b>
의 값을 계산하여, 다르면 
true
를, 같으면 
false
를 반환한다.


위의 두 연산자 모두, 연산자의 좌변과 우변에는 
오직
 단항식만이 올 수 있다. 예를 들어, 
(a==b)!=(b==c)
는 
!=
의 좌변과 우변에 단항식이 아닌 논리식이 들어 있으므로 라이언이 사용하는 논리식이 아니다.






라이언은 논리곱 연산자 
&&
로 
한 개 이상의
 논리식들을 연결하여 
조건문
을 만든다. 연결한 논리식들이 
모두
 
true
를 반환할 때에만 
true
, 그렇지 않다면 
false
를 반환하도록 할 것이다. 연결할 때에 공백 등을 삽입하지 않는다. 예를 들어, 라이언이 세 논리식 
a==b
, 
b!=c
, 
1!=a
를 연결하고자 한다면, 
a==b&&b!=c&&1!=a
와 같이 연결한다.




라이언이 작성하고자 하는 조건문 
S
는 위 문단에서 언급한 방법으로만 만들 수 있음이 보장된다.


하지만, 라이언은 남은 시간에 비해 
S
의 길이가 너무 길다고 생각하여, 
S
와 동치이면서 위에서 제시된 방법으로 만들 수 있는 길이가 가장 짧은 조건문 
S'
을 대신 입력할 생각이다. 두 조건문 
T
1
과 
T
2
가 동치라는 것은, 어떤 변수 (조건문에 등장하지 않는 모든 가능한 변수도 포함) 에 어떤 값 (라이언이 작성하지 않는 정수도 가능)을 넣더라도 
T
1
의 참/거짓 여부와 
T
2
의 참/거짓 여부가 같다는 것이다.


라이언을 위해, 
S'
을 대신 구해주는 프로그램을 작성하자. 
S'
이 여러 가지 있다면, 그 중 하나를 아무거나 구해주면 된다.","첫 번째 줄에 라이언이 입력하고자 하는 조건문 
S
(1 ≤ |
S
| ≤ 10
6
)가 주어진다.","첫 번째 줄에 
S
와 동치이면서, 문제 본문에 제시된 방법으로 만들 수 있는 길이가 가장 짧은 조건문 
S'
을 출력한다.","festival==kakao&&festival==2018&&haha==123456&&hoho!=123456

---

kakaocodefestival==-20180804&&hello!=-20180804

---

a==b&&b==c&&c==a

---

int==float

---

a==A&&B==b","festival==2018&&kakao==2018&&haha==123456&&hoho!=haha

---

kakaocodefestival==-20180804&&hello!=-20180804

---

a==b&&a==c

---

int==float

---

A==a&&b==B",
16726,영과일 학회방,Platinum III,"영과일은 학회방이 없어질 위기에 처했지만 우수한 학회원들의 실력을 인정받아 학회방을 다시 배정 받을 수 있었다! 이에 행복해진 영과일 총무부장 재현이는 새로운 마음으로 1 × 2, 1 × 1 타일을 구매하여 학회방 바닥을 모두 덮으려고 한다.


알뜰한 재현이를 도와 학회방 도면이 주어졌을 때 학회방 바닥을 모두 덮을 수 있는 최소의 타일 개수를 출력하는 프로그램을 작성하시오.","첫 번째 줄에 학회방 도면의 행의 수를 나타내는 N(1 ≤ N ≤ 50)과 열의 수를 나타내는 M(1 ≤ M ≤ 50)이 주어진다.


두 번째 줄부터 N개의 줄에 학회방 도면의 정보를 나타내는 길이가 M인 문자열이 주어진다. i+1번째 줄의 j번째 문자가 ‘.’ 일 경우 바닥, ‘X’ 일 경우 기둥을 나타낸다.",첫 번째 줄에 필요한 타일의 최소 개수를 출력한다.,"3 4
.X..
...X
...X",5,
29760,건물 방문하기,Gold II,"푸앙이는 $H\times W$개의 방이 있는 건물에서 $N$개의 방을 모두 방문하려고 한다.


건물은 $H$층이고 각 층에 $W$개의 방이 있는 직사각형 모양이다. 각 층의 가장 왼쪽에 있는 방부터 순서대로 $1$호, $2$호, $\cdots$, $W$호이다.


이 건물은 특이한 구조로 되어 있어 같은 층에 있는 인접한 방으로 이동하는 데는 $1$초가 걸리지만, 같은 호의 인접한 방으로 이동하는 데는 $100$초가 걸린다.


같은 층에 있는 인접한 방의 호수의 차는 $1$이고, 같은 호의 인접한 방의 층수의 차는 $1$이다.


푸앙이는 현재 $1$층 $1$호에 있다. 푸앙이가 방문하고자 하는 방의 위치가 방문 순서와 상관 없이 주어질 때, 주어진 $N$개의 방을 방문하는 데 걸리는 최소 시간을 구하시오.","첫 번째 줄에 방문하고자 하는 방의 개수 $N$, 건물의 층과 호의 개수 $H$, $W$이 공백으로 구분되어 정수로 주어진다. $(1 \le N \le H \times W;$ $1 \le H \le 1\,000;$ $1 \le W \le 100)$


두 번째 줄부터 $N$개의 줄에 걸쳐 방문하고자 하는 방의 위치가 주어진다. 그중 $i$번째 줄에는 방의 위치 $X_i$층, $Y_i$호가 공백으로 구분되어 정수로 주어진다. $(1 \le X_i \le H;$ $1 \le Y_i \le W)$


방문하고자 하는 방의 위치는 서로 다르다.",주어진 $N$개의 방을 방문하는 데 걸리는 최소 시간을 출력한다.,"3 10 10
1 9
4 2
6 4",517,
1178,간선 추가,Platinum V,"그래프에 최소 개수의 간선을 추가해서 한붓그리기가 가능한 연결 그래프로 만드는 프로그램을 작성하시오.


한붓그리기가 가능하다는 것은 한 번 지난 간선을 다시 지나지 않으면서 모든 간선을 지나는 경로가 존재한다는 것을 의미한다. 시작점과 끝점은 같을 수도 있고 다를 수도 있다.","첫째 줄에 정점의 개수 V와 간선의 개수 E가 주어진다. (2 ≤ V ≤ 1,000, 1 ≤ E ≤ V×(V-1)/2) 정점에는 1부터 V까지 번호가 매겨져 있다고 생각한다. 이어서 E개의 줄에 걸쳐 간선을 이루는 두 점 a와 b가 주어진다. a와 b는 서로 다르며, 입력으로 주어지는 모든 간선 역시 서로 다르다.",첫째 줄에 추가해야 하는 간선 개수의 최솟값을 출력한다.,"5 3
1 2
1 3
4 5",1,
3344,N-Queen,Platinum II,"8*8 체스보드에 8개의 퀸을 서로 공격하지 못하게 놓는 문제는 잘 알려져 있는 문제이다. 퀸은 같은 행, 열, 또는 대각선 위에 있는 말을 공격할 수 있다. 이 문제의 한가지 정답은 아래 그림과 같다.







	이 문제의 조금 더 일반화된 문제는 Franz Nauck이 1850년에 제기했다.



	N*N 보드에 N개의 퀸을 서로 다른 두 퀸이 공격하지 못하게 놓는 경우의 수는 몇 가지가 있을까?



	이 문제는 N>3인 경우에 경우의 수가 적어도 1개 라는 것이 증명되어 있다. 예를 들어, N=26인 경우에 22317699616364044가지 방법이 있다.



	N이 주어졌을 때, N*N 보드에 N개의 퀸을 서로 다른 두 퀸이 공격하지 못하게 놓는 한가지 경우를 출력하는 프로그램을 작성하시오.","첫째 줄에 N이 주어진다. N은 8, 26, 213, 2012, 99991, 99999중 하나이다.","N개의 줄을 출력해야 한다. i번째 줄에는 하나의 정수를 출력해야 하고, 이 정수는 i번째 행에 있는 퀸이 있는 열의 번호이다.",8,"3
6
8
1
4
7
5
2",
11920,버블 정렬,Platinum II,"버블 정렬이란, 두 인접한 원소를 검사하여 자리를 바꾸는 방식으로 길이가 N인 수열을 정렬하는 알고리즘이다. 버블 정렬은 아래와 같은 단계를 총 N번 진행하면 된다.




첫 번째 값과 두 번째 값을 비교하여 첫 번째 값이 더 크면 자리를 바꾼다.


두 번째 값과 세 번째 값을 비교하여 두 번째 값이 더 크면 자리를 바꾼다.


…


N - 1번째 값과 N번째 값을 비교하여 N - 1번째 값이 더 크면 자리를 바꾼다.




세찬이는 버블 정렬의 결과는 당연히 알기에 버블 정렬의 중간 과정을 알아보려고 한다. 하지만 N이 매우 크므로 위와 같은 단계를 K번 하면 시간이 오래 걸린다. 세찬이를 도와 버블 정렬의 중간 과정을 구하는 프로그램을 작성하여라.","첫 번째 줄에는 N과 K가 주어진다.


두 번째 줄에는 처음 수열의 상태가 주어진다. 즉, 처음 수열을 이루는 N개의 정수가 공백을 사이로 두고 차례대로 주어진다.




1 ≤ N ≤ 100,000


1 ≤ K ≤ N


수열의 각 항은 1 이상 1,000,000,000 이하의 정수이다.",위 단계를 K번 한 후 수열의 상태를 출력한다.,"4 1
62 23 32 15",23 32 15 62,
14498,학급비 낭비하기,Platinum II,"욱제에게 미션이 주어졌다! 바로 학급비(서울시민들의 세금)로 구매할 물품을 정하는 것이다. 욱제는 학급비를 낭비(?)할 생각에 신이 났다. 본인(경기도민)이 낸 세금이 아니기 때문이다. 욱제는 낭비(?)에 적합한 두 개의 물품을 정해서 친구들의 의견을 수렴하기로 했다. 그 두 개의 물품은 바로 뽁뽁이와 꼭꼭이이다.






(뽁뽁이와 꼭꼭이)


욱제의 시장조사 결과, 뽁뽁이는 n개의 색상이 있고 꼭꼭이는 m개의 모델이 있다. 욱제는 k명의 친구들에게 다음과 같은 질문을 던졌다: ""사고 싶은 뽁뽁이 색상과 사고 싶지 않은 꼭꼭이 모델을 하나씩 고르거나, 사고 싶지 않은 뽁뽁이 색상과 사고 싶은 꼭꼭이 모델을 하나씩 골라라"" 


욱제는 최대한 많은 친구들을 만족시키고 싶어 한다. 친구들은 자신의 두 요구사항이 모두 반영되어야 만족한다고 한다. 하지만 모두를 만족시키긴 힘들기 때문에 욱제는 만족하지 못하게 되는 친구들에게 미안함의 표시로 사탕을 하나씩 사주려고 한다. (사실 사탕도 학급비이다)


욱제는 최소 몇 개의 사탕을 준비해야할까?","첫째 줄에 뽁뽁이의 색상의 수 n, 꼭꼭이의 색상의 수 m, 친구들의 수 k가 주어진다. (1 ≤ n, m ≤ 128, 1 ≤ k ≤ 512)


이후 k개의 줄에 걸쳐 n
i
, m
i
, c
i
가 주어진다. n
i
와 m
i
는 뽁뽁이와 꼭꼭이의 색상(모델) 번호를 의미하며 c
i
가 0이면 n
i
를, 1이면 m
i
를 구매하길 원한다는 뜻이다.",욱제가 최소  몇 개의 사탕을 준비해야하는지 출력한다.,"1 2 4
1 1 0
1 2 0
1 1 0
1 2 1

---

2 3 5
1 3 0
2 3 0
2 2 1
2 1 0
1 3 1","1

---

2",
12909,그래프 만들기,Platinum V,"N개의 노드와 N-1개의 간선으로 이루어져 있는 그래프를 만들려고 한다. 이 그래프는 연결되어 있어야 한다.


예를 들어, 아래 그림은 N=5개의 노드와 N-1=4개의 간선으로 이루어져 있는 그래프이다.




간선은 두 노드를 연결할 수 있다. 노드의 차수는 노드와 연결되어 있는 간선의 개수이다. 위의 그림에서 A의 차수는 3이고, B의 차수는 1이다.


N이 주어졌을 때, 적절히 그래프를 만들어서 그래프의 점수를 최대로 만들려고 한다. 그래프의 점수는 각 노드의 점수를 더해서 구할 수 있으며, 각 노드의 점수는 차수에 의해서 결정된다.


입력으로, 차수에 대한 점수가 주어졌을 때, 만들 수 있는 그래프의 점수의 최댓값을 구하는 프로그램을 작성하시오.","첫째 줄에 그래프의 정점의 개수 N이 주어진다. (1 ≤ N ≤ 51)


둘째 줄에는 각 차수의 점수가 주어진다. (0 ≤ 점수 ≤ 10,000)


점수는 차수 1인 노드의 점수, 차수 2인 노드의 점수, ..., 차수 N-1인 노드의 점수 순서대로 주어진다.",첫째 줄에 만들 수 있는 그래프 중에서 점수가 최대가 되는 것의 점수를 출력한다.,"4
1 3 0

---

5
0 0 0 10

---

7
1 2 3 4 5 6

---

4
5 0 0

---

8
1 3 2 5 3 7 5","8

---

10

---

12

---

15

---

20","예제 1의 경우에 차수가 1인 노드의 점수는 1, 2인 노드의 점수는 3, 3인 노드의 점수는 0이다.


아래 그림과 같은 그래프를 만들면 그래프의 점수가 최대가 된다.




그래프의 차수를 계산해보면 1, 2, 2, 1이다. 따라서, 합은 1+3+3+1 = 8이 된다.


예제 2의 경우에 가능한 정답은 아래 그림과 같다."
23257,비트코인은 신이고 나는 무적이다,Gold III,"코인 경력 4년차, 차트에 통달한 찬호는 이전 $N$개의 월봉을 통해 다음 월봉의 절댓값을 예측할 수 있는 아래의 공식을 만들어냈다.


(다음 월봉의 절댓값) = 이전 $N$개의 월봉 중 중복을 허용해 $M$개를 골라 절댓값들을 
bitwise xor
 한 것 중 최대


$N$, $M$, 이전 월봉들 $A_i$들이 주어졌을 때 다음 월봉의 절댓값을 구해보자.","첫째 줄에 $N$, $M$이 주어진다.


둘째 줄에 $A_1, A_2, \cdots , A_N$이 주어진다.",다음 월봉의 절댓값을 출력하라.,"3 2
-1 2 3",3,
16855,"일해라, 류트!",Platinum IV,"디디포스 주식회사에 다니는 류트는 회사의 코딩 테스트를 출제하는 업무를 맡게 되었다. 그는 '고양이 소개팅'이란 문제를 출제했지만, 일하기 귀찮다는 이유로 정해를 짜지 않았고
[1]
 디디에 의해 해고당했다. 일자리를 잃은 류트는 러시아로 이사를 가서 새로운 직업을 찾게 되었다.


우여곡절 끝에 러시아의 화학 공학 기업에서 근무하게 된 류트는 블라디보스토크에서 모스크바로 몇 개의 파이프를 거쳐 여러 화학 약품을 옮기려고 한다. 블라디보스토크에서 모스크바로 화학 약품을 파이프를 통해 수송하려면 총 M개의 파이프 P
1
, P
2
, ..., P
M
을 차례로 거쳐야 한다. 각각의 i = 1, 2, ..., M 에 대하여 P
i
의 길이는 L
i
이다.


류트가 옮기려는 화학 약품은 총 N가지 종류이다. 편의상 이들에 1, 2, 3, ..., N의 번호를 붙이자. 참고로, 각각의 1 ≤ i < j ≤ N에 대하여 화학 약품 i는 화학 약품 j 보다 먼저 수송되어야 한다.


각각의 i = 1, 2, ..., N에 대하여 화학 약품 i의 점성계수는 r
i
이다. 점성계수가 r인 화학 약품을 길이가 L인 파이프로 시각 t부터 흘려보내기 시작했다면, 이 화학 약품은 시각 t+rl 직전에 해당 파이프를 완전히 빠져나온다. 다시 말해, [t, t+rl) 동안 해당 파이프를 통과한다.


류트는 여러 화학 약품이 섞일 것을 염려하여, 각각의 i = 1, 2, ..., M에 대하여 하나의 화학 약품이 P
i
를 통과한 후, C
i
 만큼의 시간이 지나기 이전에는 다른 화학 약품이 P
i
에 들어오는 일이 없도록 하고자 한다. (이러한 C
i
들은 류트가 나름의 기준을 가지고 정해놓은 값으로 입력을 통해 주어질 것이다.)


또한, i = 1, 2, ..., M-1에 대하여 화학 약품이 P
i
를 빠져 나온 직후에 바로 P
i+1
로 들어가야한다. 다시 말해, 화학 약품이 파이프들을 거쳐 흘러가는 도중에 멈추어서는 안 된다.


류트가 시각 0부터 시작하여 화학 약품들을 파이프로 흘려보낸다고 하자. 류트는 최소 시간 안에 수송 작업을 완료하고자 한다. 류트가 최소 시간 안에 수송 작업을 완료할 경우 i = 1, 2, ..., N에 대하여 화학 약품 i가 P
N
을 빠져나오는 시각을 T
i
라 하자. 이 때, T
1
, T
2
, ..., T
N
을 구해보자.




[1]
 실제로 정해를 짜지 않았습니다.😡 이를 한심하게 여긴 디디가 대신 풀어준 바람에 류트는 풀이도 모릅니다.","입력의 첫 줄에 N, M이 사이에 공백을 두고 주어진다.


입력의 둘째 줄에 L
1
, L
2
, ..., L
M
이 사이에 공백을 두고 주어진다.


입력의 셋째 줄에 C
1
, C
2
, ..., C
M
이 사이에 공백을 두고 주어진다.


입력의 넷째 줄에 r
1
, r
2
, ..., r
N
이 사이에 공백을 두고 주어진다.","출력의 첫 줄에 T
1
, T
2
, ..., T
N
을 사이에 공백을 두고 출력한다.","3 3
3848 3073 1988
73 67 76
3 21 46",26727 198706 502312,
12431,장터판 (Small),Gold IV,"당신은 지리산 등반 도중 장이 열리는 장터를 발견하였다. 많은 사람들이 모여있는 와중에, 어떤 사람이 게임을 주최하고 있었다.


이 게임에서는 탁자 위에 
N
줄 
M
열의 격자가 있는 게임판을 이용한다. 격자의 각 칸에 하나씩 
K
면 다면체가 있다.


게임은 다음과 같이 진행된다. 게임 주최자는 다면체 중 일부를 특정 면이 보이도록 고정시켜놓고, 일부는 자유로이 움직일 수 있도록 한다. 그후, 이 게임판을 흔드는데, 그러면 고정되지 않은 다면체들(이들을 
'자유로운 다면체'
라고 한다)은 흔들리다가 
K
면 중 한 면이 선택되어 보이게 된다. 이때, 
K
면 중 어떤 면이 보일 확률은 모든 면에 대해서 같으며 각각의 다면체에 대해 독립적이다.


게임판이 멈추면 각 칸에 대해 점수를 매기게 된다.


1) 이 칸의 다면체를 포함하여 가로/세로/대각선 으로 연속해서 4개가 같은 면을 가리키는 경우가 존재 - 
S
4
점

2) 1)에 해당하지 않고 연속한 3개에 대해서는 이런 경우가 존재 - 
S
3
점

3) 2)에 해당하지 않고 연속한 2개에 대해서는 이런 경우가 존재 - 
S
2
점


각 다면체에 대해 나온 점수를 모두 합하면 그 게임의 점수가 된다.


어떤 게임 도중, 다면체를 고정시키는 작업이 완성되었고 이제 게임판을 흔드는 차례가 되었다.


당신은 이 게임의 결과가 궁금해졌다. 이 게임판을 흔들었을 때 얻을 수 있는 점수의 기댓값은 몇 점일까?","입력의 첫 줄에는 테스트 케이스의 숫자 
T
가 주어진다.


각 테스트 케이스는 다음과 같이 주어진다.



N M K S
4
 S
3
 S
2


F
1,1
 F
1,2
 ... F
1,M


F
2,1
 F
2,2
 ... F
2,M


...

F
N,1
 F
N,2
 ... F
N,M





각 케이스의 첫 줄에는 다음과 같이 정수 6개가 주어진다: 
N
은 게임판의 행 수, 
M
은 열 수를 나타내며, 
K
는 다면체의 면의 수이다. 
S
4
, 
S
3
, 
S
2
는 문제에 설명된 해당 점수이다.


두 번째 줄부터 
N
개의 줄은 순서대로 게임판의 가장 위부터 게임판의 각 행에 존재하는 다면체들의 상태를 나타낸다. 각 줄은 
M
개의 숫자로 이루어져 있으며, 그 행의 왼쪽부터의 다면체의 상태를 나타낸다. 고정된 다면체는 보여지는 면의 숫자 1부터 
K
까지의 한 자리 숫자로 나타내어지고, 자유로운 다면체는 '?'로 나타내어진다.


제한




1 ≤ 
T
 ≤ 50.


2 ≤ 
K
 ≤ 9.


0 ≤ 
S
2
 ≤ 
S
3
 ≤ 
S
4
 ≤ 100.


2 ≤ 
N
 ≤ 8, 2 ≤ 
M
 ≤ 8.


각 입력 게임판에서, 자유로운 다면체의 수는 0개 이상 4개 이하이다.","각 테스트 케이스에 대한 출력은 ""Case #x: y"" 형태로 이루어져야 한다. x는 1부터 시작되는 케이스 번호이고, y는 주어진 케이스에 대한 점수 기댓값이다. 10
-6
 범위의 절대/상대오차는 정답으로 간주된다.","2
2 3 3 40 30 10
121
??1
4 3 4 100 30 20
2?2
4?1
3?3
1?4","Case #1: 53.3333333
Case #2: 187.7734375",
15939,쉬운 최단경로 문제,Diamond III,"농부 John의 목장은 특이하게 생겼다. 볼록 다각형을 이루는 N개의 말뚝이 있고, 각 말뚝 쌍에 대해 두 말뚝을 선분으로 잇는 밧줄이 존재한다. 이 밧줄은 높이가 상당해서 소들이 넘어 다니기 어렵다.


소 Alice와 Bessie는 서로의 가장 친한 친구이다. 하지만 농부 John이 그들을 떨어뜨려 놓았기 때문에 현재는 멀리 위치해 있다.




위 그림은 N=4일때의 한 예를 그림으로 나타낸 것이다. 총 6개의 밧줄이 존재한다.


Alice는 Bessie가 있는 곳으로 놀러 가려고 한다. 하지만 밧줄을 넘는 것은 쉽지 않기 때문에, 넘는 밧줄의 개수를 최소로 하여 가려고 한다.




위 그림의 경우, 밧줄을 2번 넘어서 가는 것이 최적임을 알 수 있다.


농부 John이 두 소의 위치를 자주 바꾸기 때문에, Q개의 위치 쌍에 대해 각각의 경우 넘어야 하는 밧줄의 최소 개수를 구하고자 한다. Alice와 Bessie를 도와 문제를 해결해주자.


두 개 이상의 밧줄이 교차하는 점을 통해 넘어가는 것은 한꺼번에 넘은 것으로 인정되지 않는다. 예를 들어 3개 밧줄이 교차하는 점을 통해 한꺼번에 넘어도 3번으로 센다. 또한, 같은 밧줄을 여러 번 넘는 것은 여러 번 센다.","첫 번째 줄에 말뚝의 수 N(3 ≤ N ≤ 5,000)이 주어진다. 두 번째 줄부터 N개의 줄에는 2개의 정수 x와 y가 주어진다. 이는 말뚝들의 좌표를 나타낸다. 말뚝의 정보는 반시계방향 순서대로 주어진다.


N+2번째 줄에 쿼리의 개수 Q(1 ≤ Q ≤ 10,000)가 주어진다. N+3번째 줄부터 Q개의 줄에는 4개의 정수 x1, y1, x2, y2가 주어진다. (x1, y1)은 Alice의 좌표를, (x2, y2)은 Bessie의 좌표를 나타낸다.


주어지는 모든 좌표의 절댓값은 10
8
 이하이다.


N개의 말뚝은 내각이 180도 미만인 볼록 다각형을 이루고 있으며, 주어지는 소들의 위치는 밧줄 위에 있지 않다. 또한, 각 쿼리에 대해 N개의 말뚝 및 두 소의 좌표는 서로 다르다.",쿼리가 주어진 순서대로 Q개의 줄에 걸쳐 각 줄에 그 쿼리에 대한 답을 출력한다.,"4
-5 -5
5 -5
5 5
-5 5
3
0 2 0 -2
2 0 -2 0
6 0 0 -6","2
2
0",
24092,알고리즘 수업 - 퀵 정렬 3,Silver I,"오늘도 서준이는 퀵 정렬 수업 조교를 하고 있다. 아빠가 수업한 내용을 학생들이 잘 이해했는지 문제를 통해서 확인해보자.


N
개의 서로 다른 양의 정수가 저장된 배열 A가 있다. 퀵 정렬로 배열 A를 오름차순 정렬할 경우 정렬 과정에서 배열 A가 배열 B와 같은 경우가 발생하는지 확인해 보자. 초기 상태 배열 A도 정렬 과정에서 발생 가능한 경우로 생각하자.


크기가 
N
인 배열에 대한 퀵 정렬 의사 코드는 다음과 같다.



quick_sort(A[p..r]) { # A[p..r]을 오름차순 정렬한다.
    if (p < r) then {
        q <- partition(A, p, r);  # 분할
        quick_sort(A, p, q - 1);  # 왼쪽 부분 배열 정렬
        quick_sort(A, q + 1, r);  # 오른쪽 부분 배열 정렬
    }
}

partition(A[], p, r) {
    x <- A[r];    # 기준원소
    i <- p - 1;   # i는 x보다 작거나 작은 원소들의 끝지점
    for j <- p to r - 1  # j는 아직 정해지지 않은 원소들의 시작 지점
        if (A[j] ≤ x) then A[++i] <-> A[j]; # i값 증가 후 A[i] <-> A[j] 교환
    if (i + 1 != r) then A[i + 1] <-> A[r]; # i + 1과 r이 서로 다르면 A[i + 1]과 A[r]을 교환
    return i + 1;
}","첫째 줄에 배열 A, B의 크기 
N
(5 ≤ 
N
 ≤ 10,000)이 주어진다.


다음 줄에 서로 다른 배열 A의 원소 A
1
, A
2
, ..., A
N
이 주어진다. (1 ≤ A
i
 ≤ 10
9
)


다음 줄에 배열 B의 원소 B
1
, B
2
, ..., B
N
이 주어진다. (1 ≤ B
i
 ≤ 10
9
)","퀵 정렬로 배열 A를 오름차순 정렬하는 과정에서 배열 A가 배열 B와 같은 경우가 발생하면 1, 아니면 0을 출력한다.","5
2 5 1 4 3
2 5 1 4 3

---

5
2 5 1 4 3
2 1 5 4 3

---

5
2 5 1 4 3
1 2 3 5 4","1

---

1

---

0",
2597,줄자접기,Silver III,"준성이는 1㎝ 간격으로 눈금이 매겨져 있는 줄자를 가지고 있다. 그 줄자에 있는 서로 다른 눈금 6개에 한 눈금에 하나씩 점이 찍혀 있는데, 빨간 점, 파란 점, 노란 점이 각각 두 개씩 있다.


준성이는 먼저 빨간 점이 만나도록 줄자를 접었다. 그런 후 두 파란 점이 만나도록 줄자를 접고, 또 다시 두 노란 점이 만나도록 줄자를 접었다. 줄자는 투명하여 접더라도 점들을 잘 볼 수 있다. 어떤 색깔의 두 점이 만나도록 줄자를 접었을 때, 그 다음에 접으려는 색깔의 두 점이 이미 만나고 있으면, 그 두 점에 대해서는 줄자를 접지 않는다.


예를 들어 길이 10㎝ 인 줄자에 아래 그림과 같이 2㎝ 와 7㎝ 위에에 두 빨간 점이 찍혀 있고, 5㎝ 와 4㎝위치에 파란 점이, 10㎝ 와 3㎝ 위치에 노란 점이 찍혀 있다고 하자. (그림에서 빨간 점은 별표로, 파란 점은 동그라미, 그리고 노란 점은 네모로 표시되어 있다.) 빨간 두 점이 만나도록 줄자를 접으면 줄자의 4.5㎝ 위치에서 접히고 4㎝ 와 5㎝ 눈금이 서로 만나게 된다. 그러면 줄자의 왼쪽 부분의 길이는 4.5㎝ 이고 오른쪽 부분의 길이는 5.5㎝가 되어, 접힌 줄자의 길이는 5.5㎝ 가 된다. 파란 두 점은 이미 만나므로 줄자를 접지 않고, 그런 다음 노란 두 점이 만나도록 접으면 줄자의 길이는 3.5㎝ 가 된다.




줄자의 길이와 각 색깔의 점들이 찍혀있는 위치가 주어질 때, 준성이가 빨간 색, 파란 색, 노란 색의 순서로 두 점이 만나도록 줄자를 접으면 줄자의 길이가 얼마가 되는지를 구하는 프로그램을 작성하시오.","첫째 줄에 줄자의 길이가 입력된다. 줄자의 길이는 10㎝ 이상, 1,000㎝ 이하이고 단위를 나타내는 ㎝은 입력되지 않는다. 둘째 줄에는 두 빨간 점의 위치를 나타내는 정수가 빈칸을 사이에 두고 입력된다. 셋째 줄에는 두 파란 점의 위치가, 넷째 줄에는 두 노란 점의 위치를 나타내는 정수가 빈칸을 사이에 두고 입력된다. 모든 점들의 위치는 서로 다르다.",한 줄에 접은 후의 줄자의 길이를 소수점 이하 한자리까지 출력한다. 소수점 이하 한자리가 0 이면 0 도 출력한다.(예 4.0),"10
2 7
5 4
10 3",3.5,
25943,양팔저울,Silver IV,"$1$부터 $n$까지 번호가 매겨진 $n$개의 자갈이 있다. 이 자갈들을 다음 절차에 따라 양팔저울에 올려놓는다.




$1$번 자갈을 왼쪽, $2$번 자갈을 오른쪽에 올려놓는다.


$i = 3, \dots , n$번 자갈 각각에 대해서 차례로 다음 과정 중 하나를 수행한다.
	


만약 양팔저울이 평형을 이루는 경우, $i$번 자갈을 왼쪽에 올려 놓는다.


만약 양팔저울이 평형을 이루지 않는 경우, $i$번 자갈을 가벼운 쪽에 올려 놓는다.








모든 자갈을 위의 규칙에 따라 올려 놓은 후에도 양팔저울은 평형을 이루지 않을 수 있다. 이경우 가벼운 쪽에 무게추를 올려서 균형을 맞추려고 한다. 무게추는 1g, 2g, 5g, 10g, 20g, 50g, 100g 7종류가 있고, 무게추의 개수에는 제한이 없다.


입력 받은 자갈을 위 규칙에 따라 양팔저울에 올렸을 때, 최종적으로 평형을 맞추는데 추가적으로 필요한 무게추의 최소 개수를 구하는 프로그램을 작성하시오.","입력은 표준입력을 사용한다. 첫 번째 줄에 자갈 개수를 나타내는 양의 정수 $n$ ($2 ≤ n ≤ 10\,000$)이 주어진다. 다음 줄에 $n$ 개의 수들이 주어지는데, 이들은 번호 순서대로 자갈의 무게이다. 자갈의 무게는 각각 $1$이상이며, 모든 자갈의 무게의 총합은 $10\,000\,000$이하이다.",출력은 표준출력을 사용한다. 최종적으로 평형을 맞추는데 추가적으로 필요한 무게추의 최소 개수를 한 줄에 출력한다.,"7
3 1 4 1 5 9 2

---

4
2 4 6 4

---

5
2 5 3 1 2","2

---

0

---

1",
17960,3차원 점과 쿼리,Diamond III,"3차원 평면에 찍힌 N개의 점이 주어질 때 다음 쿼리를 처리하는 프로그램을 작성하시오




l
x
 l
y
 l
z
 r
x
 r
y
 r
z
 : 점 (l
x
, l
y
, l
z
)과 점 (r
x
, r
y
, r
z
)을 꼭짓점으로 하는 직육면체 영역에 포함된 점의 갯수를 출력한다.




 


직육면체의 모든 모서리는 축에 평행하며 주어지는 (l
x
, l
y
, l
z
)와 (r
x
, r
y
, r
z
)를 연결한 선은 이 직육면체의 대각선이다","첫 번째 줄에 점의 수 N과 쿼리의 수 Q가 공백으로 구분하여 주어진다. (1 ≤ N, Q ≤ 10
5
)


다음 N개의 줄에 걸쳐 점의 좌표를 의미하는 세 정수 x, y, z가 공백으로 구분하여 주어진다. (0 ≤ x, y, z ≤ 10
9
)


다음 Q개의 줄에 걸쳐 6개의 정수 a
i
, b
i
, c
i
, d
i
, e
i
, f
i
가 주어진다. (0 ≤ a
i
, b
i
, c
i
, d
i
, e
i
, f
i 
< 2
63
)


i번째 쿼리의 l
x
 l
y
 l
z
 r
x
 r
y
 r
z
는 다음과 같다.




l
x
 = (a
i
 xor S
i-1
) mod (10
9
 + 1)


l
y
 = (b
i
 xor S
i-1
) mod (10
9
 + 1)


l
z
 = (c
i
 xor S
i-1
) mod (10
9
 + 1)


r
x
 = (d
i
 xor S
i-1
) mod (10
9
 + 1)


r
y
 = (e
i
 xor S
i-1
) mod (10
9
 + 1)


r
z
 = (f
i
 xor S
i-1
) mod (10
9
 + 1)




S
i
 = S
i-1
 + ans
i
 이며 S
0
는 0이다.",Q개의 줄에 각 쿼리의 정답을 순서대로 출력한다.,"5 8
1 0 5
1 1 10
5 1 10
0 10 5
2 10 0
0 0 3 5 5 8
0 0 2 6 5 6
1 1 0 2 4 11
2 2 6 7 9 4
2 3 1 0 9 4
5 4 0 14 5 14
6 6 2 1 2 14
6 7 3 15 5 0","1
0
2
0
1
3
0
1",
2672,여러 직사각형의 전체 면적 구하기,Gold II,"밑변이 모두 x축에 평행한 N개의 직사각형이 주어질 때, 이 N개의 직사각형들이 차지하는 면적을 구하는 프로그램을 작성하시오. 여기서 주어진 직사각형들은 서로 겹칠 수도 있으며, 변이나 꼭짓점을 공유할 수도 있다.","첫째 줄에 직사각형의 개수 N(1 ≤ N ≤ 30)이 주어지고 그 다음 N줄에는 각각의 직사각형에 대한 자료가 주어진다. 이 자료는 4개의 숫자로 표시되는데 첫째, 둘째 숫자는 직사각형의 왼쪽 아래 모서리의 x좌표, y좌표이고 셋째 숫자는 폭, 넷째 숫자는 높이를 나타낸다. 각 수는 최대 소수점 이하 한 자리까지 주어지며, 1000.0보다 작거나 같은 양의 실수이다.","첫째 줄에 N개의 직사각형이 차지하는 면적을 소수점 이하 2자리까지 출력한다. 단, 값이 소수 부분이 없이 정수로 맞아떨어지는 경우는 정수 부분만 출력한다.","4
52.7 22.9 27.3 13.3
68.8 57.6 23.2 8.0
20.0 48.0 37.0 23.5
41.5 36.2 27.3 21.4",1853.61,
1956,운동,Gold IV,"V개의 마을와 E개의 도로로 구성되어 있는 도시가 있다. 도로는 마을과 마을 사이에 놓여 있으며, 일방 통행 도로이다. 마을에는 편의상 1번부터 V번까지 번호가 매겨져 있다고 하자.


당신은 도로를 따라 운동을 하기 위한 경로를 찾으려고 한다. 운동을 한 후에는 다시 시작점으로 돌아오는 것이 좋기 때문에, 우리는 사이클을 찾기를 원한다. 단, 당신은 운동을 매우 귀찮아하므로, 사이클을 이루는 도로의 길이의 합이 최소가 되도록 찾으려고 한다.


도로의 정보가 주어졌을 때, 도로의 길이의 합이 가장 작은 사이클을 찾는 프로그램을 작성하시오. 두 마을을 왕복하는 경우도 사이클에 포함됨에 주의한다.","첫째 줄에 V와 E가 빈칸을 사이에 두고 주어진다. (2 ≤ V ≤ 400, 0 ≤ E ≤ V(V-1)) 다음 E개의 줄에는 각각 세 개의 정수 a, b, c가 주어진다. a번 마을에서 b번 마을로 가는 거리가 c인 도로가 있다는 의미이다. (a → b임에 주의) 거리는 10,000 이하의 자연수이다. (a, b) 쌍이 같은 도로가 여러 번 주어지지 않는다.",첫째 줄에 최소 사이클의 도로 길이의 합을 출력한다. 운동 경로를 찾는 것이 불가능한 경우에는 -1을 출력한다.,"3 4
1 2 1
3 2 1
1 3 5
2 3 2",3,
25397,점 연결하기,Diamond II,"수평선 상에 
N
개의 점이 있다. 
N
개의 점은 서로 다른 위치에 존재하며, 왼쪽부터 1번부터 
N
번까지의 번호가 붙어 있다. 각 점에는 색이 있어 
i
번 점의 색깔은 
A
i
이다. 당신은 두 점을 연결하는 선을 여러개 긋고 싶어한다. 그러나 점을 연결하는 선에는 다음과 같은 제한이 존재한다.




동일한 색을 가진 두 점은 이을 수 없다.


점들을 잇는 선은 수평선보다 위에 있어야 한다. 즉, 집들이 있는 수평선을 y=0이라고 할 때, 점을 잇는 선들은 양 끝점을 제외한 모든 부분이 y>0 영역 내에 존재하는 곡선이라고 생각할 수 있다.


점들을 잇는 선들끼리는 교차할 수 없다. (끝점을 공유하는 것은 가능하다)




예를 들어, 아래와 같이 4개의 점이 있고 1, 2번 점은 붉은색, 3, 4번 점은 푸른색인 경우 1번 점과 4번 점, 2번 점과 3번 점, 2번 점과 4번 점 사이에 선을 연결하여 총 3개를 그을 수 있다.




선을 4개 그으려면 3가지 제한 중 적어도 하나 이상을 위반하게 되므로 이 경우 3개가 최대이다. 각 점의 색깔이 주어질 때, 어떤 제한도 위반하지 않으면서 두 점 사이를 연결하는 선을 최대한 많이 그리는 방법을 찾아 각 선이 어떤 두 점을 연결하는지 출력하라. 가능한 여러 방법이 존재하는 경우, 그 중 하나를 출력하면 정답으로 인정된다.","첫 줄에는 테스트 케이스의 개수 
T(1
 ≤ 
T
 ≤ 101)
가
 주어진다.


각 테스트 케이스의 첫 줄에는 집의 수 
N
과 색의 종류 
M
이 주어진다. (2
 
≤ 
N
 ≤ 30 000, 2 ≤ 
M
 ≤ 
N
).


각 테스트 케이스의 둘째 줄에는 각 점의 색깔 
A
1
,
A
2
, ..., 
A
N
이 주어진다. (1 ≤ 
A
i
 ≤ 
M
).


전체 테스트 케이스의 N의 합은 200 000을 넘지 않는다.","각 테스트 케이스마다 첫 줄에는 “Case #C”를 출력하여야 한다. 이때 C는 테스트 케이스의 번호이다.


그 다음 줄에는 두 점 사이를 연결하는 선의 최대 개수 
K
를 출력한다.


그 다음 
K
줄에 걸쳐 각 선이 연결하는 두 점의 번호를 출력한다.","3
4 2
1 1 2 2
4 2
1 2 1 2
3 3
1 2 3","Case #1
3
1 4
2 3
2 4
Case #2
4
1 2
1 4
2 3
3 4
Case #3
3
1 2
2 3
1 3",
13318,위험한 해싱,Diamond II,"string matching 알고리즘에는 여러 가지가 있다. KMP 알고리즘이나 Boyer­Moore 알고리즘이 그 예시이다. 하지만 지구이는 KMP를 이해할 수 없었고, Boyer­Moore는 시간복잡도가 너무 컸다. 결국 지구이는 틀릴 확률이 있지만, 간단한 방법인 해싱을 즐겨 사용하게 되었다. 해싱은 문자열을 숫자 하나로 바꾸는 해시 함수를 하나 정의한 후, 이 값이 같은지 다른지를 통해 문자열이 같은지 판별하는 방법이다.


지구이는 해시 함수를 다음과 같이 정의했다.


길이가 n인 문자열 d[0] ~ d[n­1]와 임의의 숫자 p에 대하여 해시 함수 값은 아래와 같다. (d[i]는 해당 문자의 ASCII 코드 값이다.)


H(p, d) = p
0
 * d[0] + p
1
 * d[1] + ... + p
n-1
 * d[n­1] (mod (10^9 + 7))


지구이는 Codeforces 대회에서 H(29, d)를 해시 함수로 사용하였다. 이는 H(29, d) = H(29, e)인 두 문자열 d, e가 있다면, d, e는 같은 문자열로 판별하는 것을 의미한다. 하지만 우연히 같은 룸에 도토리가 있었고, 도토리는 해시 값이 같은 두 문자열을 찾아 핵을 성공시켰다.


결국 지구이는 그 문제를 풀지 못했으며, 도토리에게 해싱이 너무 약했기 때문에 틀렸다는 사실을 듣게 되었다. 그 후로 지구이는 해시 함수로 H(29, d) 뿐만이 아니라, p의 값이 31, 37, 41, 43, 47, 53, 59, 61, 67인 해시 함수도 사용하기로 했다. 즉, 문자열 각각에 대하여 10개의 해시 함수를 계산한 후, 모든 해시 함수의 값이 같을 때만 두 문자열이 같다고 판별하는 것이다.


이제 지구이는 자신이 틀릴 리가 없다고 생각하고 있다. 해시 함수 10개의 값이 같은 문자열 2개를 만들어 KMP의 아름다움을 보여주자!


지구이의 코드는 
여기
에 있다.",입력은 없다.,"첫 번째 줄에 문자열 A를 출력한다.


두 번째 줄에 문자열 B를 출력한다.


문자열 2개는 길이는 같되 서로 달라야 하며, 길이는 300000 이하여야 한다. 또한, 문자열은 알파벳 소문자로만 구성되어야 한다.


출력 예시는 답이 아님에 주의하라.",,"aaaaaa
bbbbbb",
20161,왜 동전은 하나씩만 뒤집는 거야,Platinum IV,"영원한 건 절대 없어


결국에 넌 변했지


이유도 없어 진심이 없어


사랑 같은 소리 따윈 집어 쳐


오늘밤은 삐딱하게




<삐딱하게>를 감명 깊게 들은 정훈이는 삐딱해졌다. 정훈이는 혼자서 
N
개의 동전을 뒤집는 놀이를 조용히 하고 있었다. 원하는 동전을 하나 뒤집는 방식까지 불만인 정훈이는 화가 나서 책상을 쳤다. 그랬더니 한 번에 
K
개의 연속된 동전 중에 하나를 제외하고 모두 뒤집어졌다.


놀란 정훈이는 몇 번 해보다가 삐딱한 마음으로 책상을 치면 지정한 연속된 
K
개의 동전에서 원하는 동전 하나를 제외한 모두를 뒤집는 능력을 발견했다. 신나서 책상을 두드리던 정훈이는 손이 아파 이 능력만을 이용하여 동전들을 현재 상태에서 원하는 상태로 만드는 능력의 최소 사용 횟수를 구하려고 한다.


최소 횟수를 구하려고 하니 또 불만이 생긴 정훈이를 도와 최소 횟수를 구하자.","첫째 줄에 두 정수 동전의 개수 
N
 (1 ≤ 
N
 ≤ 100)과 뒤집는 범위 
K
 (1 ≤ 
K
 ≤ min(10, 
N
))가 주어진다.


다음 줄에는 동전의 현재 상태가 주어진다. 0이 앞면, 1이 뒷면이다.


그다음 줄에는 원하는 동전의 상태가 주어진다.","정훈이가 책상을 쳐서 동전을 뒤집는 최소 횟수를 출력한다.


불가능한 경우 -1을 출력한다.","5 2
0 0 0 0 0
1 1 1 0 0

---

5 5
1 0 1 1 1
0 1 0 1 1

---

5 3
0 0 0 0 0
0 1 0 1 0","3

---

-1

---

1",
